---
displayed_sidebar: "Japanese"
---

# ルーチンロード

## ロードのパフォーマンスを改善するにはどうすればよいですか？

**方法1：実際のロードタスク並列処理を増やす** ロードジョブをできるだけ多くの並列ロードタスクに分割することで実現できます。

> **注意**
>
> この方法はより多くのCPUリソースを消費し、多数のタブレットバージョンを引き起こす可能性があります。

実際のロードタスク並列処理は、いくつかのパラメータで構成される以下の数式で決定されます。BEノードの数または消費するパーティションの数の上限があります。

```Plaintext
min(生存_BE数、パーティション_数、望ましい並列数、最大_ルーチンロード_タスク並列数)
```

パラメータの説明：

- `生存_BE数`：生存するBEノードの数。
- `パーティション_数`：消費するパーティションの数。
- `望ましい並列数`：ルーチンロードジョブの望ましいロードタスク並列処理の数。デフォルト値は `3` です。このパラメータを設定して実際のロードタスク並列処理を増やすためにこのパラメータをより高い値に設定できます。
  - ルーチンロードジョブを作成していない場合、[CREATE ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/CREATE_ROUTINE_LOAD.md) を使用する際にこのパラメータを設定する必要があります。
  - ルーチンロードジョブを既に作成している場合、このパラメータを変更するには[ALTER ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/ALTER_ROUTINE_LOAD.md) を使用する必要があります。
- `最大_ルーチンロード_タスク並列数`：ルーチンロードジョブのデフォルトの最大タスク並列処理数。デフォルト値は `5` です。このパラメータはFE動的パラメータです。詳細と構成方法については[パラメータ構成](../../administration/Configuration.md#loading-and-unloading)を参照してください。

したがって、消費するパーティションの数と生存するBEノードの数が他の2つのパラメータよりも大きい場合、`望ましい並列数`と`最大_ルーチンロード_タスク並列数`パラメータの値を増やして実際のロードタスク並列処理を増やすことができます。

例えば、消費するパーティションの数が `7` で、生存するBEノードの数が `5` であり、`最大_ルーチンロード_タスク並列数`がデフォルト値 `5` の場合、この場合、ロードタスク並列処理を上限まで増やす必要がある場合は、`望ましい並列数`を `5` に設定する必要があります（デフォルト値は `3` です）。そうすると、実際のタスク並列処理 `min(5,7,5,5)` は `5` と計算されます。

詳細なパラメータの説明については、[CREATE ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/CREATE_ROUTINE_LOAD.md) を参照してください。

**方法2：1つまたは複数のパーティションからルーチンロードタスクが消費するデータ量を増やす。**

> **注意**
>
> この方法はデータの読み込みに遅延を引き起こす可能性があります。

ルーチンロードタスクが消費できるメッセージの数の上限は、`最大_ルーチンロード_バッチ_サイズ`と呼ばれるロードタスクが消費できるメッセージの最大数、または`routine_load_task_consume_second`と呼ばれるメッセージの消費の最大期間です。1つのロードタスクがこれらの要件のいずれかを満たすだけのデータを消費すると、消費が完了します。これら2つのパラメータはFE動的パラメータです。詳細と構成方法については[パラメータ構成](../../administration/Configuration.md#loading-and-unloading)を参照してください。

ルーチンロードタスクによって消費されるデータ量の上限を決定するパラメータを確認するには、**be/log/be.INFO** のログを表示して詳細を分析できます。そのパラメータを増やすことで、ロードタスクで消費されるデータ量を増やすことができます。

```Plaintext
I0325 20:27:50.410579 15259 data_consumer_group.cpp:131] consumer group done: 41448fb1a0ca59ad-30e34dabfa7e47a0. consume time(ms)=3261, received rows=179190, received bytes=9855450, eos: 1, left_time: -261, left_bytes: 514432550, blocking get time(us): 3065086, blocking put time(us): 24855
```

通常、ログの`left_bytes` フィールドが `0` 以上である場合は、ロードタスクによって消費されるデータ量が`routine_load_task_consume_second` 内で `最大_ルーチンロード_バッチ_サイズ` を超えていないことを意味します。これは、スケジュールされたロードタスクのバッチが遅延することなくKafkaからすべてのデータを消費できることを意味します。この場合、`routine_load_task_consume_second` の値を大きく設定して1つまたは複数のパーティションからロードタスクが消費するデータ量を増やすことができます。

`left_bytes` フィールドが `0` 未満の場合、これはロードタスクによって消費されるデータ量が`routine_load_task_consume_second` 内で `最大_ルーチンロード_バッチ_サイズ` に達したことを意味します。Kafkaからのデータが常にスケジュールされたロードタスクのバッチを満たします。よって、Kafkaには未消費のデータが残っている可能性が高く、これが遅延の原因となります。この場合、`max_routine_load_batch_size` の値を大きく設定することができます。

## SHOW ROUTINE LOADの結果によって、ロードジョブが`PAUSED` の状態であることが示された場合は、どうすればよいですか？

- `ReasonOfStateChanged` フィールドを確認し、エラーメッセージが `Broker: Offset out of range` と報告されている場合は次のことを行います。

  **原因分析:** ロードジョブのコンシューマオフセットがKafkaパーティションに存在しません。

  **解決策:** [SHOW ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/SHOW_ROUTINE_LOAD.md) を実行し、パラメータ `Progress` でロードジョブの最新のコンシューマオフセットを確認します。その後、対応するメッセージがKafkaパーティションに存在するかどうかを確認できます。存在しない場合は、

  - ロードジョブが作成される際に指定されたコンシューマオフセットが未来のオフセットである可能性があります。
  - ロードジョブによってコンシューマオフセットが消費される前にKafkaパーティションの指定されたコンシューマオフセットのメッセージが削除されました。読み込み速度に基づいて、適切なKafkaログクリーニングポリシーや `log.retention.hours および log.retention.bytes` などのパラメータを設定することをお勧めします。

- `ReasonOfStateChanged` フィールドを確認し、エラーメッセージが `Broker: Offset out of range` と報告されていない場合は次のことを行います。

  **原因分析:** ロードタスク内のエラー行の数が閾値 `max_error_number` を超えています。

  **解決策:** `ReasonOfStateChanged` および `ErrorLogUrls` のエラーメッセージを使用して問題をトラブルシューティングおよび修正することができます。

  - データソース内のデータの形式が正しくないために発生した場合は、データ形式を確認して問題を修正する必要があります。問題が成功裏に修正された後、[RESUME ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/RESUME_ROUTINE_LOAD.md) を使用して一時停止したロードジョブを再開することができます。

  - StarRocksがデータソース内のデータ形式を解析できない原因である場合は、閾値 `max_error_number` を調整する必要があります。まず、[SHOW ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/SHOW_ROUTINE_LOAD.md) を実行して `max_error_number` の値を表示し、その後、閾値を増やすために[ALTER ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/ALTER_ROUTINE_LOAD.md) を実行できます。閾値を変更した後は、[RESUME ROUTINE LOAD](../../sql-reference/sql-statements/data-manipulation/RESUME_ROUTINE_LOAD.md) を使用して一時停止したロードジョブを再開できます。

## SHOW ROUTINE LOADの結果によって、ロードジョブが`CANCELLED` の状態であることが示された場合は、どうすればよいですか？

  **原因分析:** ロードジョブは、テーブルが削除されるなどのロード中に例外が発生しました。

  **解決策:** 問題のトラブルシューティングおよび修正の際に、`ReasonOfStateChanged` および `ErrorLogUrls` のエラーメッセージを参照できます。ただし、問題が修正された後は、キャンセルされたロードジョブを再開することはできません。

## ルーチンロードは、Kafkaから読み取り、StarRocksに書き込む際に一貫性のセマンティクスを保証できますか？

   ルーチンロードは、厳密な1回だけのセマンティクスを保証します。

   各ロードタスクは個々のトランザクションです。トランザクションの実行中にエラーが発生した場合、トランザクションは中止され、FEはロードタスクの関連パーティションの消費進捗を更新しません。次回FEがタスクキューからロードタスクをスケジュールすると、ロードタスクはパーティションの最後に保存された消費位置から消費リクエストを送信します。これにより、厳密な一貫性のセマンティクスが保証されます。