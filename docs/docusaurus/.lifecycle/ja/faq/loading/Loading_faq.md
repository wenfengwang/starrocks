---
displayed_sidebar: "Japanese"
---

# データの読み込み

## 1. "close index channel failed" または "too many tablet versions" エラーが発生した場合の対処方法

	load ジョブを頻繁に実行し、データが適切なタイミングでコンパクションされていない場合にこのエラーが発生します。その結果、ロード中に生成されるデータバージョンの数が許容されるデータバージョンの最大数（デフォルトで1000）を超えます。この問題を解決するには、次のいずれかの方法を使用してください。

	- 個々のジョブでロードされるデータの量を増やし、ロード頻度を減らす。

	- それぞれの BE の BE 構成ファイル **be.conf** の構成項目を以下のように変更し、データコンパクションを加速します。

        ```Plain
        cumulative_compaction_num_threads_per_disk = 4
        base_compaction_num_threads_per_disk = 2
        cumulative_compaction_check_interval_seconds = 2
        ```

    上記の構成項目の設定を変更した後、メモリおよび I/O が正常であることを確認する必要があります。

## 2. "Label Already Exists" エラーが発生した場合の対処方法

	このエラーが発生するのは、ロードジョブが同じStarRocksデータベース内で他のロードジョブと同じラベルを持っていて、そのロードジョブは既に正常に実行されたか、実行中であるためです。

	ストリームロードジョブは HTTP によって送信されます。通常、プログラム言語のHTTPクライアントにはリクエストの再試行ロジックが組み込まれています。StarRocks クラスタが HTTP クライアントからのロードジョブリクエストを受け取ると、すぐにリクエストの処理を開始しますが、タイムリーにジョブの結果を HTTP クライアントに返しません。その結果、HTTP クライアントは同じロードジョブリクエストを再度送信します。ただし、StarRocks クラスタは既に最初のリクエストを処理しているため、2回目のリクエストに対して `Label Already Exists` エラーを返します。

	異なるロード方法を使用して送信されたロードジョブが同じラベルを持ち、繰り返し送信されていないことを確認するために、以下のようにします。

	- FE ログを表示し、失敗したロードジョブのラベルが2回記録されているかどうかを確認します。ラベルが2回記録されている場合、クライアントはロードジョブリクエストを2回送信しています。

  	  > **注記**
  	  >
      > StarRocks クラスタはロード方法に基づいてロードジョブのラベルを区別しません。したがって、異なるロード方法を使用して送信されたロードジョブは同じラベルを持つ可能性があります。

	- "xxx" というラベルを持つロードジョブが**FINISHED**状態にあるかどうかを確認するために、SHOW LOAD WHERE LABEL = "xxx" を実行します。

	  > **注記**
	  >
	  > `xxx` は確認したいラベルです。

	ロードジョブを送信する前に、データをロードするために必要な時間のおおまかな量を計算して、クライアント側のリクエストタイムアウト期間を適切に調整することをお勧めします。これにより、クライアントが複数回ロードジョブリクエストを送信するのを防ぐことができます。

## 3. "ETL_QUALITY_UNSATISFIED; msg:quality not good enough to cancel" エラーが発生した場合の対処方法

[SHOW LOAD](../../sql-reference/sql-statements/data-manipulation/SHOW_LOAD.md) を実行し、戻された実行結果のエラー URL を使用して、エラーの詳細を表示してください。

一般的なデータ品質エラーは次のとおりです。

- "convert csv string to INT failed."
  
  ソース列の文字列が、一致する宛先列のデータ型に変換できませんでした。たとえば、`abc` は数値に変換できませんでした。

- "the length of input is too long than schema."
  
  ソース列の値が、一致する宛先列でサポートされていない長さです。たとえば、CHAR データ型のソース列の値が、テーブルの作成時に指定された宛先列の最大長を超えるか、または INT データ型のソース列の値が 4 バイトを超えます。

- "actual column number is less than schema column number."
  
  指定した列区切り記号を基にソース行が解析された後、取得された列の数が、宛先テーブルの列の数よりも小さいです。ロードコマンドまたはステートメントで指定された列区切り記号が、実際にその行で使用されている列区切り記号と異なる可能性があります。

- "actual column number is more than schema column number."
  
  指定した列区切り記号を基にソース行が解析された後、取得された列の数が、宛先テーブルの列の数よりも多いです。ロードコマンドまたはステートメントで指定された列区切り記号が、実際にその行で使用されている列区切り記号と異なる可能性があります。

- "the frac part length longer than schema scale."
  
  DECIMAL 型のソース列からの値の小数部分が指定された長さを超えています。

- "the int part length longer than schema precision."
  
  DECIMAL 型のソース列からの値の整数部分が指定された長さを超えています。

- "there is no corresponding partition for this key."
  
  ソース行のパーティション列の値がパーティション範囲内にありません。

## 4. RPC タイムアウトエラーが発生した場合の対処方法

	それぞれの BE の BE 構成ファイル **be.conf** で、`write_buffer_size` 構成項目の設定を確認してください。この構成項目は BE 上のメモリブロックあたりの最大サイズを制御するために使用されます。デフォルトの最大サイズは 100 MB です。最大サイズが極端に大きい場合、リモートプロシージャコール（RPC）がタイムアウトする可能性があります。この問題を解決するには、BE 構成ファイルの `write_buffer_size` および `tablet_writer_rpc_timeout_sec` 構成項目の設定を調整してください。詳細については、[BE 構成](../../loading/Loading_intro.md#be-configurations) を参照してください。

## 5. "Value count does not match column count" エラーが発生した場合の対処方法

	ロードジョブが失敗した後、ジョブの結果で戻されたエラー URL を使用してエラーの詳細を取得し、"Value count does not match column count" エラーが見つかりました。これは、ソースデータファイルの列数と StarRocks テーブルの列数が一致しないことを示します。

	上記の問題の原因は次の通りです。

	ロードコマンドまたはステートメントで指定された列区切り記号が、ソースデータファイルで実際に使用されている列区切り記号と異なります。前述の例では、CSV 形式のデータファイルは 3 列から構成されており、カンマ (`,`) で区切られています。ただし、ロードコマンドまたはステートメントで列区切り記号として `\t` が指定されています。その結果、ソースデータファイルの3列が誤って1列にパースされます。

	ロードコマンドまたはステートメントで列区切り記号としてカンマ (`,`) を指定してください。その後、ロードジョブを再送信してください。