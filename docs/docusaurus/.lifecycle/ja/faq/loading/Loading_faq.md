---
displayed_sidebar: "Japanese"
---

# データの読み込み

## 1. 「クローズインデックスチャネルの失敗」または「タブレットバージョンが多すぎる」エラーが発生した場合の対処方法

定期的にロードジョブを実行し、データのコンパクションが適切なタイミングで行われていなかったことが原因で、ロード中に生成されるデータバージョンの数が（デフォルトで1000と設定されている）許容されるデータバージョンの最大数を超えたために、このエラーが発生します。この問題を解決するために、次のいずれかの方法を使用できます。

- 個々のジョブでロードされるデータの量を増やし、ロード頻度を低下させます。

- 各BEのBE構成ファイル **be.conf** 内の構成項目を以下のように変更し、データのコンパクションを加速させます。

    ```Plain
    cumulative_compaction_num_threads_per_disk = 4
    base_compaction_num_threads_per_disk = 2
    cumulative_compaction_check_interval_seconds = 2
    ```

  上記の構成項目の設定を変更した後は、メモリとI/Oが正常であることを確認する必要があります。

## 2. 「ラベルが既に存在しています」エラーが発生した場合の対処方法

このエラーは、ロードジョブが同じラベルを持ち、そのラベルのロードジョブが同じStarRocksデータベース内で正常に実行されているか、実行中であるために発生します。

Stream LoadジョブはHTTPに従って送信されます。一般的に、プログラム言語のHTTPクライアントにはリクエストの再試行ロジックが組み込まれています。StarRocksクラスタがHTTPクライアントからのロードジョブリクエストを受信すると、そのリクエストの処理をすぐに開始しますが、HTTPクライアントには適切なタイミングでジョブの結果が返されないため、HTTPクライアントは同じロードジョブリクエストを再度送信します。しかし、StarRocksクラスタは既に最初のリクエストを処理しているため、2回目のリクエストに対して `ラベルが既に存在しています` エラーが返されます。

異なるロード方法を使用して送信されたロードジョブが同じラベルを持ち、繰り返し送信されていないかを確認するために、次の手順を実行します。

- FEログを表示し、失敗したロードジョブのラベルが2回記録されていないかを確認します。もしラベルが2回記録されている場合、クライアントがロードジョブリクエストを2回送信しています。

  > **注意**
  >
  > StarRocksクラスタは、異なるロード方法を使用して送信されたロードジョブのラベルを区別しません。したがって、異なるロード方法を使用して送信されたロードジョブは同じラベルを持っている可能性があります。

- `SHOW LOAD WHERE LABEL = "xxx"` を実行し、同じラベルを持ち、**FINISHED** 状態にあるロードジョブを確認します。

  > **注意**
  >
  > `xxx` は確認したいラベルです。

ロードジョブを送信する前に、データをロードするのに必要なおおよその時間を計算し、クライアント側のリクエストタイムアウト期間を調整することをお勧めします。このようにすることで、クライアントがロードジョブリクエストを複数回送信するのを防ぐことができます。

## 3. 「ETL_QUALITY_UNSATISFIED; msg:quality not good enough to cancel」エラーが発生した場合の対処方法

[SHOW LOAD](../../sql-reference/sql-statements/data-manipulation/SHOW_LOAD.md) を実行し、戻された実行結果内のエラーURLを使用して、エラーの詳細を確認します。

一般的なデータ品質エラーは次のとおりです。

- "convert csv string to INT failed."
  
  ソースカラムの文字列が、一致する宛先カラムのデータ型に変換されなかったことを示します。例えば、`abc` が数値に変換されなかったことが該当します。

- "the length of input is too long than schema."
  
  ソースカラムの値が、一致する宛先カラムでサポートされていない長さを持っていることを示します。例えば、CHARデータ型のソースカラムの値が、テーブル作成時に指定された宛先カラムの最大長を超えているか、INTデータ型のソースカラムの値が4バイトを超えているかが該当します。

- "actual column number is less than schema column number."
  
  指定された列区切り記号に基づいてソース行が解析された後、取得される列の数が宛先テーブルの列数よりも少ないことを示します。ロードコマンドまたはステートメントで指定された列区切り記号が、実際にその行で使用されている列区切り記号と異なる可能性があります。

- "actual column number is more than schema column number."
  
  指定された列区切り記号に基づいてソース行が解析された後、取得される列の数が宛先テーブルの列数よりも多いことを示します。ロードコマンドまたはステートメントで指定された列区切り記号が、実際にその行で使用されている列区切り記号と異なる可能性があります。

- "the frac part length longer than schema scale."
  
  DECIMAL型のソースカラムの小数部分が指定された長さを超えていることを示します。

- "the int part length longer than schema precision."
  
  DECIMAL型のソースカラムの整数部分が指定された長さを超えていることを示します。

- "there is no corresponding partition for this key."
  
  ソース行のパーティション列の値がパーティション範囲内にないことを示します。

## 4. RPCがタイムアウトした場合の対処方法

各BEのBE構成ファイル **be.conf** 内の `write_buffer_size` 構成項目の設定を確認します。この構成項目はBE上のメモリブロックごとの最大サイズを制御するために使用されます。デフォルトの最大サイズは100 MBです。最大サイズが非常に大きい場合、Remote Procedure Call（RPC）がタイムアウトする場合があります。この問題を解決するには、BE構成ファイル内の `write_buffer_size` と `tablet_writer_rpc_timeout_sec` 構成項目の設定を調整します。詳細については、[BE configurations](../../loading/Loading_intro.md#be-configurations) を参照してください。

## 5. 「Value count does not match column count」エラーが発生した場合の対処方法

ロードジョブに失敗した後、ジョブ結果内で戻されたエラーURLを使用してエラーの詳細を取得し、ソースデータファイルの列数とStarRocksテーブルの列数の不一致を示す「Value count does not match column count」というエラーが見つかりました。

```Java
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:00Z,cpu0,80.99
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:10Z,cpu1,75.23
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:20Z,cpu2,59.44
```

この問題の原因は以下のとおりです。

ロードコマンドまたはステートメントで指定された列区切り記号が、実際にソースデータファイルで使用されている列区切り記号と異なるためです。上記の例では、CSV形式のデータファイルが3つの列で構成されており、これらの列はカンマ（`,`）で区切られています。しかし、ロードコマンドまたはステートメントで `\t` が列区切り記号として指定されています。その結果、ソースデータファイルの3つの列が誤って1つの列に解析されます。

ロードコマンドまたはステートメントで列区切り記号としてカンマ（`,`）を指定します。その後、ロードジョブを再提出します。