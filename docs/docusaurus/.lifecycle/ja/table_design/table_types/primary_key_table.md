---
displayed_sidebar: "Japanese"
---

# プライマリキーテーブル

テーブルを作成するとき、プライマリキーとソートキーを別々に定義できます。Primary Keyテーブルにデータがロードされると、StarRocksはデータを保存する前にソートキーに従ってデータをソートします。クエリは同じプライマリキーを持つレコードの中で最新のレコードを返します。一意キーのテーブルとは異なり、Primary Keyテーブルではクエリ中の集約操作は必要ありません。また、プッシュダウンプレディケートおよびインデックスをサポートしています。そのため、リアルタイムかつ頻繁にデータが更新される状況でも、Primary Keyテーブルは高いクエリ性能を提供します。

> **注意**
>
> - v3.0より前のバージョンでは、Primary Keyテーブルではプライマリキーとソートキーの切り離しをサポートしていません。
> - v3.1以降、StarRocksの共有データモードはPrimary Keyテーブルをサポートしています。v3.1.4以降、StarRocksの共有データクラスターで作成されたPrimary Keyテーブルはローカルディスクへのインデックス永続性をさらにサポートしています。

## シナリオ

- Primary Keyテーブルは、データをリアルタイムで頻繁に更新する必要がある以下のシナリオに適しています:

  - **トランザクション処理システムからリアルタイムにストリームデータをStarRocksに取り込む。** 通常、トランザクション処理システムには挿入操作に加えて多数の更新および削除操作が含まれます。トランザクション処理システムからデータをStarRocksに同期する必要がある場合は、Primary Keyテーブルを使用することをおすすめします。その後、CDC Connectors for Apache Flink®などのツールを使用して、トランザクション処理システムのバイナリログをStarRocksに同期します。StarRocksはバイナリログを使用して、テーブルのデータをリアルタイムで追加、削除、および更新します。これにより、データの同期が簡素化され、Unique Keyテーブルのマージ・オン・リード（MoR）テーブルを使用する場合と比べて3〜10倍の高いクエリ性能が提供されます。たとえば、flink-connector-starrocksを使用してデータをロードできます。詳細については、[flink-connector-starrocksを使用してデータをロードする](../../loading/Flink-connector-starrocks.md) を参照してください。

  - **個々のカラムに更新操作を実行して複数のストリームを結合する**。ユーザープロファイリングなどのビジネスシナリオでは、フラットテーブルを使用してデータアナリストが利用する分析モデルを簡素化し、多次元分析の性能を向上させることが求められます。これらのシナリオでの上流データは、ショッピングアプリ、配信アプリ、銀行アプリなどのさまざまなアプリや、ユーザーの一意のタグやプロパティを取得するために計算を行う機械学習システムなどから得られる可能性があります。Primary Keyテーブルは、個々のカラムを更新できるため、これらのシナリオに適しています。各アプリまたはシステムは、自分自身のサービス範囲内のデータを保持するカラムだけを更新できます。これにより、リアルタイムのデータの追加、削除、および更新が高いクエリ性能で利用できます。

- Primary Keyテーブルは、プライマリキーが占有するメモリ量がコントロール可能なシナリオに適しています。

  StarRocksのストレージエンジンは、Primary Keyテーブルを使用する各テーブルのプライマリキーに対してインデックスを作成します。また、テーブルにデータをロードすると、StarRocksはプライマリキーのインデックスをメモリにロードします。そのため、Primary Keyテーブルは他の3つのテーブルタイプよりも多くのメモリ容量を必要とします。**StarRocksは、プライマリキーを構成するフィールドの合計長をエンコード後に127バイトに制限しています。**

  次の特性を持つテーブルを持っている場合は、Primary Keyテーブルを検討してください:

  - テーブルには高速に変更されるデータと遅く変更されるデータの両方が含まれています。高速に変更されるデータは最近の数日間で頻繁に更新され、遅く変更されるデータはめったに更新されません。たとえば、MySQLの注文テーブルを解析およびクエリのためにリアルタイムでStarRocksと同期する必要があるとします。この例では、テーブルのデータは日ごとにパーティションされており、ほとんどの更新は最近作成された注文に対して行われます。歴史的な注文は完了後に更新されません。データロードジョブを実行すると、プライマリキーインデックスはメモリにロードされず、最近更新された注文のインデックスエントリだけがメモリにロードされます。

    次の図に示すように、テーブルのデータは日ごとにパーティションされており、最近の2つのパーティションのデータが頻繁に更新されます。

    ![Primary index -1](../../assets/3.2-1.png)

  - テーブルは数百または数千のカラムで構成されたフラットテーブルです。プライマリキーはテーブルデータのごく一部であり、メモリをごくわずかしか消費しません。たとえば、ユーザーステータスまたはプロファイルテーブルは多数のカラムで構成されていますが、ユーザーは数千万から数億です。このような状況では、プライマリキーによって消費されるメモリ量は管理可能です。

    次の図に示すように、テーブルにはわずかな行しか含まれず、プライマリキーはテーブルのごく一部です。

    ![Primary index -2](../../assets/3.2.4-2.png)

### 原則

Primary Keyテーブルは、StarRocksが提供する新しいストレージエンジンをベースに設計されています。Primary Keyテーブルのメタデータ構造および読み取り/書き込みメカニズムは、Unique Keyテーブルとは異なります。したがって、Primary Keyテーブルは集約操作を必要とせず、プッシュダウンプレディケートおよびインデックスをサポートしています。これにより、クエリ性能が飛躍的に向上します。

Duplicate Keyテーブルは、MoRポリシーを採用しています。MoRはデータ書き込みを効率的に行いますが、複数のデータバージョンをオンラインで集約する必要があります。さらに、マージ演算子はプッシュダウンプレディケートおよびインデックスのサポートをしていません。その結果、クエリ性能が低下します。

Primary Keyテーブルは、各レコードが一意のプライマリキーを持つようにするために、Delete+Insertポリシーを採用しています。これにより、Primary Keyテーブルではマージ操作を必要としません。詳細は次の通りです:

- StarRocksは、レコードの更新操作のリクエストを受け取ると、プライマリキーインデックスを検索してレコードを見つけ、レコードを削除マークし、新しいレコードを挿入します。つまり、StarRocksは更新操作を削除操作にプラスして挿入操作に変換します。

- StarRocksは、レコードの削除操作のリクエストを受け取ると、プライマリキーインデックスを検索してレコードを削除マークします。

## テーブルを作成

例1: 日次で注文を解析する必要があるとします。この例では、`orders`という名前のテーブルを作成し、`dt`と`order_id`をプライマリキーとし、他のカラムをメトリックカラムとして定義します。

```SQL
create table orders (
    dt date NOT NULL,
    order_id bigint NOT NULL,
    user_id int NOT NULL,
    merchant_id int NOT NULL,
    good_id int NOT NULL,
    good_name string NOT NULL,
    price int NOT NULL,
    cnt int NOT NULL,
    revenue int NOT NULL,
    state tinyint NOT NULL
) PRIMARY KEY (dt, order_id)
PARTITION BY RANGE(`dt`) (
    PARTITION p20210820 VALUES [('2021-08-20'), ('2021-08-21')),
    PARTITION p20210821 VALUES [('2021-08-21'), ('2021-08-22')),
    ...
    PARTITION p20210929 VALUES [('2021-09-29'), ('2021-09-30')),
    PARTITION p20210930 VALUES [('2021-09-30'), ('2021-10-01'))
) DISTRIBUTED BY HASH(order_id)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

> **ご注意**
>
> - テーブルを作成する際は、`DISTRIBUTED BY HASH`句を使用してバケティング列を指定する必要があります。詳細については、[バケティング](../Data_distribution.md#design-partitioning-and-bucketing-rules)を参照してください。
> - v2.5.7以降、StarRocksはテーブルを作成したりパーティションを追加したりする際にバケツの数（BUCKETS）を自動的に設定できます。バケットの数を手動で設定する必要がなくなりました。詳細については、[バケツの数を決定する](../Data_distribution.md#determine-the-number-of-buckets)を参照してください。

例2: ユーザーの住所や最終アクティブ時間などのディメンションからリアルタイムでユーザーの行動を分析する必要があるとします。この場合、`user_id`カラムをプライマリキーとし、`address`と`last_active`カラムの組み合わせをソートキーとして定義できます。

```SQL
create table users (
    user_id bigint NOT NULL,
    name string NOT NULL,
    email string NULL,
    address string NULL,
    age tinyint NULL,
    sex tinyint NULL,
    last_active datetime,
    property0 tinyint NOT NULL,
    property1 tinyint NOT NULL,
    property2 tinyint NOT NULL,
    property3 tinyint NOT NULL,
    ....
) PRIMARY KEY (user_id)
DISTRIBUTED BY HASH(user_id)
ORDER BY(`address`,`last_active`)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

## 使用上の注意点

- テーブルのプライマリキーに関しては、次の点に注意してください:
  - プライマリキーは、`PRIMARY KEY`キーワードを使用して定義されます。

  - プライマリキーは一意制約が適用される列で作成され、プライマリキー列の名前は変更できません。

  - プライマリキー列は、次のデータ型のいずれかにできます: BOOLEAN、TINYINT、SMALLINT、INT、BIGINT、LARGEINT、STRING、VARCHAR、DATE、およびDATETIME。ただし、プライマリキー列を`NULL`として定義することはできません。

  - パーティション列およびバケット列は、プライマリキーに参加する必要があります。

- 主キー列の数と総長は適切に設計する必要があり、メモリを節約します。データ型のメモリ使用量が少ない列を特定し、これらの列を主キーとして定義することをお勧めします。このようなデータ型にはINTおよびBIGINTが含まれます。VARCHARデータ型の列を主キーにすることはお勧めしません。

- テーブルを作成する前に、主キーのインデックスがテーブルのデータ型と行数に基づいてどれだけのメモリを占有するかを見積もることをお勧めします。この方法により、テーブルがメモリを使い果たすことを防ぐことができます。次の例は、主キーのインデックスが占有するメモリの計算方法を説明しています:

  - DATEデータ型で4バイトを占有する`dt`列と、BIGINTデータ型で8バイトを占有する`id`列が主キーとして定義されていると仮定します。この場合、主キーの長さは12バイトです。

  - テーブルにはホットデータの10,000,000行が含まれ、3つのレプリカに保存されています。

  - 上記の情報に基づいて、主キーのインデックスが以下の式に基づいて945 MBを占有しているとします:

    (12 + 9) x 10,000,000 x 3 x 1.5 = 945 (MB)

    上記の式では、`9`は各行ごとの変更できないオーバーヘッドであり、`1.5`はハッシュテーブルごとの平均的な余分なオーバーヘッドです。

- `enable_persistent_index`: 主キーインデックスをディスクに永続化してメモリに格納することで、メモリ消費を抑えることができます。通常、主キーインデックスは、以前と比べてメモリの1/10しか占有しません。テーブルを作成する際に、`PROPERTIES`でこのプロパティを設定することができます。有効な値はtrueまたはfalseです。デフォルト値はfalseです。

  > - テーブル作成後にこのパラメータを変更する場合は、[ALTER TABLE](../../sql-reference/sql-statements/data-definition/ALTER_TABLE.md)における「テーブルのプロパティを変更する」の部分を参照してください。
  > - SSDを使用している場合は、このプロパティをtrueに設定することをお勧めします。
  > - バージョン2.3.0から、StarRocksはこのプロパティの設定をサポートしています。
  > - バージョン3.1以降、StarRocksの共有データモードはプライマリキーテーブルをサポートしています。バージョン3.1.4以降、StarRocks共有データクラスターで作成されたプライマリキーテーブルはローカルディスクへのインデックス永続化をさらにサポートしています。

- `ORDER BY`キーワードを使用して、ソートキーを任意の列の組み合わせとして指定できます。

  > **注意**
  >
  > ソートキーが指定されている場合、プレフィックスインデックスはソートキーに従って構築されます。ソートキーが指定されていない場合、プレフィックスインデックスは主キーに従って構築されます。

- ALTER TABLEを使用してテーブルのスキーマを変更できますが、以下の制限が存在します:
  - 主キーの変更はサポートされていません。
  - ALTER TABLE ... ORDER BY ... を使用してソートキーを再割り当てることはサポートされていますが、ソートキーの削除はサポートされていません。ソートキーの列のデータ型の変更もサポートされていません。
  - 列の順序の調整はサポートされていません。

- バージョン2.3.0以降、プライマリキー列以外の列では、BITMAPおよびHLLデータ型がサポートされています。

- テーブルを作成する際に、プライマリキー列以外にBITMAPインデックスまたはBloom Filterインデックスを作成することができます。

- バージョン2.4.0以降、プライマリキーテーブルベースの非同期マテリアライズドビューを作成することができます。

## 次の手順

テーブルを作成した後、ロードジョブを実行してデータをプライマリキーテーブルにロードすることができます。サポートされているロード方法の詳細については、[データロードの概要](../../loading/Loading_intro.md)を参照してください。

プライマリキーテーブルのデータを更新する必要がある場合は、[ロードジョブを実行](../../loading/Load_to_Primary_Key_tables.md)するかDMLステートメント（[UPDATE](../../sql-reference/sql-statements/data-manipulation/UPDATE.md)または[DELETE](../../sql-reference/sql-statements/data-manipulation/DELETE.md)）を実行することができます。また、これらの更新操作は原子性を保証します。