---
displayed_sidebar: "Japanese"
---

# プライマリキー テーブル

テーブルを作成するときには、プライマリキーとソートキーを別々に定義できます。プライマリキーテーブルにデータがロードされると、StarRocks はデータを保存する前にソートキーに従ってデータを並び替えます。クエリは、同じプライマリキーを持つ一群のレコードの中で最新のレコードを返します。ユニークキーテーブルとは異なり、プライマリキーテーブルではクエリ中の集約操作が不要であり、プリディケートとインデックスのプッシュダウンをサポートしています。そのため、プライマリキーテーブルはリアルタイムかつ頻繁なデータ更新にもかかわらず高速なクエリパフォーマンスを提供できます。

> **注意**
>
> - v3.0 より前のバージョンでは、プライマリキーテーブルはプライマリキーとソートキーを切り離すことをサポートしていません。
> - v3.1 以降、StarRocks の共有データモードはプライマリキーテーブルをサポートしています。v3.1.4 以降、StarRocks の共有データクラスター内で作成されたプライマリキーテーブルはローカルディスク上へのインデックスの永続化をさらにサポートしています。

## シナリオ

- プライマリキーテーブルは、リアルタイムでデータが頻繁に更新される次のようなシナリオに適しています：

  - **トランザクション処理システムからリアルタイムでストリーミングデータを StarRocks に流し込む。** 通常、トランザクション処理システムでは挿入操作に加えて大量の更新および削除操作が発生します。トランザクション処理システムのデータを StarRocks に同期する必要がある場合は、プライマリキーテーブルを使用することをお勧めします。その後、Apache Flink® の CDC コネクタなどのツールを使用して、トランザクション処理システムのバイナリログを StarRocks に同期できます。StarRocks はバイナリログを使用して、テーブル内のデータをリアルタイムに追加、削除、更新します。これにより、データの同期が容易になり、ユニークキーテーブルの Merge on Read（MoR）テーブルを使用した場合と比較して、3 〜 10 倍高速なクエリパフォーマンスが提供されます。たとえば、flink-connector-starrocks を使用してデータを読み込むことができます。詳細については、[flink-connector-starrocks を使用したデータの読み込み](../../loading/Flink-connector-starrocks.md) を参照してください。

  - **個々の列に更新操作を実行して複数のストリームを結合する。** ユーザープロファイリングなどのビジネスシナリオでは、複数の次元分析パフォーマンスを向上させ、データアナリストが使用する分析モデルを簡素化するためにフラットテーブルを使用することが好ましいです。これらのシナリオのアップストリームデータは、ショッピングアプリ、配信アプリ、銀行アプリなどのさまざまなアプリや、ユーザーの異なるタグやプロパティを取得するために計算を行う機械学習システムなどから取得される可能性があります。プライマリキーテーブルは、これらのシナリオに非常に適しており、それぞれの列を更新することをサポートしています。各アプリやシステムは、自分自身のサービス範囲内でデータを保持する列のみを更新できますが、リアルタイムのデータ追加、削除、更新を高速なクエリパフォーマンスで利用できます。

- プライマリキーテーブルは、プライマリキーによって占められるメモリが制御可能なシナリオに適しています。

  StarRocks のストレージエンジンは、プライマリキーテーブルを使用する各テーブルのプライマリキーのためにインデックスを作成します。また、テーブルにデータをロードすると、StarRocks はプライマリキーインデックスをメモリにロードします。そのため、プライマリキーテーブルは他のテーブルの種類よりも多くのメモリ容量を必要とします。**StarRocks は、プライマリキーを構成するフィールドの合計長をエンコード後 127 バイトまでに制限します。**

  テーブルに以下の特性がある場合は、プライマリキーテーブルの使用を検討してください：

  - テーブルには、急速に変化するデータとゆっくり変化するデータが含まれています。急速に変化するデータは最新の数日間で頻繁に更新され、ゆっくり変化するデータはほとんど更新されません。たとえば、MySQL の注文テーブルを分析およびクエリ用に StarRocks にリアルタイムで同期する必要があるとします。この例では、テーブルのデータは日ごとにパーティションされ、ほとんどの更新は最近数日で作成された注文に実行されます。履歴的な注文は完了時に更新されなくなります。データロードジョブを実行すると、プライマリキーインデックスはメモリにロードされず、最近更新された注文のみのインデックスエントリがメモリにロードされます。

    次の図のように、テーブルのデータは日ごとにパーティションされ、最近の 2 つのパーティションのデータが頻繁に更新されます。

    ![プライマリ インデックス -1](../../assets/3.2-1.png)

  - テーブルは、何百もしくは何千もの列で構成されたフラットテーブルです。プライマリキーはテーブルデータの一部であり、メモリをほとんど消費しません。たとえば、ユーザーステータスやプロファイルテーブルは大量の列で構成されていますが、ユーザーは数千万人単位です。このような状況では、プライマリキーによって消費されるメモリ量が制御できます。

    次の図のように、テーブルにはわずかな行しか含まれず、テーブルのプライマリキーはテーブルのほんの一部しか占めていません。

    ![プライマリ インデックス -2](../../assets/3.2.4-2.png)

### 原則

プライマリキーテーブルは、StarRocks が提供する新しいストレージエンジンに基づいて設計されています。プライマリキーテーブルのメタデータ構造と読み書きメカニズムは、ユニークキーテーブルとは異なります。そのため、プライマリキーテーブルは集約操作を必要とせず、プリディケートとインデックスのプッシュダウンをサポートしています。これにより、クエリパフォーマンスが大幅に向上します。

ユニークキーテーブルは MoR ポリシーを採用しています。MoR はデータの書き込みを合理化しますが、複数のデータバージョンをオンラインで集約する必要があります。また、マージ演算子はプリディケートとインデックスのプッシュダウンをサポートしていません。その結果、クエリパフォーマンスが低下します。

プライマリキーテーブルは、各レコードが一意のプライマリキーを持つようにするために、Delete+Insert ポリシーを採用しています。したがって、プライマリキーテーブルにはマージ操作が不要です。詳細は次のとおりです：

- StarRocks がレコードの更新操作のリクエストを受け取ると、プライマリキーインデックスを検索してレコードを削除し、新しいレコードを挿入します。つまり、StarRocks は更新操作を削除操作と挿入操作に変換します。

- StarRocks がレコードの削除操作を受け取ると、プライマリキーインデックスを検索してレコードを削除します。

## テーブルの作成

例1：日次で注文を分析する必要があるとします。この場合、`orders` という名前のテーブルを作成し、`dt` と `order_id` をプライマリキーに定義し、他の列をメトリック列として定義します。

```SQL
create table orders (
    dt date NOT NULL,
    order_id bigint NOT NULL,
    user_id int NOT NULL,
    merchant_id int NOT NULL,
    good_id int NOT NULL,
    good_name string NOT NULL,
    price int NOT NULL,
    cnt int NOT NULL,
    revenue int NOT NULL,
    state tinyint NOT NULL
) PRIMARY KEY (dt, order_id)
PARTITION BY RANGE(`dt`) (
    PARTITION p20210820 VALUES [('2021-08-20'), ('2021-08-21')),
    PARTITION p20210821 VALUES [('2021-08-21'), ('2021-08-22')),
    ...
    PARTITION p20210929 VALUES [('2021-09-29'), ('2021-09-30')),
    PARTITION p20210930 VALUES [('2021-09-30'), ('2021-10-01'))
) DISTRIBUTED BY HASH(order_id)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

> **注意**
>
> - テーブルを作成する際には、 `DISTRIBUTED BY HASH` 句を使用してバケット列を指定する必要があります。詳細については、[バケットング](../Data_distribution.md#design-partitioning-and-bucketing-rules) を参照してください。
> - v2.5.7 以降、StarRocks は、テーブルを作成するかパーティションを追加する際に自動的にバケットの数（BUCKETS）を設定できます。個別にバケットの数を設定する必要はもはやありません。詳細については、[バケットの数を決定する](../Data_distribution.md#determine-the-number-of-buckets) を参照してください。

例2：ユーザーアドレスや最終アクティブ時間などの次元からユーザーの行動をリアルタイムで分析する必要があるとします。この場合、`user_id` 列をプライマリキーに定義し、 `address` と `last_active` の組み合わせをソートキーに定義します。

```SQL
create table users (
    user_id bigint NOT NULL,
    name string NOT NULL,
    email string NULL,
    address string NULL,
    age tinyint NULL,
    sex tinyint NULL,
    last_active datetime,
    property0 tinyint NOT NULL,
    property1 tinyint NOT NULL,
    property2 tinyint NOT NULL,
    property3 tinyint NOT NULL,
    ....
) PRIMARY KEY (user_id)
DISTRIBUTED BY HASH(user_id)
ORDER BY(`address`,`last_active`)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

## 使用上の注意

- テーブルのプライマリキーに関する次の点に注意してください：
  - プライマリキーは、 `PRIMARY KEY` キーワードを使用して定義します。

  - プライマリキーは、一意制約が適用されている列に作成する必要があり、プライマリキーカラムの名前を変更することはできません。

  - プライマリキーカラムは、 BOOLEAN、TINYINT、SMALLINT、INT、BIGINT、LARGEINT、STRING、VARCHAR、DATE、DATETIME のいずれかのデータ型である必要があります。ただし、プライマリキーカラムは `NULL` として定義できません。

  - パーティション列とバケット列はプライマリキーに参加する必要があります。
- 主キー列の数と合計長は、メモリを節約するために適切に設計する必要があります。データ型がメモリを占有していない列を特定し、これらの列を主キーとして定義することを推奨します。このようなデータ型には、INTおよびBIGINTなどがあります。VARCHARデータ型の列を主キーに参加させないことをお勧めします。

- テーブルを作成する前に、主キーインデックスがテーブルの行数と主キー列のデータ型に基づいて占有するメモリを見積もることをお勧めします。これにより、テーブルがメモリ不足に陥るのを防ぐことができます。以下の例は、主キーインデックスが占有するメモリを計算する方法を説明しています。
  - DATEデータ型で4バイトを占有する「dt」列と、BIGINTデータ型で8バイトを占有する「id」列を主キーとして定義すると仮定します。この場合、主キーの長さは12バイトです。

  - ホットデータを含むテーブルが10,000,000行あり、3つのレプリカに保存されているとします。

  - 上記の情報に基づくと、主キーインデックスが以下の式によって945MBを占有することになります。

    (12 + 9) x 10,000,000 x 3 x 1.5 = 945 (MB)

    上記の式において、「9」は行ごとの不変のオーバーヘッドであり、「1.5」はハッシュテーブルごとの平均的な余分なオーバーヘッドです。

- `enable_persistent_index`: 主キーインデックスをディスクに永続化し、メモリ上での占有を避けることができます。一般的に、永続化することで、主キーインデックスが従来よりもメモリの1/10しか占有しなくなります。テーブルを作成する際にこのプロパティを`PROPERTIES`に設定できます。有効な値はtrueまたはfalseです。デフォルト値はfalseです。

  > - テーブル作成後にこのパラメータを変更する場合は、[ALTER TABLE](../../sql-reference/sql-statements/data-definition/ALTER_TABLE.md)の「テーブルのプロパティを変更」の部分を参照してください。
  > - SSDが使用されている場合は、このプロパティをtrueに設定することをお勧めします。
  > - StarRocksはバージョン2.3.0以降でこのプロパティをサポートしています。
  > - バージョン3.1以降、StarRocksの共有データモードは主キーテーブルをサポートしています。バージョン3.1.4以降、StarRocksの共有データクラスタで作成された主キーテーブルは、ローカルディスクへのインデックスの永続化をさらにサポートしています。

- `ORDER BY`キーワードを使用して、任意の列の順列と組み合わせとしてソートキーを指定できます。

  > **注意**
  >
  > ソートキーが指定されている場合、プレフィックスインデックスはソートキーに基づいて構築されます。ソートキーが指定されていない場合、プレフィックスインデックスは主キーに基づいて構築されます。

- ALTER TABLEを使用してテーブルスキーマを変更できますが、以下の制限が存在します。
  - 主キーの変更はサポートされていません。
  - `ALTER TABLE ... ORDER BY ...` を使用してソートキーを再割り当てることはサポートされていますが、ソートキーの削除はサポートされていません。ソートキーの列のデータ型の変更もサポートされていません。
  - 列の順序の調整はサポートされていません。

- バージョン2.3.0以降、主キー列以外の列はBITMAPおよびHLLデータ型もサポートされています。

- テーブルを作成する際には、主キーカラムを除く列に対してBITMAPインデックスまたはBloom Filterインデックスを作成することができます。

- バージョン2.4.0以降、主キーテーブルに基づいて非同期マテリアライズドビューを作成することができます。

## 次の手順

テーブルを作成した後、データをロードするためにロードジョブを実行できます。サポートされているロード方法の詳細は、[データロードの概要](../../loading/Loading_intro.md)を参照してください。

主キーテーブルのデータを更新する必要がある場合は、[ロードジョブを実行](../../loading/Load_to_Primary_Key_tables.md)するか、DMLステートメント（[UPDATE](../../sql-reference/sql-statements/data-manipulation/UPDATE.md)または[DELETE](../../sql-reference/sql-statements/data-manipulation/DELETE.md)）を実行できます。また、これらの更新操作は原子性を保証します。