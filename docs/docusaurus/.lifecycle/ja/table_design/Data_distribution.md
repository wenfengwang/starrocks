---
displayed_sidebar: "Japanese"
---

# データ分布

テーブル作成時の適切なパーティション分割とバケティングの設定は、均等なデータ分布を実現するのに役立ちます。均等なデータ分布とは、データを特定のルールに従ってサブセットに分割し、異なるノード間で均等に配布することを意味します。これにより、スキャンされるデータ量を減らし、クラスタの並列処理能力を十分に活用してクエリのパフォーマンスを向上させることができます。

> **注記**
>
> - v3.1から、テーブルの作成やパーティションの追加時にDISTRIBUTED BY句でバケティングキーを指定する必要はありません。StarRocksはランダムバケティングをサポートしており、データをすべてのバケットにランダムに配布します。詳細については、[ランダムバケティング](#random-bucketing-since-v31)を参照してください。
> - v2.5.7から、テーブルの作成やパーティションの追加時にバケットの数を手動で設定しないことも可能です。StarRocksは自動的にバケットの数（BUCKETS）を設定することもできますが、StarRocksがバケットの数を自動的に設定した後でもパフォーマンスが期待通りでない場合や、バケティングメカニズムに精通している場合は、[バケットの数を手動で設定](#determine-the-number-of-buckets)することもできます。

## 分布方法

### 一般的な分布方法

現代の分散データベースシステムでは、通常、次の基本的な分布方法を使用します：ラウンドロビン、範囲、リスト、およびハッシュ。

![データ分布方法](../assets/3.3.2-1.png)

- **ラウンドロビン**: データをサイクリックに異なるノード間で配布します。
- **範囲**: パーティション列の値の範囲に基づいてデータを異なるノード間で配布します。図に示すように、範囲[1-3]と[4-6]は異なるノードに対応します。
- **リスト**: パーティション列の離散値に基づいてデータを異なるノード間で配布します。各離散値はノードにマップされ、複数の異なる値が同じノードにマップされることもあります。
- **ハッシュ**: ハッシュ関数に基づいてデータを異なるノード間で配布します。

特定のビジネス要件に基づいて、上記のデータ分布方法のいずれかを使用するだけでなく、これらの方法を組み合わせることで柔軟なデータ分割を実現できます。一般的な組み合わせには、ハッシュ+ハッシュ、範囲+ハッシュ、およびハッシュ+リストがあります。

### StarRocksにおける分布方法

StarRocksはデータ分布方法の個別の使用と複合の使用の両方をサポートしています。

> **注記**
>
> 一般的な分布方法に加えて、StarRocksはバケティング設定を簡略化するためにランダム分布もサポートしています。

また、StarRocksは2段階のパーティション分割+バケティング方式を実装してデータを分布させます。

- 第1段階はパーティション分割です：テーブル内のデータをパーティション分割できます。サポートされているパーティション分割方法は、式によるパーティション分割、範囲によるパーティション分割、リストによるパーティション分割です。または、パーティションを使用しないでテーブル全体を1つのパーティションとして扱うこともできます。
- 第2段階はバケティングです：パーティション内のデータをさらに小さなバケットに分布する必要があります。サポートされているバケティング方法はハッシュとランダムバケティングです。

| **分布方法**         | **パーティション分割とバケティング方式**                  | **説明**                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ランダム分布          | ランダムバケティング                                             | テーブル全体を1つのパーティションと見なします。テーブル内のデータは異なるバケットにランダムに分布されます。これはデフォルトのデータ分布方法です。 |
| ハッシュ分布          | ハッシュバケティング                                               | テーブル全体を1つのパーティションと見なします。テーブル内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分布されます。 |
| 範囲+ランダム分布       | <ol><li>式によるパーティション分割または範囲によるパーティション分割 </li><li>ランダムバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が範囲に適合する範囲に基づいて対応するパーティションに分布されます。 </li><li>パーティション内のデータは異なるバケットにランダムに分布されます。 </li></ol> |
| 範囲+ハッシュ分布        | <ol><li>式によるパーティション分割または範囲によるパーティション分割</li><li>ハッシュバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が範囲に適合する範囲に基づいて対応するパーティションに分布されます。 </li><li>パーティション内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分布されます。 </li></ol> |
| リスト+ランダム分布      | <ol><li>式によるパーティション分割またはリストによるパーティション分割</li><li>ランダムバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が範囲に適合する範囲に基づいて対応するパーティションに分布されます。 </li><li>パーティション内のデータは異なるバケットにランダムに分布されます。</li></ol> |
| リスト+ハッシュ分布        | <ol><li>式によるパーティション分割またはリストによるパーティション分割</li><li>ハッシュバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が属する値リストに基づいてパーティションが作成されます。</li><li>パーティション内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分布されます。</li></ol> |

- **ランダム分布**

  テーブル作成時にパーティション分割とバケティング方法を設定しない場合、デフォルトでランダム分布が使用されます。この分布方法は現在、重複キーのテーブルの作成にのみ使用できます。

  ```SQL
  CREATE TABLE site_access1 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY (event_day,site_id,pv);
  -- パーティション分割およびバケティング方法が設定されていないため、デフォルトでランダム分布が使用されます。
  ```

- **ハッシュ分布**

  ```SQL
  CREATE TABLE site_access2 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code SMALLINT,
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY (event_day, site_id, city_code, user_name)
  -- バケティング方法とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day,site_id); 
  ```

- **範囲+ランダム分布**（この分布方法は現在、重複キーのテーブルの作成にのみ使用できます。）

  ```SQL
  CREATE TABLE site_access3 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY(event_day,site_id,pv)
  -- パーティション分割方法として式によるパーティション分割を使用し、時間関数式を構成します。
  -- または、範囲によるパーティション分割を使用することもできます。
  PARTITION BY date_trunc('day', event_day);
  -- バケティング方法が設定されていないため、デフォルトでランダムバケティングが使用されます。
  ```

- **範囲+ハッシュ分布**

  ```SQL
  CREATE TABLE site_access4 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY(event_day, site_id, city_code, user_name)
  -- パーティション分割方法として式によるパーティション分割を使用し、時間関数式を構成します。
  -- または、範囲によるパーティション分割を使用することもできます。
  PARTITION BY date_trunc('day', event_day)
  -- バケティング方法とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day, site_id);
  ```

- **リスト+ランダム分布**（この分布方法は現在、重複キーのテーブルの作成にのみ使用できます。）

  ```SQL
  CREATE TABLE t_recharge_detail1 (
      id bigint,
      user_id bigint,
      recharge_money decimal(32,2), 
      city varchar(20) not null,
      dt date not null
  )
  DUPLICATE KEY(id)
  -- パーティション分割方法として式によるパーティション分割を使用し、パーティション列を指定します。
  -- または、リストによるパーティション分割を使用することもできます。
  PARTITION BY (city);
  -- バケティング方法が設定されていないため、デフォルトでランダムバケティングが使用されます。
  ```

- **リスト+ハッシュ分布**

  ```SQL
  CREATE TABLE t_recharge_detail2 (
      id bigint,
      user_id bigint,
      recharge_money decimal(32,2), 
      city varchar(20) not null,
      dt date not null
  )
  DUPLICATE KEY(id)
  -- パーティション分割方法として式によるパーティション分割を使用し、パーティション列を指定します。
  -- または、リストによるパーティション分割を使用することもできます。
  PARTITION BY (city)
  -- バケティング方法とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(city,id); 
  ```

#### パーティション分割
パーティショニング方法は、テーブルを複数のパーティションに分割します。パーティショニングは主に、パーティションキーに基づいてテーブルを異なる管理単位（パーティション）に分割するために使用されます。各パーティションの保存戦略を設定でき、それにはバケット数、ホットデータとコールドデータの保存戦略、保存メディアのタイプ、およびレプリカ数が含まれます。StarRocksはクラスタ内で異なる種類の保存メディアを使用できます。たとえば、最新データをソリッドステートドライブ（SSD）に保存してクエリのパフォーマンスを向上させ、履歴データをSATAハードドライブに保存してストレージコストを削減することができます。

| **パーティショニング方法**                   | **シナリオ**                                                    | **パーティションの作成方法**               |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| 式によるパーティショニング（推奨） | 以前は自動パーティショニングとして知られていました。このパーティショニング方法は、柔軟かつ使いやすい方法です。 連続した日付範囲やenum値に基づいてデータをクエリおよび管理する場合など、ほとんどのシナリオに適しています。 | データロード時に自動的に作成されます |
| 範囲によるパーティショニング                    | 典型的なシナリオは、しばしばクエリされ管理されるシンプルで順序立ったデータを保存することです。例えば、履歴データを月ごとにパーティション分割し、最近のデータを日ごとにパーティション分割するケースなどが挙げられます。 | 手動で、動的に、または一括で作成します |
| リストによるパーティショニング                     | 典型的なシナリオは、enum値に基づいてデータをクエリおよび管理し、パーティションに異なる値を含める必要がある場合です。例えば、国と都市に基づいて頻繁にデータをクエリおよび管理する場合、この方法を使用し、`city`をパーティションキーとして選択できます。したがって、1つのパーティションには同じ国に属する複数の都市のデータを含めることができます。 | 手動で作成します                           |

##### パーティションキーと粒度の選択

- 適切なパーティションキーを選択することで、クエリ時にスキャンされるデータ量を効果的に削減できます。ほとんどのビジネスシステムでは、時間に基づくパーティショニングが一般的に採用され、期限切れデータの削除によって引き起こされる特定の問題を解決し、ホットデータとコールドデータのティア化ストレージの管理を容易にします。この場合、式によるパーティショニングまたは範囲によるパーティショニングを使用し、パーティショニングキーとして時間列を指定できます。また、enum値に基づいてデータが頻繁にクエリおよび管理される場合は、式によるパーティショニングまたはリストによるパーティショニングを使用し、これらの値を含む列をパーティショニングキーとして指定できます。
- パーティションの粒度を選択する際には、データ量、クエリパターン、およびデータ管理の粒度を考慮する必要があります。
  - 例1：テーブルにおける月次データ量が少ない場合、日単位でのパーティショニングよりもメタデータの消費量を減らし、メタデータ管理とスケジューリングのリソース消費を軽減できます。
  - 例2：テーブルにおける月次データ量が多く、クエリが主に特定の日のデータを要求する場合、日単位でのパーティショニングをすることで、クエリ時にスキャンされるデータ量を効果的に削減できます。
  - 例3：データの有効期限が日次で切れる必要がある場合、日単位でのパーティショニングが推奨されます。

#### バケティング

バケティング方法は、1つのパーティションを複数のバケットに分割します。バケット内のデータはタブレットと呼ばれます。

サポートされているバケティング方法には、[ランダムバケティング](#ランダムバケティング-v31から)（v3.1から）および[ハッシュバケティング](#ハッシュバケティング)があります。

- ランダムバケティング：テーブルを作成するかパーティションを追加する際、バケティングキーを設定する必要はありません。パーティション内のデータはランダムに異なるバケットに分散されます。
- ハッシュバケティング：テーブルを作成するかパーティションを追加する際、バケティングキーを指定する必要があります。同じパーティション内のデータは、バケティングキーの値に基づいてバケットに分割され、バケティングキーの同じ値を持つ行は対応する一意なバケットに分散されます。

バケット数：デフォルトでは、StarRocksはバケット数を自動で設定します（v2.5.7から）。また、バケット数を手動で設定することもできます。詳細については、[バケット数の決定](#バケット数の決定)を参照してください。

## パーティションの作成と管理

### パーティションの作成

#### 式によるパーティショニング（推奨）

> **注**
>
> v3.1以降、StarRocksの[共有データモード](../deployment/shared_data/s3.md)では、時間関数式をサポートし、列式をサポートしていません。

v3.0以降、StarRocksは、より柔軟で使いやすい[式によるパーティショニング](./expression_partitioning.md)（以前は自動パーティショニングとして知られていました）をサポートしています。このパーティショニング方法は、連続した日付範囲やenum値に基づいてデータをクエリおよび管理するなど、ほとんどのシナリオに適しています。

テーブル作成時にパーティション式（時間関数式または列式）を構成するだけでよく、StarRocksはデータのロード時に自動的にパーティションを作成します。事前に多数のパーティションを手動で作成する必要はなく、動的パーティションプロパティを構成する必要もありません。

#### 範囲によるパーティショニング

範囲によるパーティショニングは、時間系列データ（日付またはタイムスタンプ）や連続した数値データなど、シンプルで連続したデータを保存するのに適しています。 また、連続した日付/数値範囲に基づいてデータを頻繁にクエリおよび管理する場合にも適用できます。また、履歴データを月単位でパーティション分割し、最近のデータを日単位でパーティション分割するなどの特殊なケースにも適用できます。

StarRocksは、明示的に定義された各パーティションの範囲に基づいて、対応するパーティションにデータを保存します。

##### 動的パーティショニング

[動的パーティショニング](./dynamic_partitioning.md)に関連するプロパティは、テーブル作成時に構成されます。StarRocksは、データの新しいパーティションを事前に自動的に作成し、期限切れのパーティションを削除して、データの新しさを確保します。これにより、パーティションの期限を管理するタイムリーな管理が実現します。

式によるパーティショニングによって提供される自動的なパーティション作成機能とは異なり、動的パーティショニングはプロパティに基づいて定期的に新しいパーティションを作成し、期限切れのパーティションを削除します。これにより、読み込まれたデータに基づいて常に対応する新しいパーティションを作成できますが、新しいデータがこれらのパーティションに属さない場合、ロードジョブはエラーが返されます。

##### 手動でパーティションを作成

適切なパーティションキーを使用することで、クエリ時にスキャンされるデータ量を効果的に削減できます。現在、パーティションキーに選択できるのは、日付または整数型の列のみです。ビジネスシナリオでは、パーティションキーは通常、データ管理の観点から選択されます。一般的なパーティショニング列には、日付または場所を表す列などが含まれます。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

##### 一括で複数のパーティションを作成

テーブル作成およびその後に一括で複数のパーティションを作成できます。一括作成されるすべてのパーティションの開始時刻と終了時刻は、`START()`および`END()`で指定し、`EVERY()`でパーティションの増分値を指定できます。ただし、パーティションの範囲は右半開区間であり、開始時刻は含まれますが、終了時刻は含まれません。パーティションの命名規則は、動的パーティショニングと同じです。

- **テーブル内の日付型の列（DATEおよびDATETIME）をテーブル作成時にパーティショニングする**

  日付型のパーティショニング列を持つ場合、テーブル作成時に、`START()`および`END()`を使用して一括で作成されるすべてのパーティションの開始日と終了日を指定し、`EVERY(INTERVAL xxx)`を使用して2つのパーティション間の増分間隔を指定できます。現在、インターバルの粒度は`HOUR`（v3.0以降）、`DAY`、`WEEK`、`MONTH`、`YEAR`をサポートしています。

  次の例では、一括で作成されるすべてのパーティションの日付範囲は2021-01-01から2021-01-04までで、増分間隔は1日です。

    ```SQL
  CREATE TABLE site_access (
      datekey DATE,
      site_id INT,
      city_code SMALLINT,
      user_name VARCHAR(32),
      pv BIGINT DEFAULT '0'
  )
  ENGINE=olap
  DUPLICATE KEY(datekey, site_id, city_code, user_name)
  PARTITION BY RANGE (datekey) (
      START ("2021-01-01") END ("2021-01-04") EVERY (INTERVAL 1 DAY)
  )
  DISTRIBUTED BY HASH(site_id)
  PROPERTIES ("replication_num" = "3" );
    ```

  これは、次の`CREATE TABLE`文内の`PARTITION BY`句を使用した場合と同等です。

    ```SQL
  PARTITION BY RANGE (datekey) (
  PARTITION p20210101 VALUES [('2021-01-01'), ('2021-01-02')),
  PARTITION p20210102 VALUES [('2021-01-02'), ('2021-01-03')),
  PARTITION p20210103 VALUES [('2021-01-03'), ('2021-01-04'))
  )
    ```
異なるインクリメンタル間隔を指定して、異なるバッチのパーティションに`EVERY`で指定することで、日付パーティションのバッチを作成できます（異なるバッチ間のパーティション範囲が重複しないようにしてください）。各バッチのパーティションは、`START(xxx) END(xxx) EVERY(xxx)`句に従って作成されます。例：

```SQL
CREATE TABLE site_access(
    datekey DATE,
    site_id INT,
    city_code SMALLINT,
    user_name VARCHAR(32),
    pv BIGINT DEFAULT '0'
)
ENGINE=olap
DUPLICATE KEY(datekey, site_id, city_code, user_name)
PARTITION BY RANGE (datekey) 
(
    START ("2019-01-01") END ("2021-01-01") EVERY (INTERVAL 1 YEAR),
    START ("2021-01-01") END ("2021-05-01") EVERY (INTERVAL 1 MONTH),
    START ("2021-05-01") END ("2021-05-04") EVERY (INTERVAL 1 DAY)
)
DISTRIBUTED BY HASH(site_id)
PROPERTIES(
    "replication_num" = "3"
);
```

この場合、CREATE TABLE文の`PARTITION BY`句を使用した以下のようなものに相当します：

```SQL
PARTITION BY RANGE (datekey) (
  PARTITION p2019 VALUES [('2019-01-01'), ('2020-01-01')),
  PARTITION p2020 VALUES [('2020-01-01'), ('2021-01-01')),
  PARTITION p202101 VALUES [('2021-01-01'), ('2021-02-01')),
  PARTITION p202102 VALUES [('2021-02-01'), ('2021-03-01')),
  PARTITION p202103 VALUES [('2021-03-01'), ('2021-04-01')),
  PARTITION p202104 VALUES [('2021-04-01'), ('2021-05-01')),
  PARTITION p20210501 VALUES [('2021-05-01'), ('2021-05-02')),
  PARTITION p20210502 VALUES [('2021-05-02'), ('2021-05-03')),
  PARTITION p20210503 VALUES [('2021-05-03'), ('2021-05-04'))
)
```

- **テーブルの整数型列にパーティションを付与**

  パーティション列のデータ型がINTの場合、`START`と`END`でパーティションの範囲を指定し、`EVERY`で増分値を定義します。例：

  > **注記**
  >
  > **START()**および**END()**のパーティション列の値は、二重引用符で囲む必要がありますが、**EVERY()**の増分値は二重引用符で囲む必要はありません。

  次の例では、すべてのパーティションの範囲が`1`から`5`であり、パーティションの増分値は`1`です：

  ```SQL
  CREATE TABLE site_access (
      datekey INT,
      site_id INT,
      city_code SMALLINT,
      user_name VARCHAR(32),
      pv BIGINT DEFAULT '0'
  )
  ENGINE=olap
  DUPLICATE KEY(datekey, site_id, city_code, user_name)
  PARTITION BY RANGE (datekey) (START ("1") END ("5") EVERY (1)
  )
  DISTRIBUTED BY HASH(site_id)
  PROPERTIES ("replication_num" = "3");
  ```

  CREATE TABLE文の`PARTITION BY`句を使用した以下のようなものに相当します：

  ```SQL
  PARTITION BY RANGE (datekey) (
  PARTITION p2019 VALUES [('2019-01-01'), ('2020-01-01')),
  PARTITION p2020 VALUES [('2020-01-01'), ('2021-01-01')),
  PARTITION p202101 VALUES [('2021-01-01'), ('2021-02-01')),
  PARTITION p202102 VALUES [('2021-02-01'), ('2021-03-01')),
  PARTITION p202103 VALUES [('2021-03-01'), ('2021-04-01')),
  PARTITION p202104 VALUES [('2021-04-01'), ('2021-05-01')),
  PARTITION p20210501 VALUES [('2021-05-01'), ('2021-05-02')),
  PARTITION p20210502 VALUES [('2021-05-02'), ('2021-05-03')),
  PARTITION p20210503 VALUES [('2021-05-03'), ('2021-05-04'))
  )
  ```

##### テーブル作成後に複数のパーティションをバッチで作成

  テーブルを作成した後、ALTER TABLE文を使用してパーティションを追加することができます。構文は、テーブル作成時のバッチで複数のパーティションを作成するのと似ています。`ADD PARTITIONS`句で`START`、`END`、`EVERY`を構成する必要があります。

  ```SQL
  ALTER TABLE site_access 
  ADD PARTITIONS START ("2021-01-04") END ("2021-01-06") EVERY (INTERVAL 1 DAY);
  ```

#### リストパーティショニング（v3.1から）

[リストパーティショニング](./list_partitioning.md)は、enum値に基づいてデータを効率的に管理し、クエリを高速化するのに適しています。パーティションの列に異なる値のデータを含める必要があるシナリオに特に有用です。たとえば、国と都市を基準にデータを頻繁にクエリおよび管理する場合は、このパーティショニング方法を使用して、`city`列をパーティショニング列として選択できます。この場合、1つのパーティションに1つの国に属するさまざまな都市のデータを含めることができます。

StarRocksは、各パーティションに対する事前に定義された値リストの明示的なマッピングに基づいてデータを対応するパーティションに格納します。

### パーティションの管理

#### パーティションの追加

範囲パーティショニングおよびリストパーティショニングでは、新しいデータを格納するために新しいパーティションを手動で追加することができます。ただし、式パーティショニングの場合、データのロード中にパーティションが自動的に作成されるため、手動で追加する必要はありません。

次の文は、テーブル`site_access`に新しい月のデータを格納するために新しいパーティションを追加します：

```SQL
ALTER TABLE site_access
ADD PARTITION p4 VALUES LESS THAN ("2020-04-30")
DISTRIBUTED BY HASH(site_id);
```

#### パーティションの削除

次の文は、テーブル`site_access`からパーティション`p1`を削除します。

> **注記**
>
> この操作は、パーティション内のデータを即座に削除するものではありません。データはデフォルトで一定の期間（通常は1日）Trashに保持されます。パーティションが誤って削除された場合は、[RECOVER](../sql-reference/sql-statements/data-definition/RECOVER.md)コマンドを使用してパーティションとそのデータを復元できます。

```SQL
ALTER TABLE site_access
DROP PARTITION p1;
```

#### パーティションのリストア

次の文は、パーティション`p1`とそのデータをテーブル`site_access`にリストアします。

```SQL
RECOVER PARTITION p1 FROM site_access;
```

#### パーティションの表示

次の文は、テーブル`site_access`のすべてのパーティションの詳細を返します。

```SQL
SHOW PARTITIONS FROM site_access;
```

## バケット設定

### ランダムバケット（v3.1から）

StarRocksは、パーティション内のデータをランダムにすべてのバケツに分散します。データサイズが小さく、クエリのパフォーマンス要件が比較的低いシナリオに適しています。バケティング方法を設定しない場合は、StarRocksはデフォルトでランダムバケティングを使用し、バケツの数を自動的に設定します。

ただし、大量のデータをクエリし、特定の列をクエリ条件として頻繁に使用する場合、ランダムバケティングによるクエリパフォーマンスは最適とは言えません。そのようなシナリオでは、[ハッシュバケティング](#hash-bucketing)を使用することをお勧めします。これらの列がクエリのフィルタ条件として使用される場合、クエリにヒットするバケツ数の少ないデータのみがスキャンおよび計算されるため、クエリのパフォーマンスが大幅に向上します。

#### 制限

- ランダムバケティングは、Duplicate Keyテーブルを作成する際にのみ使用できます。
- ランダムバケティングのテーブルを[共有ジョイン](../using_starrocks/Colocate_join.md)に所属させることはできません。
- [Spark Load](../loading/SparkLoad.md)を使用してランダムバケティングのテーブルにデータをロードすることはできません。

以下のCREATE TABLEの例では、`DISTRIBUTED BY xxx`文が使用されていないため、StarRocksはデフォルトでランダムバケティングを使用し、バケツの数を自動的に設定します。

```SQL
CREATE TABLE site_access1(
    event_day DATE,
    site_id INT DEFAULT '10', 
    pv BIGINT DEFAULT '0' ,
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT ''
)
DUPLICATE KEY(event_day,site_id,pv);
```

ただし、バケティングメカニズムに精通している場合は、ランダムバケティングを使用してテーブルを作成する際に、バケツの数を手動で設定することもできます。

```SQL
CREATE TABLE site_access2(
    event_day DATE,
    site_id INT DEFAULT '10', 
    pv BIGINT DEFAULT '0' ,
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT ''
)
DUPLICATE KEY(event_day,site_id,pv)
DISTRIBUTED BY RANDOM BUCKETS 8; -- バケツの数を8に手動設定
```

### ハッシュバケティング
StarRocksは、バケット分けキーと[バケットの数](#バケットの数を決定する)に基づいて、パーティション内のデータをバケットに細分化するためにハッシュ・バケットを使用できます。ハッシュ・バケットで、ハッシュ関数がデータのバケット分けキーの値を入力として受け取り、ハッシュ値を計算します。ハッシュ値とバケットの間のマッピングに基づいてデータは対応するバケットに格納されます。

#### 利点

- クエリパフォーマンスの向上: 同じバケット分けキー値を持つ行は同じバケットに格納されるため、クエリ中にスキャンされるデータ量が減少します。

- データの均等な分布: カーディナリティ（一意の値のより大きな数）が高い列をバケット分けキーとして選択することで、データをバケット間でより均等に分散させることができます。

#### バケット分け列の選択方法

以下の2つの要件を満たす列をバケット分け列として選択することをお勧めします。

- IDなどのカーディナリティが高い列
- クエリでよく使用されるフィルターとして使用される列

ただし、どの列もこの2つの要件を満たさない場合は、クエリの複雑さに応じてバケット分け列を決定する必要があります。

- クエリが複雑な場合は、データを可能な限り均等にバケットに分散させ、クラスタリソースの利用効率を向上させるために、カーディナリティが高い列をバケット分け列として選択することをお勧めします。
- クエリが比較的単純な場合は、クエリの効率を向上させるために、クエリで頻繁に使用される条件でフィルターとして使用される列をバケット分け列として選択することをお勧めします。

1つのバケット分け列を使用してもパーティションデータがすべてのバケットに均等に分散されない場合は、複数のバケット分け列を選択できます。ただし、3つを超える列の使用は推奨されません。

#### 注意事項

- **テーブルを作成する際には、必ずバケット分け列を指定する必要があります**。
- バケット分け列のデータ型は、INTEGER、DECIMAL、DATE/DATETIME、CHAR/VARCHAR/STRINGである必要があります。
- バケット分け列は、指定された後に変更することはできません。

#### 例

以下の例では、`site_id`をバケット分け列として使用して`site_access`テーブルが作成されます。また、`site_access`テーブルのデータがクエリされる際は、データが頻繁にサイトでフィルタリングされます。このため、`site_id`をバケット分けキーとして使用することで、クエリ中に大幅なデータが収縮されます。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)
(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

仮に`site_access`テーブルの各パーティションに10個のバケットがあるとします。次のクエリでは10個のバケットのうち9個が刈り取られるため、StarRocksは`site_access`テーブル内のデータの1/10のスキャンのみを必要とします。

```SQL
select sum(pv)
from site_access
where site_id = 54321;
```

しかし、`site_id`が不均等に分布しており、多くのクエリがわずかなサイトのデータをリクエストする場合、1つのバケット分け列のみを使用すると深刻なデータの偏りが発生し、システムのパフォーマンスボトルネックを引き起こす可能性があります。この場合、複数のバケット分け列の組み合わせを使用できます。たとえば、次のステートメントでは、`site_id`と`city_code`をバケット分け列として使用しています。

```SQL
CREATE TABLE site_access
(
    site_id INT DEFAULT '10',
    city_code SMALLINT,
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(site_id, city_code, user_name)
DISTRIBUTED BY HASH(site_id,city_code);
```

実際には、ビジネス特性に基づいて1つまたは2つのバケット分け列を使用することができます。1つのバケット分け列`site_id`を使用することは、短いクエリに対して非常に有益であり、ノード間のデータ交換を減らすため、クラスタ全体のパフォーマンスを向上させることができます。一方で、2つのバケット分け列`site_id`と`city_code`を採用することは、長いクエリに対して非常に有益であり、分散クラスタ全体の全体的な並列処理を活用することで、パフォーマンスを大幅に向上させることができます。

> **注意**
>
> - 短いクエリは少量のデータをスキャンし、単一ノードで完了することができます。
> - 長いクエリは大量のデータをスキャンし、分散クラスタの複数ノードで並列スキャンすることで、パフォーマンスを大幅に向上させることができます。

### バケットの数を決定する

バケットは、データファイルが実際にStarRocksでどのように構成されているかを反映しています。

- テーブル作成時のバケットの数の設定方法

  - 方法1: バケットの数を自動で設定（推奨）

    - ハッシュ・バケット設定されたテーブル

      v2.5.7以降、StarRocksではテーブル作成時に、マシンリソースとデータ容量に基づいてパーティションのバケットの数を自動で設定することができます。
      > **注意**
      >
      > パーティションの生データサイズが100 GBを超える場合は、Method 2を使用してバケットの数を手動で構成することをお勧めします。

      例:

      ```sql
      CREATE TABLE site_access (
          site_id INT DEFAULT '10',
          city_code SMALLINT,
          user_name VARCHAR(32) DEFAULT '',
          pv BIGINT SUM DEFAULT '0')
      AGGREGATE KEY(site_id, city_code, user_name)
      DISTRIBUTED BY HASH(site_id,city_code); -- バケットの数を設定する必要はありません
      ```

    - ランダム・バケット設定されたテーブル

      v2.5.7以降、StarRocksではテーブル作成時に、マシンリソースとデータ容量に基づいてパーティションのバケットの数を自動で設定することができます。v3.2.0以降、StarRocksは、テーブル作成時にパーティションのバケットの数を設定するだけでなく、データの読み込み中にクラスタ容量と読み込まれたデータの量に基づいてパーティションのバケットの数を**動的に増やします**。これにより、パーティションの作成が容易になるだけでなく、大容量のデータを効率的にロードすることができます。
      > **注意**
      >
      > バケットのサイズはデフォルトで`1024 * 1024 * 1024 B`（4 GB）です。テーブル作成時に`PROPERTIES ("bucket_size"="xxx")`でバケットのサイズを指定できます。

      例:

      ```SQL
      CREATE TABLE site_access1 (
          event_day DATE,
          site_id INT DEFAULT '10', 
          pv BIGINT DEFAULT '0' ,
          city_code VARCHAR(100),
          user_name VARCHAR(32) DEFAULT ''
      )
      DUPLICATE KEY (event_day,site_id,pv)
      ; -- このテーブルのパーティションのバケットの数はStarRocksによって自動で設定されます。バケットのキーを設定する必要はありません。
      
      CREATE TABLE site_access1 (
          event_day DATE,
          site_id INT DEFAULT '10', 
          pv BIGINT DEFAULT '0' ,
          city_code VARCHAR(100),
          user_name VARCHAR(32) DEFAULT '')
      DUPLICATE KEY (event_day,site_id,pv) 
      PROPERTIES("bucket_size"="1073741824") -- バケットのサイズは1 GBに設定されています。
      ; -- このテーブルのパーティションのバケットの数はStarRocksによって自動で設定されます。バケットのキーを設定する必要はありません。
      ```

    テーブルを作成した後は、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md)を実行して、StarRocksが各パーティションに設定したバケットの数を確認できます。ハッシュ・バケット設定されたテーブルの場合、各パーティションのバケットの数は**固定**されています。

    ランダム・バケット設定されたテーブルの場合、各パーティションのバケットの数は**動的に変更**されることがあります。そのため、返される結果には各パーティションの**現在**のバケットの数が表示されます。
    > **注意**
    >
    > このテーブルタイプの場合、パーティション内の実際の階層は次のとおりです: パーティション > サブパーティション > バケット。バケットの数を増やすためには、StarRocksは実際に一定数のバケットを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS`ステートメントは同じパーティション名の複数のデータ行を返す場合がありますが、それらは同じパーティション内のサブパーティションの情報を示しています。

  - 方法2: バケットの数を手動で設定

    v2.4.0以降、StarRocksはクエリ中に複数のスレッドを使用してタブレットを並列スキャンすることで、スキャンパフォーマンスの依存性を低減します。各タブレットに約10 GBの生データが含まれることが推奨されます。バケットの数を手動で設定する場合は、テーブルの各パーティションに含まれるデータ量を見積もり、その後タブレットの数を決定できます。

    タブレットで並列スキャンを有効にするには、全体のシステムで`enable_tablet_internal_parallel`パラメータが`TRUE`に設定されていることを確認してください（`SET GLOBAL enable_tablet_internal_parallel = true;`）。

    ```SQL
    CREATE TABLE site_access (
        site_id INT DEFAULT '10',
        city_code SMALLINT,
        user_name VARCHAR(32) DEFAULT '',
        pv BIGINT SUM DEFAULT '0')
    AGGREGATE KEY(site_id, city_code, user_name)
    -- パーティションにロードする生データの容量が300 GBであるとします。
    -- 各タブレットに10 GBの生データを含めることを推奨しているため、バケツの数は30に設定できます。
    DISTRIBUTED BY HASH(site_id,city_code) BUCKETS 30;
    ```

- 新しいパーティションを追加する際のバケツの数の設定方法

  - 方法1: バケツの数を自動設定する（推奨）
    - ハッシュバケットを用いたテーブルの構成

      v2.5.7以降、StarRocksは、パーティションの作成時に機械リソースとデータ容量に基づいてバケツの数を自動設定できます。
      > **注意**
      >
      > パーティションの生データサイズが100 GBを超える場合、方法2を使用してバケツの数を手動で構成することを推奨します。

    - ランダムバケットを用いたテーブルの構成

      v2.5.7以降、StarRocksは、パーティションの作成時に機械リソースとデータ容量に基づいてバケツの数を自動設定できます。v3.2.0以降、StarRocksは、バケツの数の自動設定のロジックをさらに最適化しました。パーティションの作成時だけでなく、StarRocksはデータのロード中にクラスタの容量とロードされたデータの容量に基づいて、パーティション内のバケツの数を**動的に増や**します。これにより、テーブルの作成が容易になるだけでなく、バルクロードのパフォーマンスも向上します。
      > **注意**
      >
      > バケットのサイズはデフォルトで`1024 * 1024 * 1024 B`（4 GB）です。パーティションを追加する際にバケットのサイズを`PROPERTIES ("bucket_size"="xxx")`で指定することができます。

    パーティションを追加した後、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md)を実行して、StarRocksが新しいパーティションに設定したバケツの数を表示できます。ハッシュバケットを用いたテーブルの場合、新しいパーティションのバケツの数は**固定**されています。
    ランダムバケットを用いたテーブルの場合、新しいパーティションのバケツの数は**動的に変更**される可能性があります。そのため、返される結果には新しいパーティションの**現在の**バケツの数が表示されます。
      > **注意**
      >
      > このテーブルタイプでは、実際の階層は次のようになります: パーティション > サブパーティション > バケツ。バケツの数を増やすためには、StarRocksは実際には一定数のバケツを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS` ステートメントでは、同じパーティション名の複数のデータ行が返され、同じパーティション内のサブパーティションの情報が表示されます。

  - 方法2: バケツの数を手動で設定する

    新しいパーティションを追加する際にバケツの数を手動で指定することもできます。新しいパーティションのバケツの数を計算するには、前述のテーブル作成時にバケツの数を手動で設定する方法を参照できます。
    
    ```SQL
    -- パーティションを手動で作成
    ALTER TABLE <テーブル名> 
    ADD PARTITION <パーティション名>
        [DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]];
        
    -- 動的パーティショニング
    ALTER TABLE <テーブル名> 
    SET ("dynamic_partition.buckets"="xxx");
    ```