---
displayed_sidebar: "Japanese"
---

# データ分散

テーブルの作成時に適切なパーティショニングとバケティングを設定することで、均等なデータ分散を実現することができます。均等なデータ分散とは、データを特定のルールに従ってサブセットに分割し、異なるノードに均等に分散することを意味します。これにより、スキャンされるデータ量を減らし、クラスターの並列処理能力を十分に活用してクエリのパフォーマンスを向上させることも可能です。

> **注意**
>
> - v3.1以降、テーブルの作成やパーティションの追加時には、DISTRIBUTED BY句でバケティングキーを指定する必要がありません。StarRocksはランダムバケティングをサポートしており、データをランダムにバケットに分散させることができます。詳細については、[ランダムバケティング](#random-bucketing-since-v31)を参照してください。
> - v2.5.7以降、テーブルの作成やパーティションの追加時に、バケットの数を手動で設定しない選択肢があります。StarRocksは自動的にバケットの数（BUCKETS）を設定することもできます。しかし、StarRocksが自動的にバケットの数を設定した後でも期待するパフォーマンスが得られない場合や、バケティングメカニズムに詳しい場合は、引き続き[バケットの数を手動で設定](#determine-the-number-of-buckets)することができます。

## データ分散の方法

### 一般的な分散方法

現代の分散データベースシステムでは、一般的に以下の基本的な分散方法が使用されます：ラウンドロビン、範囲、リスト、およびハッシュ。

![データ分散方法](../assets/3.3.2-1.png)

- **ラウンドロビン**: データをサイクリックに異なるノードに分散します。
- **範囲**: パーティショニング列の値の範囲に基づいてデータを異なるノードに分散します。図に示すように、範囲[1-3]と[4-6]は異なるノードに対応します。
- **リスト**: パーティショニング列の離散値に基づいてデータを異なるノードに分散します（例：genderやprovince）。各離散値はノードにマッピングされ、複数の異なる値が同じノードにマッピングされることがあります。
- **ハッシュ**: ハッシュ関数に基づいてデータを異なるノードに分散します。

より柔軟なデータパーティショニングを実現するために、上記のデータ分散方法のいずれかを使用するだけでなく、特定のビジネス要件に基づいてこれらの方法を組み合わせることもできます。一般的な組み合わせには、ハッシュ+ハッシュ、範囲+ハッシュ、およびハッシュ+リストがあります。

### StarRocksの分散方法

StarRocksは、データ分散方法を個別または複合して使用することができます。

> **注意**
>
> 一般的な分散方法に加えて、StarRocksは簡易なバケティング設定のためにランダム分散もサポートしています。

また、StarRocksは、2段階のパーティショニング+バケティング方式を実装してデータを分散させます。

- 第一レベルはパーティショニングです。テーブル内のデータはパーティショニングされることがあります。サポートされているパーティショニング方法には、式のパーティショニング、範囲のパーティショニング、およびリストのパーティショニングがあります。または、パーティショニングを使用しない選択肢もあります（テーブル全体を1つのパーティションと見なします）。
- 第二レベルはバケティングです。パーティション内のデータはさらに小さなバケットに分散する必要があります。サポートされているバケティング方法には、ハッシュとランダムバケティングがあります。

| **分散方法**           | **パーティショニングとバケティング方式**                   | **説明**                                                  |
| --------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| ランダム分散           | ランダムバケティング                                       | テーブル全体が1つのパーティションと見なされます。テーブル内のデータはランダムに異なるバケットに分散されます。これがデフォルトのデータ分散方法です。 |
| ハッシュ分散           | ハッシュバケティング                                       | テーブル全体が1つのパーティションと見なされます。テーブル内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分散されます。 |
| 範囲+ランダム分散       | <ol><li>式のパーティショニングまたは範囲のパーティショニング </li><li>ランダムバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティショニング列の値がどの範囲にあるかに基づいて対応するパーティションに分散されます。</li><li>パーティション内のデータはランダムに異なるバケットに分散されます。</li></ol> |
| 範囲+ハッシュ分散       | <ol><li>式のパーティショニングまたは範囲のパーティショニング </li><li>ハッシュバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティショニング列の値がどの範囲にあるかに基づいて対応するパーティションに分散されます。</li><li>パーティション内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分散されます。</li></ol> |
| リスト+ランダム分散     | <ol><li>式のパーティショニングまたはリストのパーティショニング</li><li>ランダムバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティショニング列の値がどの範囲にあるかに基づいて対応するパーティションに分散されます。</li><li>パーティショニング内のデータはランダムに異なるバケットに分散されます。</li></ol> |
| リスト+ハッシュ分散     | <ol><li>式のパーティショニングまたはリストのパーティショニング</li><li>ハッシュバケティング </li></ol> | <ol><li>テーブル内のデータは、パーティショニング列の値が属する値リストに基づいてパーティショニングされます。</li><li>パーティショニング内のデータは、ハッシュ関数を使用してデータのバケティングキーのハッシュ値に基づいて対応するバケットに分散されます。</li></ol> |

- **ランダム分散**

  テーブルの作成時にパーティショニングとバケティング方式を設定しない場合、デフォルトでランダム分散が使用されます。この分散方法は現在、重複キーテーブルの作成にのみ使用できます。

  ```SQL
  CREATE TABLE site_access1 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY (event_day,site_id,pv);
  -- パーティショニングとバケティング方式が設定されていないため、デフォルトでランダム分散が使用されます。
  ```

- **ハッシュ分散**

  ```SQL
  CREATE TABLE site_access2 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code SMALLINT,
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY (event_day, site_id, city_code, user_name)
  -- バケティング方式とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day,site_id); 
  ```

- **範囲+ランダム分散**（この分散方法は現在、重複キーテーブルの作成にのみ使用できます。）

  ```SQL
  CREATE TABLE site_access3 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY(event_day,site_id,pv)
  -- パーティショニング方式として式のパーティショニングを使用し、時間関数式を構成します。
  -- 範囲のパーティショニングも使用できます。
  PARTITION BY date_trunc('day', event_day);
  -- バケティング方式が設定されていないため、デフォルトでランダムバケティングが使用されます。
  ```

- **範囲+ハッシュ分散**

  ```SQL
  CREATE TABLE site_access4 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY(event_day, site_id, city_code, user_name)
  -- パーティショニング方式として式のパーティショニングを使用し、時間関数式を構成します。
  -- 範囲のパーティショニングも使用できます。
  PARTITION BY date_trunc('day', event_day)
  -- バケティング方式とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day, site_id);
  ```

- **リスト+ランダム分散**（この分散方法は現在、重複キーテーブルの作成にのみ使用できます。）

  ```SQL
  CREATE TABLE t_recharge_detail1 (
      id bigint,
      user_id bigint,
      recharge_money decimal(32,2), 
      city varchar(20) not null,
      dt date not null
  )
  DUPLICATE KEY(id)
  -- パーティショニング方式として式のパーティショニングを使用し、パーティショニング列を指定します。
  -- リストのパーティショニングも使用できます。
  PARTITION BY (city);
  -- バケティング方式が設定されていないため、デフォルトでランダムバケティングが使用されます。
  ```

- **リスト+ハッシュ分散**

  ```SQL
  CREATE TABLE t_recharge_detail2 (
      id bigint,
      user_id bigint,
      recharge_money decimal(32,2), 
      city varchar(20) not null,
      dt date not null
  )
  DUPLICATE KEY(id)
  -- パーティショニング方式として式のパーティショニングを使用し、パーティショニング列を指定します。
  -- リストのパーティショニングも使用できます。
  PARTITION BY (city)
  -- バケティング方式とバケティングキーを指定する必要があります。
  DISTRIBUTED BY HASH(city,id); 
  ```

#### パーティショニング
パーティションメソッドは、テーブルを複数のパーティションに分割します。パーティションは主に、パーティションキーに基づいてテーブルを異なる管理単位（パーティション）に分割するために使用されます。各パーティションには、バケットの数、ホットデータやコールドデータの格納方法、ストレージメディアのタイプ、およびレプリカの数など、それぞれのストレージ戦略を設定できます。StarRocksでは、クラスタ内で異なるタイプのストレージメディアを使用することができます。たとえば、最新データをソリッドステートドライブ（SSD）に格納してクエリのパフォーマンスを向上させ、履歴データをSATAハードドライブに格納してストレージコストを削減することができます。

| **パーティションメソッド**                   | **シナリオ**                                                    | **パーティションの作成方法**               |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| 式パーティション（推奨） | 以前は自動パーティションとして知られていました。このパーティションメソッドは、柔軟で使いやすく、ほとんどのシナリオに適しています。連続した日付範囲や列挙値に基づいてデータを問い合わせたり管理したりするために適しています。データロード時に自動的に作成されます | データの読み込み時に自動的に作成 |
| 範囲パーティション                    | 典型的なシナリオは、順序が付けられた単純なデータを格納し、しばしば連続した日付/数値範囲に基づいて問い合わせたり管理したりすることです。特定の場合では、過去のデータを月ごとにパーティション分けする必要がある場合や、最近のデータを日ごとにパーティション分けする必要がある場合があります。 | 手動で、動的に、またはバッチで作成 |
| リストパーティション                     | 典型的なシナリオは列挙値に基づいてデータを問い合わせたり管理したりすることで、各パーティションには異なる値をもつデータが含まれる必要があります。たとえば、国と都市に基づいて頻繁にデータを問い合わせたり管理したりする場合、このメソッドを使用して`city`をパーティション化の列として選択できます。したがって、1つのパーティションには同じ国に属する複数の都市のデータを保存できます | 手動で作成                           |

#### パーティション列と粒度の選択方法

- 適切なパーティション列を選択することで、クエリ時のスキャンデータ量を効果的に減らすことができます。ほとんどのビジネスシステムでは、期限切れデータの削除によって引き起こされる特定の問題を解決したり、ホットデータとコールドデータのティアドストレージの管理を容易にしたりするために、時間に基づいてのパーティション化が一般的に採用されています。このような場合、式パーティションまたは範囲パーティションを使用し、時間列をパーティション列として指定できます。さらに、データが列挙値に基づいて頻繁に問い合わせまたは管理される場合、式パーティションまたはリストパーティションを使用して、これらの値を含む列をパーティション列として指定できます。
- パーティションの粒度を選択する際には、データのボリューム、クエリパターン、データ管理の粒度などの要因を考慮する必要があります。
  - 例1：テーブル内の月次データボリュームが小さい場合、日次でのパーティション化はメタデータの量を減らすために有効であり、メタデータの管理とスケジューリングのリソース消費を減らします。
  - 例2：テーブル内の月次データボリュームが大きく、クエリは主に特定日のデータを要求する場合、日次でのパーティション化はクエリ時のスキャンデータ量を効果的に減らします。
  - 例3：データが毎日期限切れになる必要がある場合、日次でのパーティション化が推奨されます。

#### バケティング

バケティングメソッドは、パーティションを複数のバケットに分割します。バケット内のデータはタブレットと呼ばれます。

サポートされているバケティングメソッドは、[ランダムバケティング](#random-bucketing-since-v31)（v3.1から）および[ハッシュバケティング](#hash-bucketing)です。

- ランダムバケティング：テーブルを作成するかパーティションを追加する際、バケティングキーを設定する必要がありません。パーティション内のデータはランダムに異なるバケットに分散されます。
- ハッシュバケティング：テーブルを作成するかパーティションを追加する際、バケティングキーを指定する必要があります。同じパーティション内のデータは、バケティングキーの値に基づいて異なるバケットに分割され、バケティングキーの値が同じ行はそれぞれの固有のバケットに分散されます。

バケットの数: デフォルトでは、StarRocksはバケットの数を自動的に設定します（v2.5.7から）。また、バケットの数を手動で設定することもできます。詳細については、「[バケットの数を決定する](#determine-the-number-of-buckets)」を参照してください。

## パーティションの作成と管理

### パーティションの作成

#### 式パーティション（推奨）

> **NOTICE**
>
> v3.1以降、StarRocksの[共有データモード](../deployment/shared_data/s3.md)は時間関数式をサポートし、列式はサポートされていません。

v3.0以降、StarRocksは[式パーティション](./expression_partitioning.md)（以前は自動パーティションとして知られていました）をサポートしており、これは柔軟で使いやすいパーティションメソッドです。このパーティションメソッドは、連続した日付範囲や列挙値に基づいてデータを問い合わせたり管理したりするために適しています。

テーブル作成時にパーティション式（時間関数式または列式）を構成するだけで、StarRocksはデータのロード中に自動的にパーティションを作成します。したがって、事前に多数のパーティションを手動で作成する必要はなく、動的パーティションプロパティを構成する必要もありません。

#### 範囲パーティション

範囲パーティションは、時間系列データ（日付またはタイムスタンプ）、または連続した数値データなど、単純で連続したデータを保存するために適しています。そして、連続した日付/数値範囲に基づいて頻繁にデータを問い合わせたり管理したりすることがあります。また、過去のデータを月ごとにパーティション分けする必要がある場合や、最近のデータを日ごとにパーティション分けする必要がある特別なケースにも適用できます。

StarRocksは、明示的に定義された各パーティションのための明示的なマッピングに基づいて、対応するパーティションにデータを保存します。

##### 動的パーティション化

[動的パーティション化](./dynamic_partitioning.md) 関連のプロパティはテーブル作成時に構成されます。StarRocksは、データの新規パーティションを事前に自動的に作成し、期限切れのパーティションを削除してデータの新鮮さを確保します。つまり、パーティションの寿命管理（TTL）を実現します。

式パーティションによって提供される自動的パーティション作成能力とは異なり、動的パーティション化は定期的に新しいパーティションを作成し、プロパティに基づいて期限切れのパーティションを削除します。新しいデータがこれらのパーティションに属さない場合、ロードジョブに対してエラーが返されます。一方、式パーティションによって提供される自動的パーティション作成能力は、ロードされたデータに基づいて常に対応する新しいパーティションを作成できます。

##### 手動でパーティションを作成

適切なパーティションキーを使用することで、クエリ時のスキャンデータ量を効果的に減らすことができます。現在、パーティション化の列として選択できるのは、日付または整数型の列のみです。ビジネスシナリオでは、パーティションキーは通常、データ管理の観点から選択されます。一般的なパーティション列には、日付または場所を表す列などがあります。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

##### バッチで複数のパーティションを作成する

テーブル作成後やテーブル作成時にバッチで複数のパーティションを作成できます。バッチで作成されるすべてのパーティションの開始時刻と終了時刻を`START()`と`END()`で指定し、パーティション増分値を`EVERY()`で指定できます。ただし、パーティションの範囲は右半開区間であり、開始時刻を含みますが、終了時刻を含ませません。パーティションの命名規則は、動的パーティション化と同じです。

- **テーブルの作成時に日付型の列（DATEおよびDATETIME）に基づいてテーブルをパーティション化する**

  パーティション化の列が日付型の場合、テーブルの作成時に`START()`と`END()`を使用してバッチで作成されるすべてのパーティションの開始日と終了日を指定し、`EVERY(INTERVAL xxx)`を使用して2つのパーティション間の増分間隔を指定できます。現在、インターバルの粒度は`HOUR`（v3.0から）、`DAY`、`WEEK`、`MONTH`、`YEAR`がサポートされています。

  次の例では、バッチで作成されるすべてのパーティションの日付範囲が2021-01-01から2021-01-04までであり、増分間隔が1日であることを示しています:

    ```SQL
  CREATE TABLE site_access (
      datekey DATE,
      site_id INT,
      city_code SMALLINT,
      user_name VARCHAR(32),
      pv BIGINT DEFAULT '0'
  )
  ENGINE=olap
  DUPLICATE KEY(datekey, site_id, city_code, user_name)
  PARTITION BY RANGE (datekey) (
      START ("2021-01-01") END ("2021-01-04") EVERY (INTERVAL 1 DAY)
  )
  DISTRIBUTED BY HASH(site_id)
  PROPERTIES ("replication_num" = "3" );
    ```

  これは、次の`CREATE TABLE`ステートメントの`PARTITION BY`句を使用するのと等価です。

    ```SQL
  PARTITION BY RANGE (datekey) (
  PARTITION p20210101 VALUES [('2021-01-01'), ('2021-01-02')),
  PARTITION p20210102 VALUES [('2021-01-02'), ('2021-01-03')),
  PARTITION p20210103 VALUES [('2021-01-03'), ('2021-01-04'))
  )
    ```
```SQL
さまざまな増分間隔を指定して、各パーティションの`EVERY`で異なる増分間隔を指定することで、日付のパーティションのバッチを作成できます（異なるバッチ間のパーティション範囲が重複しないようにします）。 各バッチのパーティションは、`START(xxx) END(xxx) EVERY(xxx)`句に従って作成されます。 例：

    ```SQL
  CREATE TABLE site_access(
      datekey DATE,
      site_id INT,
      city_code SMALLINT,
      user_name VARCHAR(32),
      pv BIGINT DEFAULT '0'
  )
  ENGINE=olap
  DUPLICATE KEY(datekey, site_id, city_code, user_name)
  PARTITION BY RANGE (datekey) 
  (
      START ("2019-01-01") END ("2021-01-01") EVERY (INTERVAL 1 YEAR),
      START ("2021-01-01") END ("2021-05-01") EVERY (INTERVAL 1 MONTH),
      START ("2021-05-01") END ("2021-05-04") EVERY (INTERVAL 1 DAY)
  )
  DISTRIBUTED BY HASH(site_id)
  PROPERTIES(
      "replication_num" = "3"
  );
    ```

  これは、CREATE TABLEステートメントの`PARTITION BY`節で次のように使用することと等価です：

    ```SQL
  PARTITION BY RANGE (datekey) (
  PARTITION p2019 VALUES [('2019-01-01'), ('2020-01-01')),
  PARTITION p2020 VALUES [('2020-01-01'), ('2021-01-01')),
  PARTITION p202101 VALUES [('2021-01-01'), ('2021-02-01')),
  PARTITION p202102 VALUES [('2021-02-01'), ('2021-03-01')),
  PARTITION p202103 VALUES [('2021-03-01'), ('2021-04-01')),
  PARTITION p202104 VALUES [('2021-04-01'), ('2021-05-01')),
  PARTITION p20210501 VALUES [('2021-05-01'), ('2021-05-02')),
  PARTITION p20210502 VALUES [('2021-05-02'), ('2021-05-03')),
  PARTITION p20210503 VALUES [('2021-05-03'), ('2021-05-04'))
  )
    ```

- **テーブルを整数タイプの列に分割**

  パーティション化された列のデータ型がINTの場合、`START`と`END`でパーティションの範囲を指定し、`EVERY`で増分値を定義します。 例：

  > **注**
  >
  > **START()**および**END()**内のパーティション列の値は、二重引用符で囲む必要があります。 しかし**EVERY()**内の増分値は二重引用符で囲む必要はありません。

  次の例では、すべてのパーティションの範囲は`1`から`5`であり、パーティションの増分は`1`です。

    ```SQL
  CREATE TABLE site_access (
      datekey INT,
      site_id INT,
      city_code SMALLINT,
      user_name VARCHAR(32),
      pv BIGINT DEFAULT '0'
  )
  ENGINE=olap
  DUPLICATE KEY(datekey, site_id, city_code, user_name)
  PARTITION BY RANGE (datekey) (START ("1") END ("5") EVERY (1)
  )
  DISTRIBUTED BY HASH(site_id)
  PROPERTIES ("replication_num" = "3");
    ```

  これは、CREATE TABLEステートメントの`PARTITION BY`節で次のように使用することと等価です：

    ```SQL
  PARTITION BY RANGE (datekey) (
  PARTITION p2019 VALUES [('2019-01-01'), ('2020-01-01')),
  PARTITION p2020 VALUES [('2020-01-01'), ('2021-01-01')),
  PARTITION p202101 VALUES [('2021-01-01'), ('2021-02-01')),
  PARTITION p202102 VALUES [('2021-02-01'), ('2021-03-01')),
  PARTITION p202103 VALUES [('2021-03-01'), ('2021-04-01')),
  PARTITION p202104 VALUES [('2021-04-01'), ('2021-05-01')),
  PARTITION p20210501 VALUES [('2021-05-01'), ('2021-05-02')),
  PARTITION p20210502 VALUES [('2021-05-02'), ('2021-05-03')),
  PARTITION p20210503 VALUES [('2021-05-03'), ('2021-05-04'))
  )
    ```

##### テーブル作成後にバッチで複数のパーティションを作成

  テーブルが作成された後、ALTER TABLEステートメントを使用してパーティションを追加できます。 構文は、テーブル作成時のバッチで複数のパーティションを作成する方法と似ています。 `ADD PARTITIONS`句で`START`、`END`、および`EVERY`を構成する必要があります。

  ```SQL
  ALTER TABLE site_access 
  ADD PARTITIONS START ("2021-01-04") END ("2021-01-06") EVERY (INTERVAL 1 DAY);
  ```

#### リストパーティショニング（v3.1以降）

[リストパーティショニング](./list_partitioning.md)は、列挙値に基づいてデータを効率的に管理し、クエリを高速化するのに適しています. これは、1つのパーティションに異なる値のデータを含める必要があるシナリオに特に適しています。 たとえば、国と都市に基づいてデータを頻繁にクエリおよび管理する場合、このパーティショニング方法を使用し、`city`列をパーティション化することができます。 この場合、1つのパーティションには1つの国に属するさまざまな都市のデータが含まれることができます。

StarRocksは、各パーティションごとに事前定義された値リストの明示的なマッピングに基づいてデータを対応するパーティションに保存します。

### パーティション管理

#### パーティションの追加

範囲パーティショニングおよびリストパーティショニングでは、新しいデータを格納する新しいパーティションを手動で追加できます。 ただし、表現パーティショニングの場合は、データのロード中にパーティションが自動的に作成されるため、手動で追加する必要はありません。

```SQL
ALTER TABLE site_access
ADD PARTITION p4 VALUES LESS THAN ("2020-04-30")
DISTRIBUTED BY HASH(site_id);
```

#### パーティションの削除

次のステートメントは、テーブル`site_access`からパーティション`p1`を削除します。

> **注**
>
> この操作ではパーティション内のデータが直ちに削除されるわけではありません. データは一定期間（デフォルトでは1日）トラッシュに保持されます。パーティションが誤って削除された場合は、[RECOVER](../sql-reference/sql-statements/data-definition/RECOVER.md)コマンドを使用して、パーティションとそのデータを復元できます。

```SQL
ALTER TABLE site_access
DROP PARTITION p1;
```

#### パーティションの復元

次のステートメントは、テーブル`site_access`にパーティション`p1`およびそのデータを復元します。

```SQL
RECOVER PARTITION p1 FROM site_access;
```

#### パーティションの表示

次のステートメントは、テーブル`site_access`のすべてのパーティションの詳細を返します。

```SQL
SHOW PARTITIONS FROM site_access;
```

## バケットの構成

### ランダムバケッティング（v3.1以降）

StarRocksは、パーティション内のデータをランダムにすべてのバケットに分散させます. データサイズが小さく、クエリのパフォーマンス要件が比較的低いシナリオに適しています. バケッティング方法を設定しない場合、StarRocksはデフォルトでランダムバケッティングを使用し、バケットの数を自動的に設定します。

ただし、大量のデータをクエリし、特定の列をフィルタ条件として頻繁に使用する場合、ランダムバケッティングによるクエリパフォーマンスは最適ではありません. このような場合、[hashバケッティング](#hash-bucketing)を使用することをお勧めします。これらの列をクエリのフィルタ条件として使用する場合、クエリがヒットした一部のバケット内のデータのみがスキャンおよび計算されるため、クエリのパフォーマンスが大幅に向上します。

#### 制限事項

- ランダムバケッティングは重複キーテーブルを作成するためにのみ使用できます。
- ランダムにバケッティングされているテーブルを[サイト配置](../using_starrocks/Colocate_join.md)に関連付けることはできません。
- [スパークロード](../loading/SparkLoad.md)を使用してランダムにバケット化されたテーブルにデータをロードすることはできません。

次のCREATE TABLEの例では、`DISTRIBUTED BY xxx`ステートメントは使用されず、StarRocksはデフォルトでランダムバケッティングを使用して、バケットの数を自動的に設定します。

```SQL
CREATE TABLE site_access1(
    event_day DATE,
    site_id INT DEFAULT '10', 
    pv BIGINT DEFAULT '0' ,
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT ''
)
DUPLICATE KEY(event_day,site_id,pv);
```

ただし、StarRocksのバケッティングメカニズムに精通している場合は、ランダムバケッティングを使用してテーブルを作成する際にバケットの数を手動で設定することもできます。

```SQL
CREATE TABLE site_access2(
    event_day DATE,
    site_id INT DEFAULT '10', 
    pv BIGINT DEFAULT '0' ,
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT ''
)
DUPLICATE KEY(event_day,site_id,pv)
DISTRIBUTED BY RANDOM BUCKETS 8; -- 手動でバケットの数を8に設定
```

### hashバケッティング
```
StarRocksは、ハッシュバケッティングを使用して、パーティション内のデータをバケツに分割します。これはバケティングキーと[バケツの数](#バケツの数を決定する)に基づいて行われます。ハッシュバケッティングでは、ハッシュ関数がデータのバケティングキーの値を入力として受け取り、ハッシュ値を計算します。ハッシュの値とバケツの間のマッピングに基づいて、データが対応するバケツに格納されます。

#### 利点

- クエリのパフォーマンスが向上します: 同じバケティングキーの値を持つ行は同じバケツに格納されるため、クエリ実行中にスキャンされるデータ量が削減されます。

- データの均等な分布: カーディナリティ（一意の値の数が多い）の高い列をバケティングキーとして選択することで、データをバケツ全体に均等に分散させることができます。

#### バケティング列の選択方法

以下の2つの要件を満たす列をバケティング列として選択することを推奨します。

- IDなどの高カーディナリティな列
- クエリのフィルタ条件として頻繁に使用される列

しかし、どの列も両方の要件を満たさない場合は、クエリの複雑さに応じてバケティング列を決定する必要があります。

- クエリが複雑な場合、データを可能な限り均等に各バケツに分散させ、クラスタのリソース利用を向上させるために、高カーディナリティな列をバケティング列として選択することをお勧めします。
- クエリが比較的単純な場合、クエリの効率を改善するために、クエリのフィルタ条件として頻繁に使用される列をバケティング列として選択することをお勧めします。

1つのバケティング列を使用してパーティションデータを全てのバケツに均等に分散できない場合、複数のバケティング列を選択することができます。ただし、3つ以上の列を使用することは推奨されていません。

#### 注意事項

- **テーブルを作成する際に、バケティング列を指定する必要があります**。
- バケティング列のデータ型は、INTEGER、DECIMAL、DATE/DATETIME、またはCHAR/VARCHAR/STRINGである必要があります。
- バケティング列は、指定した後に変更することはできません。

#### 例

次の例では、`site_access`テーブルが`site_id`をバケティング列として使用して作成されています。また、`site_access`テーブルのデータがクエリされる際、データは頻繁にサイトでフィルタリングされます。そのため、`site_id`をバケティングキーとして使用することで、クエリ中に関連ないバケツを大幅に減らすことができます。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)
(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

`site_access`テーブルの各パーティションが10つのバケツを持っていると仮定します。次のクエリでは、10つのバケツのうち9つが刈り取られるため、StarRocksは`site_access`テーブル内のデータを1/10だけスキャンすれば済みます。

```SQL
select sum(pv)
from site_access
where site_id = 54321;
```

ただし、`site_id`が均等に分散されていない場合、多くのクエリがわずかな数のサイトのデータをリクエストする可能性があります。この場合、1つのバケティング列だけを使用すると、深刻なデータスキューを引き起こし、システムのパフォーマンスに影響を与えることがあります。このような場合、複数のバケティング列の組み合わせを使用することができます。たとえば、次のステートメントでは、`site_id`と`city_code`をバケティング列として使用しています。

```SQL
CREATE TABLE site_access
(
    site_id INT DEFAULT '10',
    city_code SMALLINT,
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(site_id, city_code, user_name)
DISTRIBUTED BY HASH(site_id,city_code);
```

実際的には、ビジネス特性に基づいて1つまたは2つのバケティング列を使用することができます。1つのバケティング列である`site_id`を使用することは、ノード間のデータ交換を減らすために短いクエリに非常に有益であり、クラスタ全体のパフォーマンスを向上させることができます。一方で、`site_id`および`city_code`の2つのバケティング列を採用することは、長いクエリに対して非常に有利であり、分散クラスタ全体の並行性を活用してパフォーマンスを大幅に向上させることができます。

> **注記**
>
> - 短いクエリは、少量のデータをスキャンし、単一ノードで完了できます。
> - 長いクエリは、大量のデータをスキャンし、分散クラスタ内の複数ノードでの並列スキャンによってパフォーマンスが大幅に向上します。

### バケツの数を決定する

バケツは、StarRocks内でデータファイルが実際にどのように組織化されているかを反映しています。

- テーブル作成時にバケツの数を設定する方法

  - 方法1: 自動的にバケツの数を設定する（推奨）

    - ハッシュバケティングでテーブルを構成

      v2.5.7以降、StarRocksは、テーブルの作成時にパーティションの機械リソースとデータ容量に基づいてバケツの数を自動的に設定することができます。
      > **注意**
      >
      > パーティションの生データサイズが100 GBを超える場合は、Method 2を使用してバケツの数を手動で構成することをお勧めします。

      例:

      ```sql
      CREATE TABLE site_access (
          site_id INT DEFAULT '10',
          city_code SMALLINT,
          user_name VARCHAR(32) DEFAULT '',
          pv BIGINT SUM DEFAULT '0')
      AGGREGATE KEY(site_id, city_code, user_name)
      DISTRIBUTED BY HASH(site_id,city_code); -- バケツの数を設定する必要はありません
      ```
     
    - ランダムバケティングでテーブルを構成

      v2.5.7以降、StarRocksは、テーブルの作成時にパーティションの機械リソースとデータ容量に基づいてバケツの数を自動的に設定できます。v3.2.0以降、StarRocksは、テーブルの作成時だけでなく、データ読み込み中にクラスタの容量と読み込まれたデータのボリュームに基づいて、パーティション内のバケツの数を**動的に増やします**。これにより、パーティションの作成が容易になるだけでなく、大量のデータの一括読み込みのパフォーマンスが向上します。
      > **注記**
      >
      > バケツサイズはデフォルトで`1024 * 1024 * 1024 B`（4 GB）です。テーブルの作成時に`PROPERTIES ("bucket_size"="xxx")`でバケツサイズを指定できます。

      例:

      ```SQL
      CREATE TABLE site_access1 (
          event_day DATE,
          site_id INT DEFAULT '10', 
          pv BIGINT DEFAULT '0' ,
          city_code VARCHAR(100),
          user_name VARCHAR(32) DEFAULT ''
      )
      DUPLICATE KEY (event_day,site_id,pv)
      ; -- このテーブルのパーティションのバケツの数はStarRocksによって自動的に設定されます。バケツサイズはデフォルトで4 GBです。このテーブルはランダムバケティングを構成しているため、バケティングキーを設定する必要がありません。
      
      CREATE TABLE site_access1 (
          event_day DATE,
          site_id INT DEFAULT '10', 
          pv BIGINT DEFAULT '0' ,
          city_code VARCHAR(100),
          user_name VARCHAR(32) DEFAULT '')
      DUPLICATE KEY (event_day,site_id,pv) 
      PROPERTIES("bucket_size"="1073741824") -- バケツサイズを1 GBに設定
      ; -- このテーブルのパーティションのバケツの数はStarRocksによって自動的に設定されます。このテーブルはランダムバケティングを構成しているため、バケティングキーを設定する必要がありません。
      ```

    テーブルを作成した後、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md)を実行して、各パーティションのバケツの数を確認できます。ハッシュバケティングで構成されたテーブルの場合、各パーティションのバケツの数は**固定**されています。

    ランダムバケティングで構成されたテーブルの場合、各パーティションのバケツの数は**動的に変更**することができます。したがって、返される結果には各パーティションの**現在の**バケツの数が表示されます。
    > **注意**
    >
    > このテーブルのタイプの場合、パーティション内の実際の階層は、パーティション > サブパーティション > バケツの順です。StarRocksはバケツの数を増やすために、実際には特定の数のバケツを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS`ステートメントは、同じパーティション名の複数のデータ行を返すことがありますが、これらは同じパーティション内のサブパーティションの情報を示しています。

  - 方法2: バケツの数を手動で設定する

     v2.4.0以降、StarRocksは、クエリ中に複数のスレッドを使用してテーブレットを並列スキャンすることをサポートし、スキャンパフォーマンスの依存度を減らします。各テーブレットには約10 GBの生データが含まれるようにすることをお勧めします。バケツの数を手動で設定することを意図している場合は、テーブルの各パーティションのデータ量を見積もり、それに応じてテーブレットの数を決定することができます。

     テーブレットの並列スキャンを有効にするには、システム全体で`enable_tablet_internal_parallel`パラメータが`TRUE`に設定されていることを確認します（`SET GLOBAL enable_tablet_internal_parallel = true;`）。

    ```SQL
    CREATE TABLE site_access (
        site_id INT DEFAULT '10',
        city_code SMALLINT,
        user_name VARCHAR(32) DEFAULT '',
        pv BIGINT SUM DEFAULT '0')
    AGGREGATE KEY(site_id, city_code, user_name)
    300 GBのロードするパーティションごとのバケツの数は30に設定できます。各タブレットが10GBの生データを含むことを推奨しているため、バケツの数は30に設定できます。

- 新しいパーティションにバケットの数を設定する方法

  - 方法1：バケットの数を自動設定する（推奨）
    - ハッシュバケット設定のテーブル

      v2.5.7以降、StarRocksはパーティションの作成時に機械リソースとデータ容量に基づいてバケツの数を自動設定する機能をサポートしています。
      > **注意**
      >
      > パーティションの生データサイズが100 GBを超える場合、方法2を使用してバケツの数を手動で構成することをお勧めします。

    - ランダムバケット設定のテーブル

      v2.5.7以降、StarRocksはパーティションの作成時に機械リソースとデータ容量に基づいてバケツの数を自動設定することができます。 v3.2.0以降、StarRocksはバケツの数を自動設定するロジックをさらに最適化しました。パーティションのデータロード中に、クラスタの容量とロードされたデータのボリュームに基づいて、パーティション内のバケツの数を動的に増やすことができます。これにより、テーブルの作成が容易になるだけでなく、バルクロードのパフォーマンスが向上します。
      > **注意**
      >
      > バケツのサイズはデフォルトで `1024 * 1024 * 1024 B` (4 GB) です。パーティションを追加する際には、`PROPERTIES ("bucket_size"="xxx")` でバケツのサイズを指定することができます。

    パーティションを追加した後、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md) を実行して、新しいパーティションにStarRocksが設定したバケツの数を確認できます。ハッシュバケット設定のテーブルの場合、新しいパーティションのバケツの数は**固定**です。
    ランダムバケット設定のテーブルの場合、新しいパーティションのバケツの数は**動的に変更**することができます。そのため、返される結果は新しいパーティションの**現在の**バケツの数を表示します。
      > **注意**
      >
      > この表タイプでは、パーティションの内部構造は次のようになります：パーティション > サブパーティション > バケツ。バケツの数を増やすために、StarRocksは実際には一定数のバケツを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS` ステートメントは、同じパーティション名の複数のデータ行を返すことがあります。これらは同じパーティション内のサブパーティションの情報を示しています。

  - 方法2：バケットの数を手動で設定する

    新しいパーティションを追加する際にバケット数を手動で指定することもできます。新しいパーティションのバケット数を計算するために、テーブルの作成時にバケットの数を手動で設定するアプローチを参照できます。上記の手順でバケットの数を手動で設定した場合と同じです。

    ```SQL
    -- パーティションを手動で作成
    ALTER TABLE <table_name> 
    ADD PARTITION <partition_name>
        [DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]];
        
    -- 動的パーティショニング
    ALTER TABLE <table_name> 
    SET ("dynamic_partition.buckets"="xxx");
    ```