---
displayed_sidebar: "Japanese"
---

# テーブルデザインの理解

## コラムナーストレージ

![コラムナーストレージ](../assets/3.1-1.png)

StarRocksのテーブルは他のリレーショナルデータベースと同様に、行と列で構成されています。各行はユーザーデータのレコードを保持し、各列のデータは同じ型であることが特徴です。表のすべての行は同じ数の列を持っています。テーブルに列を動的に追加または削除することができます。テーブルの列は次のように分類することができます：次元列と度量列。次元列はキーカラムとも呼ばれ、度量列は値カラムとも呼ばれます。次元列の値はデータをグループ化およびソートするために使用され、度量列の値はsum、count、min、max、hll_union_agg、bitmap_unionなどの関数を使用して累積できます。

StarRocksはテーブルにコラムナーストレージを使用しています。物理的には、列のデータはデータブロックに分割され、エンコードされ、圧縮され、そして永続的にディスク上に保存されます。論理的には、列のデータは、同じデータ型の要素から構成される配列と比較することができます。列に保持される値は、それぞれの配列の要素として列の順序に従ってリスト化されます。これは、行に保持される列の値が同じ配列インデックスを持つことを意味します。配列インデックスは暗黙的であり、保存する必要はありません。テーブルのすべての行は、1つまたは複数の次元列で指定された順序でソートされます。ソートされたテーブル内の行の位置は、その行のシーケンス番号によって表されます。

テーブルのクエリにおいて、次元列プレフィックスを構成する特定の次元列に対する等価条件または範囲条件を指定する場合、StarRocksはソートされたデータの中で興味のある行を迅速に特定するためにバイナリ・サーチを実行できます。例えば、`table1`という名前のテーブルからデータをクエリしたい場合、テーブルは`event_day`、`siteid`、`citycode`、および`username`の4つの列から構成されています、そのうち`event_day`と`siteid`は次元列です。`event_day = 2020-09-18`および`siteid = 2`をクエリ条件として指定すると、StarRocksはバイナリ・サーチを実行し、指定された範囲内のデータのみ処理する必要があります。なぜならば、`event_day`と`siteid`は次元列プレフィックスを構成することができるからです。`citycode = 4`および`username = Andy`をクエリ条件として指定する場合、StarRocksはバイナリ・サーチを実行できず、テーブル全体のデータを処理する必要があります。なぜならば、`citycode`と`username`は次元列プレフィックスを構成することができないからです。

## インデキシング

StarRocksはプレフィックスインデックスとパーコラムインデックスを使用して、興味のある行のデータブロックの開始行を迅速に特定します。

以下の図は、StarRocksでのテーブルクエリの高速化のためのテーブルデザインの仕組みを示しています。

![インデキシングの概要](../assets/3.1-2.png)

StarRocksのテーブルデータは以下の3つのパーツに分かれています：

- プレフィックスインデックス
  
  StarRocksは、1024行ごとのデータをデータブロックとして保存し、そのエントリをプレフィックスインデックステーブルに保持します。各データブロックのプレフィックスインデックスエントリの内容は、データブロックでの開始行の次元列から構成されるプレフィックスであり、36バイトを超えることはできません。プレフィックスインデックスは疎なインデックスです。行をクエリする際、StarRocksはプレフィックスインデックステーブルを検索して、行の次元列で構成されるプレフィックスを取得します。そして、StarRocksは興味のある行を取り巻くデータブロックの開始行のシーケンス番号を迅速に特定できます。

- パーカラムデータブロック
  
  StarRocksは、各列のデータを複数の64KBデータブロックに分割します。各データブロックは独立してエンコードおよび圧縮され、最小限のI/O単位としてディスクから読み取られたり書き込まれたりします。

- パーカラムインデックス
  
  StarRocksは、各列に対して行番号インデックスを維持します。行番号インデックステーブルでは、列のデータブロックがそれぞれ特定の行番号にマップされます。また、行番号インデックステーブルの各エントリは、特定の行番号にマップされるデータブロックの開始行番号、アドレス、および長さで構成されています。行をクエリする際、StarRocksは行番号インデックステーブルを検索して、行のシーケンス番号にマップされたデータブロックのアドレスを取得します。そして、StarRocksはデータブロックを読み取って行を特定します。

要約すると、StarRocksは、特定の行の次元列から構成されるプレフィックスを使用してテーブルの行を特定するために、以下の5つのステップを実行します：

1. プレフィックスインデックステーブルを検索して、興味のある行のデータブロックの開始行のシーケンス番号を特定します。

2. 各次元列の行番号インデックステーブルを検索して、次元列のデータブロックを特定します。

3. データブロックを読み取ります。

4. データブロックを伸長して解読します。

5. 次元列インデックスにマップされた行を見つけるためにデータブロックを検索します。

## 高速処理

このセクションでは、StarRocksがデータを高速に処理するためのメカニズムについて紹介します。

### プリアグリゲーション

StarRocksは、集約テーブルを提供しています。集約テーブルでは、テーブルの次元列で同じ値を持つ行を1つの行に集約することができます。集約から生成された新しい行の各次元列の値は変わらず、メトリック列の値は指定した集約関数によって集約され、結果の値がメトリック列の新しい行に生成されます。プリアグリゲーションは、集約操作を加速します。

### パーティショニングとバケティング

StarRocksの各テーブルは複数のタブレットに分割されています。各タブレットは、複数のBEs上の複数のレプリカに格納されます。BEの数とタブレットの数は、計算リソースの変更やデータサイズに合わせて柔軟にスケーリングできます。クエリを開始する際には、複数のBEが並列でテーブレットを検索し、興味のあるデータを迅速に特定できます。また、タブレットレプリカは複製されて移行することができ、これによりデータの信頼性が高まり、データの偏りが防がれます。パーティショニングとバケティングにより、データの取得効率と安定性が確保されます。

### マテリアライズドビュー

テーブルのプレフィックスインデックスは、テーブルの次元列の順序に依存してクエリを加速します。次元列プレフィックスに含まれない次元列を使用してクエリ述語を構築する場合、プレフィックスインデックスは機能しません。この場合には、テーブルのためにマテリアライズドビューを作成することができます。マテリアライズドビューのデータはテーブルのデータと同じように構成されて保存されます。しかし、マテリアライズドビューには独自のプレフィックスインデックスがあります。マテリアライズドビューのプレフィックスインデックスを作成する際には、適切な集約粒度、列数、および次元列の順序を指定して、頻繁に使用されるクエリ条件がマテリアライズドビューのプレフィックスインデックステーブルで期待どおりのエントリにヒットするようにします。

### パーカラムインデックス

StarRocksは、Bloomフィルタ、ゾーンマップ、ビットマップインデックスなどのパーカラムインデックスをサポートしています：

- Bloomフィルタは、クエリしたい値がデータブロックに含まれているかどうかを決定するために使用されます。

- ゾーンマップは、指定された範囲内の値を特定するために使用されます。

- ビットマップインデックスは、ENUMデータ型の列内で特定のクエリ条件を満たす行を特定するために使用されます。