```plaintext
---
displayed_sidebar: "Japanese"
---

# JSON演算子

StarRocksは次のJSON比較演算子をサポートしています：`<`, `<=`, `>`, `>=`, `=`, および `!=`。これらの演算子を使用してJSONデータをクエリできます。ただし、StarRocksでは`IN`演算子を使用してJSONデータをクエリすることはできません。

- > 演算子のオペランドは両方ともJSON値でなければなりません。

- > 演算子の1つのオペランドがJSON値である一方、他方がそうでない場合、算術演算中にJSON値でないオペランドはJSON値に変換されます。変換規則の詳細については、[CAST](./json-query-and-processing-functions/cast.md)を参照してください。

## 算術規則

JSON演算子は次の算術規則に準拠しています：

- 演算子のオペランドが同じデータ型のJSON値である場合：
  - 両方のオペランドが、NUMBER、STRING、またはBOOLEANなどの基本データ型のJSON値である場合、演算子は基本データ型の算術ルールに従って算術演算を実行します。

> 注意: 両方のオペランドが数値である場合でも、1つはDOUBLE値であり、他方がINT値である場合、演算子はINT値をDOUBLE値に変換します。

- 両方のオペランドがOBJECTやARRAYなどの複合データ型のJSON値である場合、演算子はオペランドのキーを辞書順に並べ替え、最初のオペランドのキーの順序に基づいてキーの値を比較します。

例1：

最初のオペランドは `{"a": 1, "c": 2}` で、2番目のオペランドは `{"b": 1, "a": 2}` です。この例では、演算子はオペランド間のキー `a` の値を比較します。最初のオペランドのキー `a` の値は `1` であり、2番目のオペランドのキー `a` の値は `2` です。値 `1` は値 `2` よりも大きいため、演算子は最初のオペランド `{"a": 1, "c": 2}` が2番目のオペランド `{"b": 1, "``a``": 2}` よりも小さいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 2} ');

       -> 1
```

例2：

最初のオペランドは `{"a": 1, "c": 2}` で、2番目のオペランドは `{"b": 1, "a": 1}` です。この例では、演算子はまずオペランド間のキー `a` の値を比較します。オペランドのキー `a` の値は両方とも `1` です。次に、演算子はオペランド間のキー `c` の値を比較します。2番目のオペランドにはキー `c` が含まれていません。したがって、演算子は最初のオペランド `{"a": 1, "c": 2}` が2番目のオペランド `{"b": 1, "a": 1}` よりも大きいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 1}');

       -> 0
```

- 演算子のオペランドが異なるデータ型のJSON値である場合、演算子は次の算術規則に従ってオペランドを比較します：NULL < BOOLEAN < ARRAY < OBJECT < DOUBLE < INT < STRING。

```plaintext
mysql> SELECT PARSE_JSON('"a"') < PARSE_JSON('{"a": 1, "c": 2}');

       -> 0
```