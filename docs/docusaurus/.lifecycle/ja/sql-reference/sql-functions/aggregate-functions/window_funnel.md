---
displayed_sidebar: "Japanese"
---

# window_funnel

## 説明

スライディングウィンドウ内のイベントチェーンを検索し、イベントチェーン内での最大連続イベント数を算出します。この関数は、コンバージョンレートの分析に一般的に使用されます。v2.3からサポートされています。

この関数は次のルールに従います:

- イベントチェーン内の最初のイベントからカウントを開始します。最初のイベントが見つかった場合、イベントカウンターが1に設定され、スライディングウィンドウが開始されます。最初のイベントが見つからない場合は0が返されます。

- スライディングウィンドウでは、イベントチェーン内のイベントが連続して発生すると、カウンターが増加します。スライディングウィンドウを超えると、イベントカウンターはもはや増加しません。

- 指定された条件に一致する複数のイベントチェーンがある場合、最も長いイベントチェーンが返されます。

## 構文

```Plain
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメーター

- `window`: スライディングウィンドウの長さ。サポートされるデータ型はBIGINTです。単位は`time`パラメーターに依存します。`time`のデータ型がDATEの場合、単位は日です。`time`のデータ型がDATETIMEの場合、単位は秒です。

- `time`: タイムスタンプを含む列です。DATEおよびDATETIME型がサポートされています。

- `mode`: イベントチェーンがフィルタリングされるモード。サポートされるデータ型はINTです。値の範囲: 0, 1, 2。
  - `0` はデフォルト値で、一般的なファネルの計算を示します。
  - `1` は `DEDUPLICATION` モードを示し、フィルタリングされたイベントチェーンには繰り返しイベントを持つことはできません。`array`パラメーターが `[event_type = 'A', event_type = 'B', event_type = 'C', event_type = 'D']` という場合、元のイベントチェーンが "A-B-C-B-D" であるとします。イベントBが繰り返され、フィルタリングされたイベントチェーンは "A-B-C" です。
  - `2` は `FIXED` モードを示し、フィルタリングされたイベントチェーンには指定されたシーケンスを崩すイベントを含むことはできません。前述の `array` パラメーターを使用し、元のイベントチェーンが "A-B-D-C" であるとします。イベントDがシーケンスを中断し、フィルタリングされたイベントチェーンは "A-B" です。
  - `4` は `INCREASE` モードを示し、フィルタリングされたイベントは厳密に増加するタイムスタンプを持たなければなりません。重複したタイムスタンプはイベントチェーンを中断します。このモードはv2.5からサポートされています。

- `array`: 定義されたイベントチェーンです。配列である必要があります。

## 返り値

BIGINT型の値を返します。

## 例

**例1**: `uid` を基に、連続イベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは `0` です。

この例では、`uid` でソートされたデータが含まれる `action` テーブルを使用します。

```Plaintext
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:20:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Order      | 2020-01-02 11:00:00 |
| 2    | Pay        | 2020-01-02 11:10:00 |
| 3    | Browse     | 2020-01-02 11:20:00 |
| 3    | Click      | 2020-01-02 12:00:00 |
| 4    | Browse     | 2020-01-02 11:50:00 |
| 4    | Click      | 2020-01-02 12:00:00 |
| 5    | Browse     | 2020-01-02 11:50:00 |
| 5    | Click      | 2020-01-02 12:00:00 |
| 5    | Order      | 2020-01-02 11:10:00 |
| 6    | Browse     | 2020-01-02 11:50:00 |
| 6    | Click      | 2020-01-02 12:00:00 |
| 6    | Order      | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action
group by uid
order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

結果の説明:

- `uid = 1` の一致するイベントチェーンは "Browse-Click-Order-Pay" であり、`4` が返されます。最後の "Browse" イベントの時間 (2020-01-02 11:00:00) は条件を満たさず、カウントされません。

- `uid = 2` のイベントチェーンは最初のイベント "Browse" から始まらず、`0` が返されます。

- `uid = 3` の一致するイベントチェーンは "Browse" であり、`1` が返されます。"Click" イベントの時間が1800秒を超えており、カウントされていません。

- `uid = 4` の一致するイベントチェーンは "Browse-Click" であり、`2` が返されます。

- `uid = 5` の一致するイベントチェーンは "Browse-Click" であり、`2` が返されます。"Order" イベント (2020-01-02 11:10:00) はイベントチェーンに属しておらず、カウントされていません。

- `uid = 6` の一致するイベントチェーンは "Browse-Click-Order" であり、`3` が返されます。

**例2**: `uid` を基に、連続イベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモード `0` および `1` を使用します。

この例は、`time` でソートされたデータが含まれる `action1` テーブルを使用します。

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:29:00 |
| 1    | Click      | 2020-01-02 11:29:50 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Click      | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', 
        event_type='Click', event_type='Order', event_type='Pay']) AS level
from action1
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` の場合、"Click" イベント (2020-01-02 11:29:50) は繰り返しイベントですが、モード `0` が使用されているため、それでもカウントされます。したがって、`4` が返されます。

`mode` を `1` に変更し、再度ステートメントを実行します。

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

重複を削除した後の最長のイベントチェーンは "Browse-Click-Order" であり、`3` が返されます。

**例3**: `uid` を基に、連続イベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルタモード `0` および `2` を使用します。

この例は、`time` でソートされたデータが含まれる `action2` テーブルを使用します。
```mysql
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | ブラウジング | 2020-01-02 11:00:00 |
| 2    | ブラウジング | 2020-01-02 11:00:01 |
| 1    | クリック     | 2020-01-02 11:10:00 |
| 1    | 支払い       | 2020-01-02 11:30:00 |
| 1    | 注文         | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 行のセット (0.01 秒)
```

以下のステートメントを実行してください。

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='ブラウジング', event_type='クリック', 
        event_type='注文', event_type='支払い']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 行のセット (0.02 秒)
```

`uid = 1` に対して `3` が返されるのは、モード `0` が使用され、"支払い" イベント（2020-01-02 11:30:00）がイベントチェーンを壊していないからです。

`モード` を `2` に変更して、もう一度ステートメントを実行してください。

```Plaintext
select uid,
       window_funnel(1900,time,2,[event_type='ブラウジング', event_type='クリック', 
        event_type='注文', event_type='支払い']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 行のセット (0.06 秒)
```

"支払い" イベントがイベントチェーンを壊して、イベントカウンターが停止するため、`2` が返されます。フィルタリングされたイベントチェーンは "ブラウジング-クリック" です。

**Example 4**: `uid` に基づいて連続イベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルターモードは `0` と `4` が使用されます。

この例では、`time` でデータがソートされた `action3` テーブルを使用します。

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | ブラウジング | 2020-01-02 11:00:00 |
| 1    | クリック     | 2020-01-02 11:00:01 |
| 2    | ブラウジング | 2020-01-02 11:00:03 |
| 1    | 注文         | 2020-01-02 11:00:31 |
| 2    | クリック     | 2020-01-02 11:00:03 |
| 2    | 注文         | 2020-01-02 11:01:03 |
+------+------------+---------------------+
3 行のセット (0.02 秒)
```

以下のステートメントを実行してください。

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='ブラウジング', event_type='クリック',
        event_type='注文']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
```

`uid = 1` と `uid = 2` に対して`3` が返されます。

`モード` を `4` に変更して、もう一度ステートメントを実行してください。

```Plaintext
select uid,
       window_funnel(1900,time,4,[event_type='ブラウジング', event_type='クリック',
        event_type='注文']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
1 行のセット (0.02 秒)
```

`uid = 2` に対して `1` が返されます。モード `4`（厳格に増加）が使用されています。 "クリック" は "ブラウジング" と同じ秒に発生します。したがって、"クリック" と "注文" はカウントされません。

## キーワード

window funnel, funnel, window_funnel
```