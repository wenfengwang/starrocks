```yaml
---
displayed_sidebar: "Japanese"
---

# window_funnel

## 説明

スライディングウィンドウ内のイベントチェーンを検索し、イベントチェーン内の連続イベントの最大数を計算します。この関数はコンバージョンレートの分析に一般的に使用されます。v2.3からサポートされています。

この関数は次のルールに従って動作します。

- イベントチェーン内の最初のイベントからカウントを開始します。最初のイベントが見つかると、イベントカウンタが1に設定され、スライディングウィンドウが開始されます。最初のイベントが見つからない場合は0が返されます。

- スライディングウィンドウ内では、イベントチェーン内のイベントが連続して発生すると、カウンタが増加します。スライディングウィンドウを超えると、イベントカウンタはもはや増加しません。

- 指定された条件に一致する複数のイベントチェーンがある場合、最も長いイベントチェーンが返されます。

## 構文

```Plain
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメーター

- `window`: スライディングウィンドウの長さです。サポートされるデータ型はBIGINTです。単位は`time`パラメータに依存します。`time`パラメータのデータ型がDATEの場合、単位は日です。`time`パラメータのデータ型がDATETIMEの場合、単位は秒です。

- `time`: タイムスタンプを含む列です。DATEおよびDATETIMEタイプがサポートされています。

- `mode`: イベントチェーンがフィルタリングされるモードです。サポートされるデータ型はINTです。値の範囲：0、1、2。
  - `0` はデフォルト値で、一般的なファネル計算を示します。
  - `1` は `DEDUPLICATION` モードを示し、フィルタリングされたイベントチェーンには繰り返しイベントが含まれていてはなりません。`array`パラメータが `[event_type = 'A', event_type = 'B', event_type = 'C', event_type = 'D']` であり、元のイベントチェーンが "A-B-C-B-D" の場合、イベントBが繰り返され、フィルタリングされたイベントチェーンは "A-B-C" になります。
  - `2` は `FIXED` モードを示し、フィルタリングされたイベントチェーンには指定されたシーケンスを崩すイベントが含まれてはなりません。前述の `array` パラメータが使用され、元のイベントチェーンが "A-B-D-C" の場合、イベントDはシーケンスを中断し、フィルタリングされたイベントチェーンは "A-B" になります。
  - `4` は `INCREASE` モードを示し、フィルタリングされたイベントは厳密に増加するタイムスタンプを持たなければなりません。重複するタイムスタンプはイベントチェーンを中断します。このモードはv2.5からサポートされています。

- `array`: 定義されたイベントチェーンです。配列である必要があります。

## 返り値

BIGINT型の値を返します。

## 例

**例1**：`uid`に基づいて連続イベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは`0`です。

この例では、`uid`でソートされた`action`テーブルが使用されます。

```Plaintext
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:20:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Order      | 2020-01-02 11:00:00 |
| 2    | Pay        | 2020-01-02 11:10:00 |
| 3    | Browse     | 2020-01-02 11:20:00 |
| 3    | Click      | 2020-01-02 12:00:00 |
| 4    | Browse     | 2020-01-02 11:50:00 |
| 4    | Click      | 2020-01-02 12:00:00 |
| 5    | Browse     | 2020-01-02 11:50:00 |
| 5    | Click      | 2020-01-02 12:00:00 |
| 5    | Order      | 2020-01-02 11:10:00 |
| 6    | Browse     | 2020-01-02 11:50:00 |
| 6    | Click      | 2020-01-02 12:00:00 |
| 6    | Order      | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action
group by uid
order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

結果の説明：

- `uid = 1` の一致するイベントチェーンは "Browse-Click-Order-Pay" であり、`4` が返されます。最後の "Browse" イベントの時刻（2020-01-02 11:00:00）は条件を満たさず、カウントされません。

- `uid = 2` のイベントチェーンは最初のイベント "Browse" から始まらず、`0` が返されます。

- `uid = 3` の一致するイベントチェーンは "Browse" で、`1` が返されます。"Click" イベントは1800秒の時間ウィンドウを超えており、カウントされません。

- `uid = 4` の一致するイベントチェーンは "Browse-Click" であり、`2` が返されます。

- `uid = 5` の一致するイベントチェーンは "Browse-Click" であり、`2` が返されます。"Order" イベント（2020-01-02 11:10:00）はイベントチェーンに属していないため、カウントされません。

- `uid = 6` の一致するイベントチェーンは "Browse-Click-Order" であり、`3` が返されます。

**例2**：`uid`に基づいて連続イベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは`0`および`1`です。

この例では、`time`でソートされた`action1`テーブルが使用されます。

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:29:00 |
| 1    | Click      | 2020-01-02 11:29:50 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Click      | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

次のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', 
        event_type='Click', event_type='Order', event_type='Pay']) AS level
from action1
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` の場合、"Click" イベント（2020-01-02 11:29:50）は繰り返しイベントですが、モード `0` が使用されているためカウントされます。したがって、`4` が返されます。

`mode`を`1`に変更し、ステートメントを再実行します。

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

重複を省略した後の最長のフィルタリングされたイベントチェーンは "Browse-Click-Order" であり、`3` が返されます。

**例3**：`uid`に基づいて連続イベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルタモードは`0`および`2`です。

この例では、`time`でソートされた`action2`テーブルが使用されます。

```Plaintext
```
```sql
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Order      | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

次のステートメントを実行します：

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` に対して `3` が返されます。モード `0` が使用されており、"Pay" イベント (2020-01-02 11:30:00) がイベントチェーンを崩さないためです。

`mode` を `2` に変更して、もう一度ステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,2,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

"Pay" イベントがイベントチェーンを崩し、イベントカウンタが停止するため、`2` が返されます。フィルターされたイベントチェーンは "Browse-Click" です。

**Example 4**: `uid` を基に、連続イベントの最大数を計算します。スライディングウィンドウは 1900 秒で、フィルターモードは `0` および `4` を使用します。

この例では、`time` でデータが並べ替えられた `action3` テーブルを使用します。

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:00:01 |
| 2    | Browse     | 2020-01-02 11:00:03 |
| 1    | Order      | 2020-01-02 11:00:31 |
| 2    | Click      | 2020-01-02 11:00:03 |
| 2    | Order      | 2020-01-02 11:01:03 |
+------+------------+---------------------+
3 rows in set (0.02 sec)
```

次のステートメントを実行します：

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
```

`uid = 1` および `uid = 2` に対して `3` が返されます。

`mode` を `4` に変更し、もう一度ステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,4,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
1 row in set (0.02 sec)
```

`uid = 2` に対して `1` が返されます。モード `4` (厳密に増加) が使用されています。"Click" が "Browse" と同じ秒に発生するため、"Click" と "Order" はカウントされません。

## キーワード

window funnel, funnel, window_funnel
```