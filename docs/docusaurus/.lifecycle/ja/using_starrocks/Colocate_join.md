---
displayed_sidebar: "Japanese"
---

# コロケートジョイン

シャッフルジョインとブロードキャストジョインでは、結合条件が満たされると、2つの結合テーブルのデータ行が1つのノードにマージされ、結合が完了します。これら2つの結合方法では、ノード間のデータネットワーク転送による遅延やオーバーヘッドを回避することはできません。

コロケートジョインの主要なアイデアは、同じコロケートグループ内のテーブルのバケットキー、コピー数、およびコピー配置を一貫させることです。もし結合列がバケット化キーである場合、計算ノードは他のノードからデータを取得せずにローカル結合のみを行うことができます。コロケートジョインは等価結合をサポートしています。

本書では、コロケートジョインの原理、実装、使用法、および考慮事項について紹介します。

## 用語

* **コロケートグループ（CG）**：CGには1つ以上のテーブルが含まれます。CG内のテーブルは同じバケット化およびレプリカ配置を持ち、コロケートグループスキーマを使用して記述されます。
* **コロケートグループスキーマ（CGS）**：CGSには、CGのバケット化キー、バケット数、およびレプリカ数が含まれます。

## 原理

コロケートジョインは、同じCGSを持つテーブルセットでCGを形成し、これらのテーブルの対応するバケットコピーが同一のBEノードセットに配置されることを保証することです。CG内のテーブルがバケット化された列で結合操作を行う場合、ローカルデータのみが結合され、ノード間でデータを転送する時間が保存されます。

バケットシーケンスは `hash(key) mod buckets` で得られます。テーブルが8つのバケットを持つとすると、\[0, 1, 2, 3, 4, 5, 6, 7\] の8つのバケットがあり、各バケットには1つ以上のサブテーブルがあり、サブテーブルの数はパーティションの数に依存します。複数パーティションのテーブルの場合、複数のタブレットが存在します。

同じCG内のテーブルは以下に準拠する必要があります。

1. 同じCG内のテーブルは、同一のバケット化キー（タイプ、数、順序）および同じ数のバケットを持っている必要があります。これにより、複数のテーブルのデータスライスを1つずつ分散制御することができます。バケット化キーはテーブル作成文 `DISTRIBUTED BY HASH(col1, col2, ...)` で指定される列です。バケット化キーはデータのどの列が異なるバケットシーケンスにハッシュ化されるかを決定します。同じCG内のテーブルの場合、バケット化キーの名前は異なる場合があります。バケット化キーは作成文で異なる列になる可能性がありますが、`DISTRIBUTED BY HASH(col1, col2, ...)` 内の対応するデータ型の順序は完全に同じでなければなりません。
2. 同じCG内のテーブルは同じ数のパーティションコピーを持っている必要があります。そうでない場合、同じBE内のパーティションに対応するコピーが存在しない可能性があります。
3. 同じCG内のテーブルは、異なる数のパーティションと異なるパーティションキーを持つことができます。

テーブルの作成時に、テーブルのPROPERTIESで属性 `"colocate_with" = "group_name"` が指定されます。CGが存在しない場合、テーブルはCGの最初のテーブルであり、親テーブルと呼ばれます。親テーブルのデータ分布（分割バケットキーのタイプ、数、順序、コピー数、分割バケットの数）がCGSを決定します。CGが存在する場合、テーブルのデータ分布がCGSと一致しているかどうかを確認します。

同じCG内のテーブルのコピー配置は以下を満たす必要があります。

1. 全てのテーブルのバケットシーケンスとBEノードのマッピングは親テーブルと同じでなければなりません。
2. 親テーブル内の全てのパーティションのバケットシーケンスとBEノードのマッピングは最初のパーティションと同じでなければなりません。
3. 親テーブルの最初のパーティションのバケットシーケンスとBEノードのマッピングは、ネイティブのラウンドロビンアルゴリズムを使用して決定されます。

一貫したデータ分布とマッピングにより、同じ値を取るバケット化キーを持つデータ行が同一のBEに配置されます。したがって、バケット化キーを使用して列を結合する際には、ローカル結合のみが必要です。

## 使用法

### テーブルの作成

テーブルを作成する際に、PROPERTIESで属性 `"colocate_with" = "group_name"` を指定して、テーブルがコロケートジョインテーブルであり指定されたコロケートグループに属することを示すことができます。
> **注記**
>
> バージョン2.5.4以降、異なるデータベースのテーブルでコロケートジョインを行うことができます。テーブルを作成する際に同じ `colocate_with` プロパティを指定するだけです。

例:

~~~SQL
CREATE TABLE tbl (k1 int, v1 int sum)
DISTRIBUTED BY HASH(k1)
BUCKETS 8
PROPERTIES(
    "colocate_with" = "group1"
);
~~~

指定したグループが存在しない場合、StarRocksは自動的に現在のテーブルのみを含むグループを作成します。グループが存在する場合、StarRocksは現在のテーブルがコロケートグループスキーマを満たしているかどうかを確認します。満たしている場合、テーブルを作成し、グループに追加します。同時に、テーブルは既存のグループのデータ分布規則に基づいてパーティションとタブレットを作成します。

コロケートグループはデータベースに属します。コロケートグループの名前はデータベース内で一意です。内部ストレージでは、コロケートグループの完全な名前は `dbId_groupName` ですが、ユーザーは `groupName` のみが認識します。
> **注記**
>
> 異なるデータベースから関連付けられたテーブルでコロケートジョインを行うために同じコロケートグループを指定すると、このコロケートグループはそれぞれのデータベースに存在します。異なるデータベース内のコロケートグループを確認するには、`show proc "/colocation_group"` を実行してください。

### 削除

完全な削除とは、リサイクルビンからの削除です。通常、`DROP TABLE` コマンドでテーブルを削除すると、デフォルトで1日間リサイクルビンに残った後、削除されます。グループ内の最後のテーブルが完全に削除されると、グループも自動的に削除されます。

### グループ情報の表示

以下のコマンドを使用すると、クラスタ内で既に存在するグループ情報を表示できます。

~~~Plain Text
SHOW PROC '/colocation_group';

+-------------+--------------+--------------+------------+----------------+----------+----------+
| GroupId     | GroupName    | TableIds     | BucketsNum | ReplicationNum | DistCols | IsStable |
+-------------+--------------+--------------+------------+----------------+----------+----------+
| 10005.10008 | 10005_group1 | 10007, 10040 | 10         | 3              | int(11)  | true     |
+-------------+--------------+--------------+------------+----------------+----------+----------+
~~~

* **GroupId**: グループのクラスタ全体で一意の識別子で、前半部分がdb id、後半部分がグループidです。
* **GroupName**: グループの完全な名前。
* **TabletIds**: グループ内のテーブルのIDリスト。
* **BucketsNum**: バケット数。
* **ReplicationNum**: レプリカ数。
* **DistCols**: 分散列、つまりバケット化列のタイプ。
* **IsStable**: グループの安定性（安定性の定義については「コロケートレプリカのバランスと修復」のセクションを参照）。

以下のコマンドを使用すると、グループのデータ分布をさらに詳しく表示できます。

~~~Plain Text
SHOW PROC '/colocation_group/10005.10008';

+-------------+---------------------+
| BucketIndex | BackendIds          |
+-------------+---------------------+
| 0           | 10004, 10002, 10001 |
| 1           | 10003, 10002, 10004 |
| 2           | 10002, 10004, 10001 |
| 3           | 10003, 10002, 10004 |
| 4           | 10002, 10004, 10003 |
| 5           | 10003, 10002, 10001 |
| 6           | 10003, 10004, 10001 |
| 7           | 10003, 10004, 10002 |
+-------------+---------------------+
~~~

* **BucketIndex**: バケットのシーケンスの添え字。
* **BackendIds**: バケット化されたデータスライスが配置されているBEノードのID。

> 注記: 上記のコマンドはAMDIN権限が必要です。一般ユーザーはアクセスすることはできません。

### グループ属性の変更

テーブルのコロケートグループプロパティを変更することができます。例:

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "group2");
~~~

テーブルが以前にグループに割り当てられていない場合、コマンドはスキーマを確認し、テーブルをグループに追加します（グループが存在しない場合は最初に作成されます）。テーブルが以前に別のグループに割り当てられている場合、コマンドはテーブルを以前のグループから削除し、新しいグループに追加します（グループが存在しない場合は最初に作成されます）。

また、以下のコマンドを使用して、テーブルのコロケート属性を解除することもできます。

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "");
~~~

### その他の関連操作

コロケート属性を持つテーブルにパーティションを追加したり、コピーの数を変更しようとする場合、StarRocksはその操作がコロケートグループスキーマを破る可能性があるかどうかをチェックし、それに違反する場合は拒否します。

## コロケートレプリカのバランスと修復
コロケーションテーブルのレプリカの分布は、グループスキーマで指定された分布ルールに従う必要があります。そのため、通常のシャーディングとは異なり、レプリカの修復やバランスに関して異なる方法で処理されます。

グループ自体には `stable` プロパティがあります。`stable` が `true` の場合、グループ内のテーブルスライスに変更が加えられておらず、コロケーション機能が正常に動作していることを意味します。`stable` が `false` の場合、現在のグループ内の一部のテーブルスライスが修復または移行されており、影響を受けるテーブルのコロケーション結合は通常の結合に劣化します。

### レプリカの修復

レプリカは指定された BE ノードにのみ保存できます。StarRocks は、利用できない BE（例: ダウン、廃止）の代わりとして負荷が最も少ない BE を探します。代替後、古い BE 上のすべてのバケットデータスライスが修復されます。移行中は、グループは **不安定** としてマークされます。

### レプリカのバランス

StarRocks は、コロケーションテーブルスライスをすべての BE ノードに均等に分散しようとします。通常のテーブルのバランスはレプリカレベルで行われます。すなわち、各レプリカは個別に負荷の少ない BE ノードを探します。コロケーションテーブルのバランスはバケットレベルで行われます。つまり、1つのバケット内のすべてのレプリカが一緒に移行されます。実際のレプリカのサイズではなく、レプリカの数だけを考慮して、`BucketsSequnce` をすべての BE ノードに均等に分散する簡単なバランスアルゴリズムが使用されます。具体的なアルゴリズムについては、`ColocateTableBalancer.java` 内のコードコメントで確認できます。

> 注意1: 現在のコロケーションレプリカのバランスと修復のアルゴリズムは、異種の展開を持つ StarRocks クラスターにはうまく機能しない可能性があります。異種の展開とは、BE ノードのディスク容量、ディスク数、ディスクタイプ（SSD および HDD）が一貫していない場合を指します。異種の展開の場合、小容量の BE ノードが大容量の BE ノードと同じ数のレプリカを格納することがあるかもしれません。

> 注意2: グループが不安定な状態にある場合、そのテーブルの結合は通常の結合に劣化し、クエリのパフォーマンスが著しく低下する可能性があります。システムが自動的にバランスを取らないようにしたい場合は、FE 設定の `disable_colocate_balance` を設定して自動バランスを無効にし、適切なタイミングで再度有効にしてください（詳細は「高度な操作」（#高度な操作）のセクションを参照）

## クエリ

コロケーションテーブルは通常のテーブルと同じようにクエリされます。コロケーションテーブルがあるグループが不安定な状態である場合、自動的に通常の結合に劣化します。以下の例に示すように、これは次のように図示されます。

テーブル1:

~~~SQL
CREATE TABLE `tbl1` (
    `k1` date NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` int(11) SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
PARTITION BY RANGE(`k1`)
(
    PARTITION p1 VALUES LESS THAN ('2019-05-31'),
    PARTITION p2 VALUES LESS THAN ('2019-06-30')
)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

テーブル2:

~~~SQL
CREATE TABLE `tbl2` (
    `k1` datetime NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` double SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

ビュークエリプラン:

~~~Plain Text
DESC SELECT * FROM tbl1 INNER JOIN tbl2 ON (tbl1.k2 = tbl2.k2);

+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN                           |
|   |  hash predicates:                              |
|   |  colocate: true                                |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----1:OlapScanNode                              |
|   |       TABLE: tbl2                              |
|   |       PREAGGREGATION: OFF. Reason: null        |
|   |       partitions=0/1                           |
|   |       rollup: null                             |
|   |       buckets=0/0                              |
|   |       cardinality=-1                           |
|   |       avgRowSize=0.0                           |
|   |       numNodes=0                               |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
+----------------------------------------------------+
~~~

コロケーション結合が有効になると、HASH JOIN ノードに `colocate: true` が表示されます。

有効にならない場合、クエリプランは次のようになります:

~~~Plain Text
+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN (BROADCAST)               |
|   |  hash predicates:                              |
|   |  colocate: false, reason: group is not stable  |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----3:EXCHANGE                                  |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
|                                                    |
| PLAN FRAGMENT 1                                    |
|  OUTPUT EXPRS:                                     |
|   PARTITION: RANDOM                                |
|                                                    |
|   STREAM DATA SINK                                 |
|     EXCHANGE ID: 03                                |
|     UNPARTITIONED                                  |
|                                                    |
|   1:OlapScanNode                                   |
|      TABLE: tbl2                                   |
|      PREAGGREGATION: OFF. Reason: null             |
|      partitions=0/1                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 1                                  |
+----------------------------------------------------+
~~~

HASH JOIN ノードに対応する理由が表示されます: `colocate: false, reason: group is not stable`。同時に EXCHANGE ノードが生成されます。

## 高度な操作

### FE 設定項目

* **disable_colocate_relocate**

StarRocks のコロケーションレプリカ修復を無効にするかどうか。デフォルトは false で、つまり有効になっています。このパラメータは通常のテーブルではなく、コロケーションテーブルのレプリカ修復にのみ影響します。

* **disable_colocate_balance**

StarRocks のコロケーションレプリカバランスを無効にするかどうか。デフォルトは false で、つまり有効になっています。このパラメータは通常のテーブルではなく、コロケーションテーブルのレプリカバランスにのみ影響します。

* **disable_colocate_join**

    この変数を変更してセッション単位でコロケーション結合を無効にすることができます。

* **disable_colocate_join**

    この変数を変更してコロケーション結合機能を無効にすることができます。

### HTTP Restful API

StarRocks には、コロケーショングループの表示および変更に関連するいくつかの HTTP Restful API が提供されています。

この API は FE 上で実装され、ADMIN 権限を持つユーザーが `fe_host:fe_http_port` を使用してアクセスできます。

1. クラスターのすべてのコロケーション情報を表示

    ~~~bash
    curl --location-trusted -u<username>:<password> 'http://<fe_host>:<fe_http_port>/api/colocate'  
    ~~~

    ~~~JSON
    // 内部のコロケーション情報を JSON 形式で返します。
    {
        "colocate_meta": {
            "groupName2Id": {
                "g1": {
                    "dbId": 10005,
                    "grpId": 10008
                }
            },
            "group2Tables": {},
            "table2Group": {
                "10007": {
                    "dbId": 10005,
```json
      "grpId": 10008
    },
    "10040": {
      "dbId": 10005,
      "grpId": 10008
    }
  },
  "group2Schema": {
    "10005.10008": {
      "groupId": {
        "dbId": 10005,
        "grpId": 10008
      },
      "distributionColTypes": [{
        "type": "INT",
        "len": -1,
        "isAssignedStrLenInColDefinition": false,
        "precision": 0,
        "scale": 0
      }],
      "bucketsNum": 10,
      "replicationNum": 2
    }
  },
  "group2BackendsPerBucketSeq": {
    "10005.10008": [
      [10004, 10002],
      [10003, 10002],
      [10002, 10004],
      [10003, 10002],
      [10002, 10004],
      [10003, 10002],
      [10003, 10004],
      [10003, 10004],
      [10003, 10004],
      [10002, 10004]
    ]
  },
  "unstableGroups": []
},
"status": "OK"
```
2. グループを安定または不安定にする

```bash
# 安定にマーク
curl -XPOST --location-trusted -u<ユーザー名>:<パスワード> 'http://<fe_host>:<fe_http_port>/api/colocate/group_stable?db_id=<dbId>&group_id=<grpId>'
# 不安定にマーク
curl -XPOST --location-trusted -u<ユーザー名>:<パスワード> 'http://<fe_host>:<fe_http_port>/api/colocate/group_unstable?db_id=<dbId>&group_id=<grpId>'
```

200が返された場合、グループは正常に安定または不安定にマークされています。

3. グループのデータ分布を設定する

このインタフェースを使用して、グループのデータ分布を強制することができます。

`POST /api/colocate/bucketseq?db_id=10005&group_id=10008`

`Body:`

`[[10004,10002],[10003,10002],[10002,10004],[10003,10002],[10002,10004],[10003,10002],[10003,10004],[10003,10004],[10003,10004],[10002,10004]]`

`返却: 200`

ここで`Body`は、ネストされた配列とバケット化スライスが配置されているBEのIDで表される`BucketsSequence`です。

> このコマンドを使用するには、FEの設定`disable_colocate_relocate`と`disable_colocate_balance`をtrueに設定する必要がある場合があります。つまり、システムに自動的な共有レプリカ修復とバランシングを行わせないようにします。それ以外の場合、変更後にシステムによって自動的にリセットされることがあります。
```