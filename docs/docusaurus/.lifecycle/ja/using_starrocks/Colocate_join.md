---
displayed_sidebar: "Japanese"
---

# コロケートジョイン

シャッフルジョインおよびブロードキャストジョインでは、ジョイン条件が満たされると、2つの結合テーブルのデータ行が単一のノードにマージされ、ジョインを完了します。これら2つの結合方法のいずれも、ノード間のデータネットワーク送信によって生じる待ち時間やオーバーヘッドを避けることはできません。

中心となる考えは、同じコロケーショングループ内のテーブルについて、バケットキー、コピー数、およびコピー配置を一貫して維持することです。ジョイン列がバケットキーである場合、計算ノードは他のノードからデータを取得することなく、ローカルジョインのみを行う必要があります。コロケートジョインは、等価ジョインをサポートしています。

本書では、コロケートジョインの原則、実装、使用方法、および考慮事項について紹介します。

## 用語

* **コロケーショングループ（CG）**：CGには1つ以上のテーブルが含まれます。CG内のテーブルは同じバケットおよびレプリカ配置を持ち、コロケーショングループスキーマを使用して記述されます。
* **コロケーショングループスキーマ（CGS）**：CGSにはCGのバケットキー、バケット数、およびレプリカ数が含まれます。

## 原則

コロケートジョインは、同じCGSを持つテーブルのセットを使用してCGを形成し、これらのテーブルの対応するバケットコピーが同じ一連のBEノードに配置されるようにします。CG内のテーブルがバケット化された列で結合操作を行う場合、ローカルデータを直接結合することで、ノード間でのデータ転送にかかる時間を節約できます。

バケットシークエンスは `hash(key) mod buckets` で得られます。テーブルが8つのバケットを持つ場合、\[0, 1, 2, 3, 4, 5, 6, 7\] の8つのバケットがあり、それぞれのバケットには1つ以上のサブテーブルが存在し、サブテーブルの数はパーティションの数に依存します。複数パーティションのテーブルの場合、複数のタブレットが存在します。

同じCG内のテーブルは以下に準拠する必要があります。

1. 同じCG内のテーブルは、データスライスが1つずつ分布および制御されるように、同じバケットキー（タイプ、数、順序）および同じバケット数を持っている必要があります。バケットキーは、テーブル作成文の `DISTRIBUTED BY HASH(col1, col2, ...)` で指定される列です。バケットキーは、異なるテーブル内でバラバラになる可能性がありますが、`DISTRIBUTED BY HASH(col1, col2, ...)` での対応するデータ型の順序はまったく同じでなければなりません。
2. 同じCG内のテーブルは、同じ数のパーティションコピーを持っている必要があります。そうでない場合、同じBE内のパーティションに対応するコピーが存在しない可能性があります。
3. 同じCG内のテーブルは、異なる数のパーティションおよび異なるパーティションキーを持つ可能性があります。

テーブルを作成する際には、テーブルのPROPERTIESで属性 `"colocate_with" = "group_name"` を指定してCGを特定します。CGが存在しない場合、テーブルはCGの最初のテーブルであり、親テーブルと呼ばれます。親テーブルのデータ分布（分割バケットキーのタイプ、数、順序、コピー数および分割バケット数）がCGSを決定します。CGが存在する場合、テーブルのデータ分布がCGSと一致しているかどうかをチェックします。

同じCG内のテーブルのコピー配置は以下を満たします。

1. すべてのテーブルのバケットシークエンスとBEノードのマッピングは、親テーブルのものと同じでなければなりません。
2. 親テーブル内のすべてのパーティションのバケットシークエンスとBEノードのマッピングは、最初のパーティションのものと同じでなければなりません。
3. 親テーブルの最初のパーティションのバケットシークエンスとBEノードのマッピングは、ネイティブのRound Robinアルゴリズムを使用して決定されます。

一貫したデータ分布とマッピングにより、バケットキーによる結合列の使用時には、ローカルジョインのみが必要となります。

## 使用方法

### テーブル作成

テーブルを作成する際には、PROPERTIESで属性 `"colocate_with" = "group_name"` を指定して、テーブルがコロケートジョインテーブルであり、指定されたコロケーショングループに属していることを示します。
> **注記**
>
> バージョン2.5.4から、異なるデータベースのテーブルに対してもコロケートジョインを行うことができます。テーブルを作成する際に同じ `colocate_with` プロパティを指定するだけです。

例：

~~~SQL
CREATE TABLE tbl (k1 int, v1 int sum)
DISTRIBUTED BY HASH(k1)
BUCKETS 8
PROPERTIES(
    "colocate_with" = "group1"
);
~~~

指定したグループが存在しない場合、StarRocksは自動的に現在のテーブルのみを含むグループを作成します。グループが存在する場合、StarRocksは現在のテーブルがコロケーショングループスキーマを満たしているかどうかをチェックします。満たしている場合、テーブルを作成し、グループに追加します。同時に、既存のグループのデータ分布ルールに基づいて、テーブルにパーティションおよびタブレットを作成します。

コロケーショングループはデータベースに属します。コロケーショングループの名前はデータベース内で一意です。内部ストレージでは、コロケーショングループの完全名は `dbId_groupName` ですが、実際には `groupName` のみを認識します。
> **注記**
>
> 異なるデータベースからテーブルをコロケートジョインするために同じコロケーショングループを指定した場合、このコロケーショングループはそれぞれのデータベースに存在します。異なるデータベース内のコロケーショングループを確認するには、`show proc "/colocation_group"` を実行して確認できます。

### 削除

完全な削除とは、リサイクルビンからの削除です。通常、`DROP TABLE` コマンドでテーブルを削除すると、デフォルトで1日間リサイクルビンに保管されます。グループ内の最後のテーブルが完全に削除されると、グループも自動的に削除されます。

### グループ情報の表示

以下のコマンドを使用して、クラスタに既に存在するグループの情報を表示できます。

~~~Plain Text
SHOW PROC '/colocation_group';

+-------------+--------------+--------------+------------+----------------+----------+----------+
| GroupId     | GroupName    | TableIds     | BucketsNum | ReplicationNum | DistCols | IsStable |
+-------------+--------------+--------------+------------+----------------+----------+----------+
| 10005.10008 | 10005_group1 | 10007, 10040 | 10         | 3              | int(11)  | true     |
+-------------+--------------+--------------+------------+----------------+----------+----------+
~~~

* **GroupId**：グループのクラスタ全体で一意の識別子であり、前半部分がdb ID、後半部分がグループIDです。
* **GroupName**：グループの完全名。
* **TabletIds**：グループ内のテーブルのIDリスト。
* **BucketsNum**：バケット数。
* **ReplicationNum**：レプリカ数。
* **DistCols**：ディストリビューション列、つまりバケット化された列のタイプ。
* **IsStable**：グループの安定性（安定性の定義については、コロケーションレプリカのバランシングとリペアのセクションを参照）。

次のコマンドで、グループのデータ分布をさらに確認できます。

~~~Plain Text
SHOW PROC '/colocation_group/10005.10008';

+-------------+---------------------+
| BucketIndex | BackendIds          |
+-------------+---------------------+
| 0           | 10004, 10002, 10001 |
| 1           | 10003, 10002, 10004 |
| 2           | 10002, 10004, 10001 |
| 3           | 10003, 10002, 10004 |
| 4           | 10002, 10004, 10003 |
| 5           | 10003, 10002, 10001 |
| 6           | 10003, 10004, 10001 |
| 7           | 10003, 10004, 10002 |
+-------------+---------------------+
~~~

* **BucketIndex**：バケットの連番。
* **BackendIds**：バケット化されたデータスライスが配置されているBEノードのID。

> 注：上記のコマンドを実行するには、AMDIN権限が必要です。通常のユーザーはアクセスできません。

### グループプロパティの変更

テーブルのコロケートグループプロパティを変更することができます。例：

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "group2");
~~~

テーブルが以前にグループに割り当てられていない場合、コマンドはスキーマをチェックし、テーブルをグループに追加します（グループがまだ存在しない場合は、まずグループを作成します）。テーブルが以前に別のグループに割り当てられていた場合、コマンドはテーブルを元のグループから削除し、新しいグループに追加します（グループがまだ存在しない場合は、まずグループを作成します）。

以下のコマンドを使用して、テーブルのコロケートプロパティを削除することもできます。

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "");
~~~

### その他の関連操作

コロケート属性を持つテーブルにパーティションを追加したり、コピー数を変更したりする際には、操作がコロケーショングループスキーマに違反するかどうかをStarRocksがチェックし、違反する場合は操作を拒否します。

## コロケートレプリカのバランシングとリペア
```
コロケーションテーブルのレプリカ分散は、通常のシャーディングとは異なるため、グループスキーマで指定された分散ルールに従う必要があります。レプリカの修復およびバランシングについても同様です。

グループ自体には「stable」というプロパティがあります。 「stable」が「true」の場合、グループ内のテーブルスライスに変更が加えられず、コロケーション機能が正常に動作していることを意味します。「stable」が「false」の場合、現在のグループ内の一部のテーブルスライスが修復または移行されていることを意味し、影響を受けるテーブルのコロケート結合が通常の結合に低下します。

### レプリカの修復

レプリカは指定されたBEノードにのみ格納できます。StarRocksは、利用できないBE（たとえばダウン、運用停止など）を置き換えるための最も負荷の少ないBEを探します。置換後、古いBE上のすべてのバケットデータスライスが修復されます。移行中は、グループが**不安定**としてマークされます。

### レプリカのバランシング

StarRocksは、コロケーションテーブルスライスをすべてのBEノードに均等に分散しようとします。通常のテーブルのバランシングはレプリカレベルであり、つまり、各レプリカは個別に負荷の少ないBEノードを見つけようとします。コロケーションテーブルのバランシングはバケットレベルであり、つまり、すべてのバケット内のレプリカが一緒に移行されます。実際のレプリカのサイズではなく、レプリカの数のみを考慮した単純なバランシングアルゴリズムを使用します。正確なアルゴリズムについては、`ColocateTableBalancer.java`のコードコメントで見つけることができます。

> 注意1: 現在のコロケーションレプリカバランシングおよび修復アルゴリズムは、異種展開を持つStarRocksクラスターでうまく機能しない場合があります。異種展開とは、BEノードのディスク容量、ディスク数、およびディスクタイプ（SSDおよびHDD）が一貫していない場合を指します。異種展開の場合、小容量のBEノードが大容量のBEノードと同じ数のレプリカを保存することがあるかもしれません。

> 注意2: グループが不安定な状態にある場合、そのテーブルの結合は通常の結合に低下し、クエリパフォーマンスが著しく低下する可能性があります。システムが自動的にバランスを取らないようにする場合は、適切なタイミングでFE設定`disable_colocate_balance`を設定して自動バランシングを無効にし、適切なタイミングで再度有効にしてください（詳細は詳細な手順（＃詳細な操作）を参照）。

## クエリ

コロケーションテーブルは通常のテーブルと同じようにクエリされます。コロケーションテーブルが配置されているグループが不安定な状態である場合、自動的に通常の結合に低下します。次の例に示すように。

テーブル1：

~~~SQL
CREATE TABLE `tbl1` (
    `k1` date NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` int(11) SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
PARTITION BY RANGE(`k1`)
(
    PARTITION p1 VALUES LESS THAN ('2019-05-31'),
    PARTITION p2 VALUES LESS THAN ('2019-06-30')
)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

テーブル2：

~~~SQL
CREATE TABLE `tbl2` (
    `k1` datetime NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` double SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

ビュークエリプラン：

~~~プレーンテキスト
DESC SELECT * FROM tbl1 INNER JOIN tbl2 ON (tbl1.k2 = tbl2.k2);

+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN                           |
|   |  hash predicates:                              |
|   |  colocate: true                                |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----1:OlapScanNode                              |
|   |       TABLE: tbl2                              |
|   |       PREAGGREGATION: OFF. Reason: null        |
|   |       partitions=0/1                           |
|   |       rollup: null                             |
|   |       buckets=0/0                              |
|   |       cardinality=-1                           |
|   |       avgRowSize=0.0                           |
|   |       numNodes=0                               |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
+----------------------------------------------------+
~~~

コロケート結合が有効になると、HASH JOINノードは`colocate: true`と表示されます。

有効にならない場合、クエリプランは次のようになります：

~~~プレーンテキスト
+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN (BROADCAST)               |
|   |  hash predicates:                              |
|   |  colocate: false, reason: group is not stable  |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----3:EXCHANGE                                  |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
|                                                    |
| PLAN FRAGMENT 1                                    |
|  OUTPUT EXPRS:                                     |
|   PARTITION: RANDOM                                |
|                                                    |
|   STREAM DATA SINK                                 |
|     EXCHANGE ID: 03                                |
|     UNPARTITIONED                                  |
|                                                    |
|   1:OlapScanNode                                   |
|      TABLE: tbl2                                   |
|      PREAGGREGATION: OFF. Reason: null             |
|      partitions=0/1                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 1                                  |
+----------------------------------------------------+
~~~

HASH JOINノードには、対応する理由が表示されます：`colocate: false, reason: group is not stable`。同時にEXCHANGEノードが生成されます。

## 高度な操作

### FE構成項目

* **disable_colocate_relocate**

StarRocksのコロケーションレプリカ修復を自動で無効にするかどうか。デフォルトはfalseで、有効になっています。このパラメータは通常のテーブルではなく、コロケーションテーブルのレプリカ修復にのみ影響します。

* **disable_colocate_balance**

StarRocksのコロケーションレプリカバランシングを自動で無効にするかどうか。デフォルトはfalseで、有効になっています。このパラメータは通常のテーブルではなく、コロケーションテーブルのレプリカバランシングにのみ影響します。

* **disable_colocate_join**

    この変数を変更することでセッション単位でコロケート結合を無効にすることができます。

* **disable_colocate_join**

    この変数を変更することでコロケート結合機能を無効にすることができます。

### HTTP Restful API

StarRocksは、コロケート結合に関連するいくつかのHTTP Restful APIを提供しており、Colocate Groupsの表示および変更が可能です。

このAPIはFEで実装されており、管理権限を持つユーザーが`fe_host:fe_http_port`を使用してアクセスできます。

1. クラスターのすべてのコロケーション情報を表示する

    ~~~bash
    curl --location-trusted -u<username>:<password> 'http://<fe_host>:<fe_http_port>/api/colocate'  
    ~~~

    ~~~JSON
    // 内部のJSON形式でコロケーション情報を返します。
    {
        "colocate_meta": {
            "groupName2Id": {
                "g1": {
                    "dbId": 10005,
                    "grpId": 10008
                }
            },
            "group2Tables": {},
            "table2Group": {
                "10007": {
                    "dbId": 10005
```
```json
                    "grpId": 10008
                },
                "10040": {
                    "dbId": 10005,
                    "grpId": 10008
                }
            },
            "group2Schema": {
                "10005.10008": {
                    "groupId": {
                        "dbId": 10005,
                        "grpId": 10008
                    },
                    "distributionColTypes": [{
                        "type": "INT",
                        "len": -1,
                        "isAssignedStrLenInColDefinition": false,
                        "precision": 0,
                        "scale": 0
                    }],
                    "bucketsNum": 10,
                    "replicationNum": 2
                }
            },
            "group2BackendsPerBucketSeq": {
                "10005.10008": [
                    [10004, 10002],
                    [10003, 10002],
                    [10002, 10004],
                    [10003, 10002],
                    [10002, 10004],
                    [10003, 10002],
                    [10003, 10004],
                    [10003, 10004],
                    [10003, 10004],
                    [10002, 10004]
                ]
            },
            "unstableGroups": []
        },
        "status": "OK"
    }
    ~~~

2. グループを安定または不安定にマークする

    ~~~bash
    # 安定としてマーク
    curl -XPOST --location-trusted -u<username>:<password> ​'http://<fe_host>:<fe_http_port>/api/colocate/group_stable?db_id=<dbId>&group_id=<grpId>​'
    # 不安定としてマーク
    curl -XPOST --location-trusted -u<username>:<password> ​'http://<fe_host>:<fe_http_port>/api/colocate/group_unstable?db_id=<dbId>&group_id=<grpId>​'
    ~~~

    返された結果が `200` の場合、グループは正常に安定または不安定にマークされます。

3. グループのデータ分布を設定します

    このインターフェースを使用すると、グループのデータ分布を強制できます。

    `POST /api/colocate/bucketseq?db_id=10005&group_id= 10008`

    `本文:`

    `[[10004,10002],[10003,10002],[10002,10004],[10003,10002],[10002,10004],[10003,10002],[10003,10004],[10003,10004],[10003,10004],[10002,10004]]`

    `返信: 200`

    `Body` は、バケットシーケンスを入れ子にした配列およびバケットスライスが配置されているBEのIDを表します。

    > このコマンドを使用するには、FE 設定 `disable_colocate_relocate` および `disable_colocate_balance` を true に設定する必要があります。これにより、システムが自動的に Colocation レプリカの修復やバランス調整を実行しないようにします。そうしないと、変更後にシステムによって自動的にリセットされることがあります。 
```