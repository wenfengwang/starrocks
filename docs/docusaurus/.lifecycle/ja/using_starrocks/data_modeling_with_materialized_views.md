---
displayed_sidebar: "Japanese"
---

# マテリアライズドビューを使用したデータモデリング

このトピックでは、StarRocksの非同期マテリアライズドビューを活用してデータモデリングを行う方法について説明します。これにより、データウェアハウスのETLパイプラインを大幅に簡素化し、データの品質とクエリのパフォーマンスを大幅に向上させることができます。

## 概要

データモデリングは、データのクリーニング、階層化、集約、関連付けを合理的な手法で行うプロセスです。これにより、直接分析するには粗すぎる、複雑すぎる、またはコストがかかりすぎる生データの理解可能な表現を作成し、データに対する具体的な洞察を提供することができます。

しかし、現実のデータモデリングにおける共通の課題は、モデリングプロセスがビジネスの発展のペースに追いつくことが難しく、データモデリングの投資対効果を測定することが困難であるということです。モデリング手法自体はシンプルですが、ビジネスの専門家はデータの組織とガバナンスに関する堅固な背景を持つ必要があり、これは複雑なプロセスです。ビジネスの初期段階では、意思決定者はデータモデリングに十分なリソースを割くことはほとんどありませんし、データモデリングがもたらす価値を見ることは困難です。さらに、ビジネスモデルは急速に変化する可能性があり、モデリング手法自体も反復と進化が必要です。したがって、多くのデータアナリストはモデリングを避け、生データを直接使用しようとする傾向があり、それによって必然的にデータ品質とクエリのパフォーマンスの問題が生じます。モデリングの必要性が生じた場合、既にデータモデルに合わせて確立されているデータ分析パターンを再構築することが困難になります。

データモデリングにマテリアライズドビューを使用することで、これらの問題を効果的に解決することができます。StarRocksの非同期マテリアライズドビューは、次のような機能を持っています。

- **データウェアハウスのアーキテクチャを簡素化する**: StarRocksがワンストップのデータガバナンス体験を提供できるため、他のデータ処理システムを維持する必要がありません。これにより、これらのシステムに費やされる人的およびシステムリソースを節約することができます。
- **データモデリングの体験を容易にする**: 基本的なSQLの知識しか持たないデータアナリストでも、StarRocksを使用してデータモデリングを行うことができます。データモデリングはもはや経験豊富なデータエンジニアの専売特許ではありません。
- **メンテナンスの複雑さを削減する**: StarRocksの非同期マテリアライズドビューは、データレイヤ間の依存関係とリレーションシップを自動的に管理するため、このタスクを処理するためにデータプラットフォーム全体を必要としません。

![Modeling-1](../assets/Modeling-1.png)

実際のシチュエーションでは、以下のようにStarRocksのビュー（論理ビュー）と非同期マテリアライズドビューの使用を組み合わせてデータモデリングを行うことができます。

1. ビューを使用してリアルタイムデータとディメンションデータを関連付け、非同期マテリアライズドビューを使用してデータレイクからの履歴データとディメンションデータを関連付けます。必要なデータクリーニングとセマンティックマッピングを行い、ビジネスシナリオで必要な詳細データを反映させたIntermediate Layerのデータを取得します。
2. アプリケーションレイヤでは、異なるビジネスシナリオに合わせてデータの結合、集計、統合、ウィンドウ計算を行います。これにより、リアルタイムパイプライン用のビューとほぼリアルタイムのパイプライン用の非同期マテリアライズドビューが生成されます。
3. アプリケーション側では、タイムリネスとパフォーマンスの要件に基づいて適切な分析データストア（ADS）を選択してクエリ分析を行います。これらのADSは、リアルタイムダッシュボード、ほぼリアルタイムのBI、アドホッククエリ、スケジュールされたレポートの提供に使用できます。

このプロセスでは、StarRocksのいくつかの組み込み機能を活用します。これらの機能については、次のセクションで詳しく説明します。

## 非同期マテリアライズドビューの機能

StarRocksの非同期マテリアライズドビューには、データモデリングに役立つ以下の機能が備わっています。

- **自動リフレッシュ**：データがベーステーブルにロードされると、マテリアライズドビューは自動的にリフレッシュされます。スケジューリングタスクを外部で維持する必要はありません。
- **パーティション別リフレッシュ**：時間系列を特徴とするテーブル上に構築されたマテリアライズドビューのパーティション別リフレッシュにより、ほぼリアルタイムの計算を実現することができます。
- **ビューとの連携**：マテリアライズドビューと論理ビューを組み合わせることで、マルチレベルのモデリングを実現し、Intermediate Layerの再利用とデータモデルの簡素化を可能にします。
- **スキーマの変更**：複雑なデータパイプラインを変更する必要なく、単純なSQL文を使用して計算結果を変更することができます。

これらの機能を使用して、さまざまなビジネスニーズとシナリオに対応する包括的で適応性のあるデータモデルを設計することができます。

### 自動リフレッシュ

非同期マテリアライズドビューを作成する際に、REFRESH句を使用してリフレッシュ戦略を指定することができます。現在、StarRocksは非同期マテリアライズドビューの以下のリフレッシュ戦略をサポートしています。

- **自動リフレッシュ** (`REFRESH ASYNC`): ベーステーブルのデータが変更されるたびにリフレッシュタスクがトリガーされます。データの依存関係は、マテリアライズドビューによって自動的に管理されます。
- **スケジュールされたリフレッシュ** (`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`): 定期的な間隔でリフレッシュタスクがトリガーされます。例えば、毎分、毎日、または毎月です。ベーステーブルにデータの変更がない場合、リフレッシュタスクはトリガーされません。
- **マニュアルリフレッシュ** (`REFRESH MANUAL`): REFRESH MATERIALIZED VIEWを手動で実行することでのみリフレッシュタスクがトリガーされます。このリフレッシュ戦略は、外部のスケジューリングフレームワークを維持してリフレッシュタスクをトリガーする場合に使用することができます。

構文:

```SQL
CREATE MATERIALIZED VIEW <名前>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### パーティション別リフレッシュ

非同期マテリアライズドビューを作成する際に、PARTITION BY句を使用してベーステーブルのパーティションをマテリアライズドビューのパーティションに関連付けることで、パーティションレベルのリフレッシュを実現することができます。

- `PARTITION BY <column>`: ベーステーブルとマテリアライズドビューで同じパーティションカラムを参照することができます。その結果、ベーステーブルとマテリアライズドビューは同じ粒度でパーティション分割されます。
- `PARTITION BY date_trunc(<column>)`: date_trunc関数を使用して、時間単位を切り捨てることで、マテリアライズドビューのパーティション戦略（粒度レベル）を異なるものにすることができます。
- `PARTITION BY { time_slice | date_slice }(<column>)`: date_truncよりも柔軟な時間の粒度調整が可能なtime_sliceとdate_sliceを使用することで、時間に基づいたより細かい制御でパーティショニングを行うことができます。

構文:

```SQL
CREATE MATERIALIZED VIEW <名前>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### ビューとの連携

- マテリアライズドビューはビューをベースに作成することができます。この場合、ビューが参照するベーステーブルがデータ変更を受けると、マテリアライズドビューが自動的にリフレッシュされます。
- 他のマテリアライズドビューをベースにしてマテリアライズドビューを作成することもできます。これにより、マルチレベルのカスケーディングリフレッシュメカニズムを実現することができます。
- マテリアライズドビューをベースにビューを作成することもできます。これは通常のテーブルと同等のものです。

### スキーマの変更

- ALTER MATERIALIZED VIEW SWAPステートメントを使用して、2つの非同期マテリアライズドビュー間でアトミックな交換を行うことができます。これにより、列の追加や列の型の変更などを行った新しいマテリアライズドビューを作成し、古いビューと置換することができます。
- ALTER VIEWステートメントを使用して、ビューの定義を直接変更することができます。
- StarRocksの通常のテーブルは、SWAPまたはALTER操作を使用して変更することができます。
- さらに、ベーステーブル（マテリアライズドビュー、ビュー、または通常のテーブルである可能性があります）に変更がある場合、それに応じて対応するマテリアライズドビューにも変更が発生します。

## 階層化されたモデリング

実際のビジネスシナリオでは、リアルタイムの詳細データ、ディメンションデータ、データレイクからの履歴データなど、さまざまな形式のデータソースがあります。一方、ビジネスの要件では、リアルタイムダッシュボード、ほぼリアルタイムのBIクエリ、アドホッククエリ、スケジュールされたレポートなど、さまざまな分析方法が必要です。異なるシナリオにはさまざまな要求があります-柔軟性が必要な場合もあれば、パフォーマンスが優先される場合もあり、コスト効果が重視される場合もあります。

明らかに、単一の解決策ではこれらの多様な要求に十分に対応することはできません。StarRocksは、ビューとマテリアライズドビューの使用を組み合わせることで、これらのニーズに効果的に対応することができます。ビューは物理データを保持しないため、ビューがクエリされるたびにクエリが解析され、ビューの定義に従って実行されます。これに対して、計算済み結果を保持するマテリアライズドビューは、繰り返し実行のオーバーヘッドを防ぐことができます。ビューはビジネスのセマンティクスを表現し、SQLの複雑さを簡素化するのに適していますが、クエリの実行コストを削減することはできません。逆に、マテリアライズドビューは、事前計算によるクエリパフォーマンスの最適化を行い、ETLパイプラインの効率化に適しています。

以下は、ビューとマテリアライズドビューの違いの要約です：

|                                      | **ビュー**                                                     | **マテリアライズドビュー**                                        |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **使用例**                        | ビジネスモデリング、データガバナンス                           | データモデリング、透明な高速化、データレイクの統合 |
| **ストレージコスト**                     | ストレージコストなし                                              | 事前計算結果の保存によって発生するストレージコスト        |
| **更新コスト**                      | 更新コストなし                                               | ベーステーブルのデータが更新された場合に発生するリフレッシュコスト           |
| **パフォーマンスの利点**             | パフォーマンスの利点なし                                       | 事前計算結果の再利用によるクエリの高速化 |
| **データのリアルタイム属性** | ビューはリアルタイムでクエリが実行されるため、最新のデータが返されます。 | データは事前計算された結果のため、最新であるとは限りません。 |
| **依存関係**                       | ビューはベーステーブルの名前を参照しているため、ベーステーブルの名前が変更されるとビューが無効になります。 | ベーステーブルの名前の変更は、ベーステーブルをIDで参照しているマテリアライズドビューの可用性に影響を与えません。 |
| **作成の構文**              | CREATE VIEW                                                  | CREATE MATERIALIZED VIEW                                     |
| **修正構文**          | ALTER VIEW                                                   | ALTER MATERIALIZED VIEW                                      |

ビュー、マテリアライズド・ビュー、および基本テーブルを修正するために、次のステートメントを使用できます。

```SQL
-- テーブルを修正する。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 2つのテーブルを入れ替える。
ALTER TABLE <table1> SWAP WITH <table2>;

-- ビューの定義を修正する。
ALTER VIEW <view_name> AS <query>;

-- 2つのマテリアライズド・ビューを入れ替える
-- （データに影響を与えずに、2つのマテリアライズド・ビューの名前を入れ替える）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- マテリアライズド・ビューを再アクティブにする。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

スキーマの変更は次の原則に従います。

- テーブルの名前変更およびスワップ操作は、依存するマテリアライズド・ビューを非アクティブに設定します。スキーマの変更操作では、依存するマテリアライズド・ビューは、マテリアライズド・ビューが参照している基本テーブルの列に対してスキーマの変更操作が行われた場合にのみ、非アクティブに設定されます。
- ビューの定義を変更すると、依存するマテリアライズド・ビューが非アクティブになります。
- マテリアライズド・ビューがスワップされると、それに基づいて構築されたネストされたマテリアライズド・ビューも非アクティブになります。
- 非アクティブ状態は、マテリアライズド・ビューの依存関係がなくなるまで上方に連鎖します。
- 非アクティブなマテリアライズド・ビューはリフレッシュすることも自動クエリの書き換えに使用することもできません。
- 非アクティブなマテリアライズド・ビューは直接クエリを実行することはできますが、再びアクティブになるまでデータの整合性は保証されません。

非アクティブなマテリアライズド・ビューのデータ整合性が保証されない一方で、以下の方法を使用してそれらの機能を復元できます。

- **手動修復**: ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE を実行して、非アクティブなマテリアライズド・ビューを手動で修復することができます。このステートメントにより、元のSQL定義に基づいてマテリアライズド・ビューが再作成されます。ただし、SQL定義は基礎となるスキーマの変更後も有効でなければならないことに注意してください。さもなければ、操作は失敗します。
- **自動修復**: StarRocks は非アクティブなマテリアライズド・ビューを自動的にアクティブ化しようとします。ただし、このプロセスのタイムリネスは保証されません。

## パーティションモデリング

階層モデリングに加えて、パーティションモデリングはデータモデリングの重要な側面です。データモデリングにおいては、しばしばビジネスのセマンティクスに基づいてデータを関連付け、データの有効期限（TTL）をタイムリネス要件に従って設定することが求められます。パーティションモデリングはこのプロセスで重要な役割を果たします。

パーティションモデリングは、階層モデリングを補完するデータモデリングの必須な側面です。ビジネスのセマンティクスに基づいてデータを関連付け、データの有効期限（TTL）をタイムリネス要件に従って設定することが求められます。データのパーティショニングはこのプロセスで重要な役割を果たします。

異なる方法でデータを関連付けることは、スタースキーマやスノーフレークスキーマなどのさまざまなモデリングアプローチとして現れます。これらのモデルには何らかの共通点があります - すべてのモデルはファクトテーブルとディメンションテーブルを使用しています。一部のビジネスシナリオでは複数の大きなファクトテーブルが必要とされ、他のビジネスシナリオでは複雑なディメンションテーブルやそれらの間の関係が扱われます。StarRocks のマテリアライズド・ビューは、ファクトテーブルのパーティション関連付けをサポートしています。つまり、ファクトテーブルがパーティション化され、マテリアライズド・ビューの結合結果も同様にパーティション化されます。

![モデリング-2](../assets/Modeling-2.png)

上記の図に示すように、マテリアライズド・ビューは複数のディメンションテーブルとファクトテーブルを関連付けます。

- 特定の基本テーブル（通常はファクトテーブル）のパーティションキー（`PARTITION BY fact_tbl.col`）をマテリアライズド・ビューのパーティションキーとして参照する必要があります。各マテリアライズド・ビューは1つの基本テーブルと関連付けることができます。
- 参照テーブルのパーティションのデータが変更されると、マテリアライズド・ビューの対応するパーティションは他のパーティションに影響を与えることなくリフレッシュされます。
- 参照されていないテーブルのデータが変更されると、通常はマテリアライズド・ビュー全体がリフレッシュされます。ただし、一部の参照されていない基本テーブルのデータ変更を無視するように選択することができます。このようにして、これらのテーブルのデータ変更時にマテリアライズド・ビューをリフレッシュしないようにすることができます。

このようなパーティション関連付けは、さまざまなビジネスシナリオをサポートします。

- **ファクトテーブルの更新**: ファクトテーブルを日次または時間単位などの詳細なレベルでパーティション化できます。ファクトテーブルが更新された後、マテリアライズド・ビュー内の対応するパーティションは自動的にリフレッシュされます。
- **ディメンションテーブルの更新**: 通常はディメンションテーブルでのデータの更新は、関連するすべての結果のリフレッシュを引き起こします。これはコストがかかることがあります。一部のディメンションテーブルでのデータ更新を無視し、マテリアライズド・ビュー全体をリフレッシュしないように選択することができます。また、リフレッシュするパーティションを時間範囲で指定することもできます。
- **外部テーブルの自動リフレッシュ**: Apache Hive や Apache Iceberg などの外部データソースでは、パーティションレベルでデータが変更されます。StarRocks のマテリアライズド・ビューは、外部カタログの変更をパーティションレベルで購読し、マテリアライズド・ビューの対応するパーティションのみをリフレッシュします。
- **TTL**: マテリアライズド・ビューのパーティショニング戦略を設定する際に、最新のパーティションを保持する数を設定できます。これにより、分析者が特定の時間枠からの最新のデータのみをクエリし、全ての履歴データを保持する必要がないビジネスシナリオで役立ちます。

リフレッシュ動作を制御するために複数のパラメータが使用できます。

- `partition_refresh_number`: リフレッシュ操作ごとにリフレッシュされるパーティションの数。
- `partition_ttl_number`: 保持される最新のパーティションの数。
- `excluded_trigger_tables`: 自動リフレッシュをトリガーさせないために無視できるテーブル。
- `auto_refresh_partitions_limit`: 自動リフレッシュ操作ごとにリフレッシュされるパーティションの数。

詳細については、[CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md) を参照してください。

現在、パーティション化されたマテリアライズド・ビューには以下の制限があります。

- パーティション化されたテーブルを基にしてパーティション化されたマテリアライズド・ビューのみを作成できます。
- 日付または日付と時刻型の列のみをパーティションキーとして使用できます。STRINGデータ型はサポートされていません。
- date_trunc、time_slice、およびdate_slice関数を使用してパーティションロールアップを行うことができます。
- パーティションキーとして単一の列のみを指定できます。複数のパーティション列はサポートされていません。

## 要約

StarRocksの非同期マテリアライズド・ビューを利用することで、データモデリングにおいてパイプラインの管理を簡素化し、宣言的モデリング言語を通じてデータモデリングの効率と柔軟性を高めるという利点が得られます。

データモデリングに加えて、StarRocksの非同期マテリアライズド・ビューは、透過的な高速化およびデータレイクの統合を含むさまざまなシナリオで応用されています。これによりデータ価値のさらなる探求が可能となり、データの効率が向上します。