---
displayed_sidebar: "Japanese"
---

# ビットマップ指標

このトピックでは、ビットマップ指標の作成と管理方法について説明します。

ビットマップ指標とは、ビットマップ(ビットの配列)を使用する特別なデータベース指標です。ビットは常に0と1のいずれかの値を取ります。ビットマップ内の各ビットは、テーブル内の単一の行に対応します。ビットの値は、対応する行の値に依存します。

ビットマップ指標は、指定された列でのクエリのパフォーマンスを改善するのに役立ちます。クエリがソートキー列に影響する場合、StarRocksは[プレフィックス指標](../table_design/Sort_key.md)を使用して効率的にクエリ結果を返します。ただし、データブロックのプレフィックス指標エントリは36バイトを超えることはできません。ソートキーとして使用されていない列でのクエリのパフォーマンスを向上させたい場合は、その列に対してビットマップ指標を作成できます。

## メリット

ビットマップ指標を使用すると、次のような点で利点があります。

- 列の基数が低い場合（列がENUM型の場合など）、応答時間を短縮できます。列のユニークな値の数が比較的高い場合、クエリの速度を向上させるためにブルームフィルタ指標を使用することをお勧めします。詳細については、[ブルームフィルタ指標](../using_starrocks/Bloomfilter_index.md)を参照してください。
- 他のインデックス技術と比較して、より少ないストレージスペースを使用します。ビットマップ指標は通常、テーブル内のインデックス化されたデータのサイズのほんの一部を占めます。
- 複数のビットマップ指標を組み合わせて複数の列でクエリを実行できます。詳細については、[複数の列でのクエリ](#複数の列でのクエリ)を参照してください。

## 使用上の注意

- 等しい（`=`）または[NOT] IN演算子を使用して列をフィルターする場合、ビットマップ指標を作成できます。
- 重複キー表や一意キー表のすべての列に対してビットマップ指標を作成できます。集約表やプライマリキー表の場合、キー列に対してのみビットマップ指標を作成できます。
- FLOAT、DOUBLE、BOOLEAN、DECIMALタイプの列ではビットマップ指標を作成できません。
- クエリがビットマップ指標を使用しているかどうかを確認するには、クエリのプロファイルの`BitmapIndexFilterRows`フィールドを表示します。

## ビットマップ指標の作成

列に対してビットマップ指標を作成する方法は2つあります。

- テーブルを作成するときに列に対してビットマップ指標を作成します。例えば：

    ```SQL
    CREATE TABLE d0.table_hash
    (
        k1 TINYINT,
        k2 DECIMAL(10, 2) DEFAULT "10.5",
        v1 CHAR(10) REPLACE,
        v2 INT SUM,
        INDEX index_name (column_name [, ...]) [USING BITMAP] [COMMENT '']
    )
    ENGINE = olap
    AGGREGATE KEY(k1, k2)
    DISTRIBUTED BY HASH(k1)
    PROPERTIES ("storage_type" = "column");
    ```

    次の表に、ビットマップ指標に関連するパラメータについて説明します。

    | **パラメータ** | **必須** | **説明**                                              |
    | ------------- | ---------- | ------------------------------------------------------------ |
    | index_name    | はい          | ビットマップ指標の名前。 命名規則は以下のとおりです：<ul><li>名前には、文字、数字（0-9）、アンダースコア(_)を含めることができます。名前は文字で始める必要があります。</li><li>名前の長さは64文字を超えることはできません。</li></ul>ビットマップ指標の名前は、テーブル内で一意である必要があります。                              |
    | column_name   | はい          | ビットマップ指標を作成する列の名前。複数の列名を指定して一度に複数の列のビットマップ指数を作成することができます。複数の列はコンマ(,)で区切って指定します。  |
    | COMMENT       | いいえ           | ビットマップ指標のコメント。                             |

    `INDEX index_name (column_name [, ...]) [USING BITMAP] [COMMENT '']`コマンドを複数指定することで、一度に複数の列に対してビットマップ指標を作成できます。これらのコマンドはコンマ(,)で区切って指定する必要があります。CREATE TABLEステートメントのその他のパラメータの説明については、[CREATE TABLE](../sql-reference/sql-statements/data-definition/CREATE_TABLE.md)を参照してください。

- CREATE INDEXステートメントを使用してテーブルの列に対してビットマップ指標を作成します。パラメータの説明や例については、[CREATE INDEX](../sql-reference/sql-statements/data-definition/CREATE_INDEX.md)を参照してください。

    ```SQL
    CREATE INDEX index_name ON table_name (column_name) [USING BITMAP] [COMMENT ''];
    ```

## ビットマップ指標の表示

SHOW INDEXステートメントを使用して、テーブルに作成されたすべてのビットマップ指数を表示できます。パラメータの説明や例については、[SHOW INDEX](../sql-reference/sql-statements/Administration/SHOW_INDEX.md)を参照してください。

```SQL
SHOW { INDEX[ES] | KEY[S] } FROM [db_name.]table_name [FROM db_name];
```

> **ノート**
>
> インデックスの作成は非同期プロセスです。そのため、作成プロセスが完了したインデックスのみを表示できます。

## ビットマップ指標の削除

DROP INDEXステートメントを使用して、テーブルからビットマップ指標を削除できます。パラメータの説明や例については、[DROP INDEX](../sql-reference/sql-statements/data-definition/DROP_INDEX.md)を参照してください。

```SQL
DROP INDEX index_name ON [db_name.]table_name;
```

## 使用例

例えば、以下の表`employee`は、ある企業の従業員情報の一部を示しています。

| **ID** | **Gender** | **Position** | **Income_level** |
| ------ | ---------- | ------------ | ---------------- |
| 01     | 女性       | 開発者       | レベル1           |
| 02     | 女性       | アナリスト   | レベル2           |
| 03     | 女性       | 営業員      | レベル1           |
| 04     | 男性       | 会計士      | レベル3           |

### 単一の列のクエリ

例えば、`Gender`列のクエリのパフォーマンスを改善したい場合、以下のステートメントを使用して列にビットマップ指標を作成できます。

```SQL
CREATE INDEX index1 ON employee (Gender) USING BITMAP COMMENT 'index1';
```

前述のステートメントを実行すると、ビットマップ指数が次の図のように生成されます。

![figure](../assets/3.6.1-2.png)

1. 辞書の作成：StarRocksは`Gender`列用に辞書を構築し、`女性`と`男性`をINT型のコード値`0`と`1`にマッピングします。
2. ビットマップの生成：StarRocksはコード値に基づいて`女性`と`男性`用のビットマップを生成します。`女性`のビットマップは`1110`であり、`女性`は最初の3行に表示されるためです。`男性`のビットマップは`0001`で、`男性`は4番目の行にのみ表示されます。

企業内の男性従業員を見つけたい場合、次のクエリを送信できます。

```SQL
SELECT xxx FROM employee WHERE Gender = 男性;
```

クエリを送信した後、StarRocksは辞書を検索して`男性`のコード値`1`を取得し、その後`男性`のビットマップ`0001`を取得します。これにより、クエリ条件に一致するのは4番目の行のみであることがわかります。そのため、StarRocksは最初の3行をスキップして4番目の行のみを読み取ります。

### 複数の列のクエリ

例えば、`Gender`列と`Income_level`列のクエリのパフォーマンスを改善したい場合、次のステートメントを使用してこれら2つの列に対してビットマップ指数を作成できます。

- `Gender`

    ```SQL
    CREATE INDEX index1 ON employee (Gender) USING BITMAP COMMENT 'index1';
    ```

- `Income_level`

    ```SQL
    CREATE INDEX index2 ON employee (Income_level) USING BITMAP COMMENT 'index2';
    ```

前述の2つのステートメントを実行すると、ビットマップ指数が次の図のように生成されます。

![figure](../assets/3.6.1-3.png)

StarRocksはそれぞれ`Gender`と`Income_level`列のために辞書を構築し、次にこれら2つの列の異なる値に対応するビットマップを生成します。

- `Gender`：`女性`のビットマップは`1110`であり、`男性`のビットマップは`0001`です。
- `Income_level`：`レベル1`のビットマップは`1010`、`レベル2`のビットマップは`0100`、そして`レベル3`のビットマップは`0001`です。

例えば、`レベル1`の給与をもらっている女性従業員を見つけたい場合、次のクエリを送信できます。

```SQL
 SELECT xxx FROM employee 
 WHERE Gender = 女性 AND Income_level = レベル1;
```

クエリを送信した後、StarRocksは`Gender`と`Income_level`の辞書を同時に検索して次の情報を取得します：

- `女性`のコード値は`0`で、ビットマップは`1110`です。
- `レベル1`のコード値は`0`で、ビットマップは`1010`です。

StarRocksは`AND`演算子に基づいて`1110 & 1010`のビットごとの論理演算を行い、結果`1010`を得ます。これにより、StarRocksは最初の行と3番目の行のみを読み取ります。