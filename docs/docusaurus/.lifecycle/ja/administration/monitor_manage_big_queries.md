---
displayed_sidebar: "Japanese"
---

# 大規模クエリの監視と管理

このトピックでは、StarRocksクラスターにおける大規模クエリの監視と管理方法について説明します。

大規模クエリとは、多くの行をスキャンするクエリや多くのCPUおよびメモリリソースを占有するクエリのことです。これらのクエリはクラスターリソースを容易に枯渇させ、規制がない場合にはシステムの過負荷を引き起こすことがあります。これらの問題に対処するため、StarRocksは大規模クエリの監視と管理のための一連の対策を提供し、クエリがクラスターリソースを独占することを防ぎます。

StarRocksにおける大規模クエリの取り扱いの全体的なアイデアは次の通りです。

1. リソースグループとクエリキューを使用して大規模クエリに対する自動的な予防措置を設定します。
2. 大規模クエリをリアルタイムで監視し、予防措置をバイパスするクエリを終了させます。
3. オーディットログとBig Queryログを分析して大規模クエリのパターンを調査し、事前に設定した予防措置のメカニズムを微調整します。

この機能はv3.0以降でサポートされています。

## 大規模クエリに対する予防措置の設定

StarRocksは大規模クエリに対処するための2つの予防措置ツール、リソースグループとクエリキューを提供しています。リソースグループを使用すると大規模クエリの実行を停止することができます。一方、クエリキューは、並行性のしきい値またはリソース制限に達した場合に、システムの過負荷を防ぐために着信クエリをキューに入れるのに役立ちます。

### リソースグループを使用して大規模クエリを取り除く

リソースグループは自動的に大規模クエリを識別し、終了させることができます。リソースグループを作成する際には、クエリに許可されるCPU時間、メモリ使用量、またはスキャン行数の上限を指定することができます。リソースグループに含まれるすべてのクエリの中で、より多くのリソースが必要なクエリは拒否され、エラーが返されます。詳細については、[リソースの分離](../administration/resource_group.md)を参照してください。

リソースグループを作成する前に、リソースグループ機能が依存するPipeline Engineを有効にするために、次のステートメントを実行する必要があります。

```SQL
SET GLOBAL enable_pipeline_engine = true;
```

次の例では、CPU時間の上限を100秒、スキャン行数の上限を100,000行、メモリ使用量の上限を1,073,741,824バイト（1GB）に制限するリソースグループ`bigQuery`を作成します。

```SQL
CREATE RESOURCE GROUP bigQuery
TO 
    (db='sr_hub')
WITH (
    'cpu_core_limit' = '10',
    'mem_limit' = '20%',
    'big_query_cpu_second_limit' = '100',
    'big_query_scan_rows_limit' = '100000',
    'big_query_mem_limit' = '1073741824'
);
```

クエリの必要なリソースがいずれかの上限を超える場合、クエリは実行されず、エラーが返されます。次の例では、クエリが多くのスキャン行を要求したときに返されるエラーメッセージを示します。

```Plain
ERROR 1064 (HY000): exceed big query scan_rows limit: current is 4 but limit is 1
```

リソースグループを初めて設定する場合は、通常のクエリの実行を妨げないように比較的高い上限を設定することをお勧めします。大規模クエリのパターンについてよりよい理解を得た後で、これらの上限を微調整することができます。

### クエリキューを使用してシステムの過負荷を和らげる

クエリキューは、クラスターリソースの占有が指定されたしきい値を超えた場合に、システムの過負荷を和らげるためのものです。最大並行性、メモリ使用率、およびCPU使用率のしきい値を設定することができます。StarRocksはしきい値のいずれかに達した場合に着信クエリを自動的にキューに入れます。保留中のクエリは、実行のためにキューで待機するか、指定されたリソースしきい値に達した場合はキャンセルされます。詳細については、[クエリキュー](../administration/query_queues.md)を参照してください。

以下のステートメントを実行して、SELECTクエリに対してクエリキューを有効にします。

```SQL
SET GLOBAL enable_query_queue_select = true;
```

クエリキュー機能が有効になった後、クエリキューをトリガーするためのルールを定義することができます。

- クエリキューをトリガーするための並行性しきい値を指定します。

  次の例では、並行性しきい値を100に設定します。

  ```SQL
  SET GLOBAL query_queue_concurrency_limit = 100;
  ```

- クエリキューをトリガーするためのメモリ使用率のしきい値を指定します。

  次の例では、メモリ使用率のしきい値を0.9に設定します。

  ```SQL
  SET GLOBAL query_queue_mem_used_pct_limit = 0.9;
  ```

- クエリキューをトリガーするためのCPU使用率のしきい値を指定します。

  次の例では、CPU使用率パーミル（CPU使用率 * 1000）のしきい値を800に設定します。

  ```SQL
  SET GLOBAL query_queue_cpu_used_permille_limit = 800;
  ```

また、キューで待機するクエリの最大長およびキュー内の各保留中クエリのタイムアウトを設定して、これらの保留中のクエリをどのように処理するかを決定することができます。

- クエリキューの最大長を指定します。このしきい値に達すると、着信クエリは拒否されます。

  次の例では、クエリキューの長さを100に設定します。

  ```SQL
  SET GLOBAL query_queue_max_queued_queries = 100;
  ```

- キューで保留中の各クエリの最大タイムアウトを指定します。このしきい値に達すると、対応するクエリが拒否されます。

  次の例では、最大タイムアウトを480秒に設定します。

  ```SQL
  SET GLOBAL query_queue_pending_timeout_second = 480;
  ```

クエリが保留中かどうかは、[SHOW PROCESSLIST](../sql-reference/sql-statements/Administration/SHOW_PROCESSLIST.md)を使用して確認できます。

```Plain
mysql> SHOW PROCESSLIST;
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
| Id   | User | Host                | Db    | Command | ConnectionStartTime | Time | State | Info              | IsPending |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
|    2 | root | xxx.xx.xxx.xx:xxxxx |       | Query   | 2022-11-24 18:08:29 |    0 | OK    | SHOW PROCESSLIST  | false     |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
```

`IsPending`が`true`の場合、対応するクエリはクエリキュー内で保留中です。

## リアルタイムで大規模クエリを監視する

v3.0以降、StarRocksではクラスターで現在処理されているクエリとそれらが占有するリソースを表示する機能がサポートされています。これにより、予防措置をバイパスして予期せぬシステムの過負荷を引き起こす可能性のある大規模クエリを監視することができます。

### MySQLクライアントを使用して監視する

1. [SHOW PROC](../sql-reference/sql-statements/Administration/SHOW_PROC.md)を使用して、現在処理されているクエリ（`current_queries`）を表示することができます。

   ```SQL
   SHOW PROC '/current_queries';
   ```

   StarRocksは、各クエリのクエリID（`QueryId`）、接続ID（`ConnectionId`）、スキャンされたデータサイズ（`ScanBytes`）、処理された行数（`ProcessRows`）、CPU時間（`CPUCostSeconds`）、メモリ使用量（`MemoryUsageBytes`）、および実行時間（`ExecTime`）を含む、各クエリのリソース消費を返します。

   ```Plain
   mysql> SHOW PROC '/current_queries';
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | QueryId                              | ConnectionId | Database   | User | ScanBytes | ProcessRows    | CPUCostSeconds | MemoryUsageBytes | ExecTime |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | 7c56495f-ae8b-11ed-8ebf-00163e00accc | 4            | tpcds_100g | root | 37.88 MB  | 1075769 Rows   | 11.13 Seconds  | 146.70 MB        | 3804     |
   | 7d543160-ae8b-11ed-8ebf-00163e00accc | 6            | tpcds_100g | root | 13.02 GB  | 487873176 Rows | 81.23 Seconds  | 6.37 GB          | 2090     |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   2 rows in set (0.01 sec)
   ```

2. クエリIDを指定して、各BEノードでクエリのリソース消費をさらに調査することができます。

   ```SQL
   SHOW PROC '/current_queries/<QueryId>/hosts';
   ```

   StarRocksは、各BEノードでクエリのスキャンされたデータサイズ（`ScanBytes`）、スキャンされた行数（`ScanRows`）、CPU時間（`CPUCostSeconds`）、メモリ使用量（`MemUsageBytes`）を返します。

   ```Plain
   mysql> show proc '/current_queries/7c56495f-ae8b-11ed-8ebf-00163e00accc/hosts';
   +--------------------+-----------+-------------+----------------+---------------+
   | Host               | ScanBytes | ScanRows    | CpuCostSeconds | MemUsageBytes |
   +--------------------+-----------+-------------+----------------+---------------+
   | 172.26.34.185:8060 | 11.61 MB  | 356252 Rows | 52.93 Seconds  | 51.14 MB      |
   | 172.26.34.186:8060 | 14.66 MB  | 362646 Rows | 52.89 Seconds  | 50.44 MB      |
   | 172.26.34.187:8060 | 11.60 MB  | 356871 Rows | 52.91 Seconds  | 48.95 MB      |
   +--------------------+-----------+-------------+----------------+---------------+
3 行をセットしました（0.00 秒）

```

### FEコンソールを介してモニタリング

MySQLクライアントに加えて、視覚化されたインタラクティブな監視のためにFEコンソールを使用できます。

1. 次のURLを使用して、ブラウザでFEコンソールに移動します：

   ```Bash
   http://<fe_IP>:<fe_http_port>/system?path=//current_queries
   ```

   ![FE console 1](../assets/console_1.png)

   **システム情報**ページで、現在処理中のクエリとそれらのリソース消費を表示できます。

2. クエリの**QueryID**をクリックします。

   ![FE console 2](../assets/console_2.png)

   表示されるページで、詳細なノード固有のリソース消費情報を表示できます。

### 大規模クエリを手動で終了する

設定した予防策をバイパスしてシステムの可用性を脅かす任意の大規模クエリがある場合は、対応する接続IDを使用してそれらを手動で終了できます[KILL](../sql-reference/sql-statements/Administration/KILL.md) 文を使用して：

```SQL
KILL QUERY <ConnectionId>;
```

## 大規模クエリログの分析

v3.0から、StarRocksは大規模クエリログをサポートし、これらはファイル **fe/log/fe.big_query.log** に保存されます。StarRocks監査ログと比較して、大規模クエリログには追加の 3 つのフィールドが印刷されます：

- `bigQueryLogCPUSecondThreshold`
- `bigQueryLogScanBytesThreshold`
- `bigQueryLogScanRowsThreshold`

これらの 3 つのフィールドは、クエリが大規模クエリであるかどうかを判断するために定義したリソース消費の閾値に対応しています。

大規模クエリログを有効にするには、次の文を実行します：

```SQL
SET GLOBAL enable_big_query_log = true;
```

大規模クエリログを有効にした後、大規模クエリログをトリガーするための規則を定義できます。

- 大規模クエリログをトリガーするための CPU 実行時間の閾値を指定します。

  次の例では、CPU 実行時間の閾値を `600` 秒に設定します：

  ```SQL
  SET GLOBAL big_query_log_cpu_second_threshold = 600;
  ```

- 大規模クエリログをトリガーするためのスキャンデータサイズの閾値を指定します。

  次の例では、スキャンデータサイズの閾値を `10737418240` バイト（10 GB）に設定します：

  ```SQL
  SET GLOBAL big_query_log_scan_bytes_threshold = 10737418240;
  ```

- 大規模クエリログをトリガーするためのスキャン行数の閾値を指定します。

  次の例では、スキャン行数の閾値を `1500000000` に設定します：

  ```SQL
  SET GLOBAL big_query_log_scan_rows_threshold = 1500000000;
  ```

## 予防策の微調整

リアルタイムモニタリングおよび大規模クエリログから得られた統計を元にして、クラスター内で省略された大規模クエリ（または誤って大規模クエリと診断された通常のクエリ）のパターンを調査し、リソースグループとクエリキューの設定を最適化できます。

特定の SQL パターンに一致する大規模クエリの顕著な割合があり、この SQL パターンを永続的に禁止したい場合は、このパターンをSQLブラックリストに追加できます。StarRocksは、SQLブラックリストで指定されたパターンに一致するクエリをすべて拒否し、エラーを返します。詳細については[SQLブラックリストの管理](../administration/Blacklist.md)を参照してください。

SQLブラックリストを有効にするには、次の文を実行します：

```SQL
ADMIN SET FRONTEND CONFIG ("enable_sql_blacklist" = "true");
```

その後、SQLブラックリストにSQLパターンを追加できます。[ADD SQLBLACKLIST](../sql-reference/sql-statements/Administration/ADD_SQLBLACKLIST.md)を使用して、SQLパターンを表す正規表現をSQLブラックリストに追加できます。

次の例では、`COUNT(DISTINCT)` をSQLブラックリストに追加します：

```SQL
ADD SQLBLACKLIST "SELECT COUNT(DISTINCT .+) FROM .+";
```