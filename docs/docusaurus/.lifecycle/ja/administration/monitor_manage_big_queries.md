---
displayed_sidebar: "Japanese"
---

# 大規模クエリの監視と管理

このトピックでは、StarRocksクラスターにおける大規模クエリの監視と管理方法について説明します。

大規模クエリには、多数の行をスキャンする、または多くのCPUおよびメモリリソースを占有するクエリが含まれます。これらはクラスターリソースを使い果たし、制限がかけられていない場合にはシステムを過負荷に陥らせる可能性があります。この問題に対処するために、StarRocksは大規模クエリの監視と管理を行うためのさまざまな手段を提供し、クエリがクラスターリソースを独占するのを防ぎます。

StarRocksにおける大規模クエリの対処の全体的なアイデアは以下の通りです。

1. リソースグループとクエリキューを使用して大規模クエリに対する自動的な予防措置を設定する。
2. 大規模クエリをリアルタイムで監視し、予防措置を回避するクエリを終了する。
3. オーディットログとBig Queryログを分析して大規模クエリのパターンを調査し、前もって設定した予防措置を微調整する。

この機能はv3.0からサポートされています。

## 大規模クエリに対する予防措置の設定

StarRocksは大規模クエリに対処するための2つの予防措置機構であるリソースグループとクエリキューを提供しています。リソースグループを使用して大規模クエリの実行を停止することができます。一方、クエリキューは、同時実行の閾値またはリソース制限が達成されたときに、システムの過負荷を防ぐために、入力されるクエリをキューに入れます。

### リソースグループを使用して大規模クエリをフィルタリング

リソースグループは自動的に大規模クエリを識別し、終了させることができます。リソースグループを作成する際に、クエリが利用できるCPU時間、メモリ使用量、またはスキャン行数の上限を指定することができます。リソースグループに該当するすべてのクエリのうち、それぞれがより多くのリソースを必要とするクエリは拒否され、エラーが返されます。詳細については、[リソースの分離](../administration/resource_group.md)を参照してください。

リソースグループを作成する前に、リソースグループ機能に依存するPipeline Engineを有効にするために、次のステートメントを実行する必要があります。

```SQL
SET GLOBAL enable_pipeline_engine = true;
```

次の例では、CPU時間の上限を`100`秒、スキャン行数の上限を`100,000`、およびメモリ使用量の上限を`1,073,741,824`バイト（1GB）とする`bigQuery`というリソースグループを作成しています。

```SQL
CREATE RESOURCE GROUP bigQuery
TO 
    (db='sr_hub')
WITH (
    'cpu_core_limit' = '10',
    'mem_limit' = '20%',
    'big_query_cpu_second_limit' = '100',
    'big_query_scan_rows_limit' = '100000',
    'big_query_mem_limit' = '1073741824'
);
```

クエリの必要なリソースがいずれかの上限を超える場合、クエリは実行されずにエラーが返されます。次の例では、クエリが多くのスキャン行を要求した場合に返されるエラーメッセージを示しています。

```Plain
ERROR 1064 (HY000): exceed big query scan_rows limit: current is 4 but limit is 1
```

リソースグループを初めて設定する際には、通常のクエリに支障をきたさないように、比較的高い上限を設定することをお勧めします。大規模クエリのパターンについてよりよく理解した後でこれらの上限を微調整することができます。

### クエリキューを使用してシステムの過負荷を緩和

クエリキューは、クラスターリソースの占有が事前に定義された閾値を超えた場合に、システムの過負荷の悪化を緩和するために設計されています。最大同時実行数、メモリ使用量、およびCPU使用量の閾値を設定することができます。StarRocksは、これらの閾値のうちいずれかが達成されたときに入力されるクエリを自動的にキューに入れます。保留中のクエリは、実行のためにキューで待機するか、事前に定義されたリソース閾値が達成された際にキャンセルされます。詳細については、[クエリキュー](../administration/query_queues.md)を参照してください。

SELECTクエリに対してクエリキューを有効にするには、次のステートメントを実行してください。

```SQL
SET GLOBAL enable_query_queue_select = true;
```

クエリキュー機能が有効になった後、クエリキューをトリガーするルールを定義することができます。

- クエリキューをトリガーするための同時実行数の閾値を指定します。

  次の例では、同時実行数の閾値を`100`に設定しています。

  ```SQL
  SET GLOBAL query_queue_concurrency_limit = 100;
  ```

- クエリキューをトリガーするためのメモリ使用率の閾値を指定します。

  次の例では、メモリ使用率の閾値を`0.9`に設定しています。

  ```SQL
  SET GLOBAL query_queue_mem_used_pct_limit = 0.9;
  ```

- クエリキューをトリガーするためのCPU使用率の閾値を指定します。

  次の例では、CPU使用率パーミル（CPU使用率×1000）の閾値を`800`に設定しています。

  ```SQL
  SET GLOBAL query_queue_cpu_used_permille_limit = 800;
  ```

また、キューで保留中のクエリの扱い方を決定することができます。これは、最大キュー長とキューで保留中の各クエリのタイムアウトを設定することで行います。

- 最大クエリキューの長さを指定します。この閾値に到達すると、新たなクエリが拒否されます。

  次の例では、クエリキューの長さを`100`に設定しています。

  ```SQL
  SET GLOBAL query_queue_max_queued_queries = 100;
  ```

- キューで保留中の各クエリの最大タイムアウトを指定します。この閾値に到達すると、対応するクエリが拒否されます。

  次の例では、最大タイムアウトを`480`秒に設定しています。

  ```SQL
  SET GLOBAL query_queue_pending_timeout_second = 480;
  ```

クエリが保留中かどうかを確認するには、[SHOW PROCESSLIST](../sql-reference/sql-statements/Administration/SHOW_PROCESSLIST.md)を使用することができます。

```Plain
mysql> SHOW PROCESSLIST;
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
| Id   | User | Host                | Db    | Command | ConnectionStartTime | Time | State | Info              | IsPending |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
|    2 | root | xxx.xx.xxx.xx:xxxxx |       | Query   | 2022-11-24 18:08:29 |    0 | OK    | SHOW PROCESSLIST  | false     |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
```

`IsPending`が`true`である場合、対応するクエリはクエリキューで保留中です。

## リアルタイムで大規模クエリを監視する

v3.0から、StarRocksはクラスターで現在処理中のクエリとそれらが占有するリソースを表示する機能をサポートしています。これにより、大規模クエリが予防措置をバイパスして予期せぬシステムの過負荷を引き起こす場合に、クラスターを監視することができます。

### MySQLクライアントを使用して監視

1. [SHOW PROC](../sql-reference/sql-statements/Administration/SHOW_PROC.md)を使用して、現在処理中のクエリ(`current_queries`)を表示することができます。

   ```SQL
   SHOW PROC '/current_queries';
   ```

   StarRocksは、各クエリのクエリID（`QueryId`）、接続ID（`ConnectionId`）、およびスキャンデータサイズ（`ScanBytes`）、処理行数（`ProcessRows`）、CPU時間（`CPUCostSeconds`）、メモリ使用量（`MemoryUsageBytes`）、および実行時間（`ExecTime`）を含む、各クエリのリソース消費を返します。

   ```Plain
   mysql> SHOW PROC '/current_queries';
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | QueryId                              | ConnectionId | Database   | User | ScanBytes | ProcessRows    | CPUCostSeconds | MemoryUsageBytes | ExecTime |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | 7c56495f-ae8b-11ed-8ebf-00163e00accc | 4            | tpcds_100g | root | 37.88 MB  | 1075769 Rows   | 11.13 Seconds  | 146.70 MB        | 3804     |
   | 7d543160-ae8b-11ed-8ebf-00163e00accc | 6            | tpcds_100g | root | 13.02 GB  | 487873176 Rows | 81.23 Seconds  | 6.37 GB          | 2090     |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   2 rows in set (0.01 sec)
   ```

2. クエリIDを指定して各BEノード上のクエリのリソース消費をさらに調査することができます。

   ```SQL
   SHOW PROC '/current_queries/<QueryId>/hosts';
   ```

   StarRocksは、各BEノード上のクエリのスキャンデータサイズ（`ScanBytes`）、スキャン行数（`ScanRows`）、CPU時間（`CPUCostSeconds`）、およびメモリ使用量（`MemUsageBytes`）を返します。

   ```Plain
   mysql> show proc '/current_queries/7c56495f-ae8b-11ed-8ebf-00163e00accc/hosts';
   +--------------------+-----------+-------------+----------------+---------------+
   | Host               | ScanBytes | ScanRows    | CpuCostSeconds | MemUsageBytes |
   +--------------------+-----------+-------------+----------------+---------------+
   | 172.26.34.185:8060 | 11.61 MB  | 356252 Rows | 52.93 Seconds  | 51.14 MB      |
   | 172.26.34.186:8060 | 14.66 MB  | 362646 Rows | 52.89 Seconds  | 50.44 MB      |
   | 172.26.34.187:8060 | 11.60 MB  | 356871 Rows | 52.91 Seconds  | 48.95 MB      |
   +--------------------+-----------+-------------+----------------+---------------+
```
   3行が設定されました (0.00 秒)

   ```

### FEコンソールを介した監視

MySQLクライアントに加えて、視覚的でインタラクティブな監視のためにFEコンソールを使用できます。

1. 次のURLを使用してブラウザでFEコンソールに移動します。

   ```Bash
   http://<fe_IP>:<fe_http_port>/system?path=//current_queries
   ```

   ![FEコンソール 1](../assets/console_1.png)

   **System Info** ページで現在処理されているクエリとそれらのリソース消費を表示できます。

2. クエリの **QueryID** をクリックします。

   ![FEコンソール 2](../assets/console_2.png)

   表示されるページで、詳細なノード固有のリソース消費情報を表示できます。

### 大規模クエリを手動で終了

設定した予防策をバイパスし、システムの可用性に脅威を与える可能性のある大規模クエリがあれば、[KILL](../sql-reference/sql-statements/Administration/KILL.md) ステートメントを使用して対応する接続IDを指定して手動で終了できます。

```SQL
KILL QUERY <ConnectionId>;
```

## 大規模クエリログの分析

v3.0以降、StarRocksは、**fe/log/fe.big_query.log** に格納されている大規模クエリログをサポートしています。StarRocks監査ログと比較して、大規模クエリログには追加の3つのフィールドが表示されます:

- `bigQueryLogCPUSecondThreshold`
- `bigQueryLogScanBytesThreshold`
- `bigQueryLogScanRowsThreshold`

これらの3つのフィールドは、クエリが大規模クエリかどうかを判断するために定義したリソース消費の閾値に対応しています。

大規模クエリログを有効にするには、次のステートメントを実行します:

```SQL
SET GLOBAL enable_big_query_log = true;
```

大規模クエリログが有効になったら、大規模クエリログをトリガするための規則を定義できます。

- 大規模クエリログをトリガするためのCPU時間の閾値を指定します。

  次の例では、CPU時間の閾値を `600` 秒に設定します:

  ```SQL
  SET GLOBAL big_query_log_cpu_second_threshold = 600;
  ```

- 大規模クエリログをトリガするためのスキャンデータサイズの閾値を指定します。

  次の例では、スキャンデータサイズの閾値を `10737418240` バイト (10 GB) に設定します:

  ```SQL
  SET GLOBAL big_query_log_scan_bytes_threshold = 10737418240;
  ```

- 大規模クエリログをトリガするためのスキャン行数の閾値を指定します。

  次の例では、スキャン行数の閾値を `1500000000` に設定します:

  ```SQL
  SET GLOBAL big_query_log_scan_rows_threshold = 1500000000;
  ```

## 予防策の微調整

リアルタイム監視や大規模クエリログから得られる統計情報を元に、クラスター内の無視された大規模クエリ (または誤って大規模クエリと診断された通常のクエリ) のパターンを分析し、リソースグループとクエリキューの設定を最適化できます。

特定のSQLパターンに合致する大規模クエリが著しい割合を占め、このSQLパターンを永続的に禁止したい場合は、このパターンをSQLブラックリストに追加できます。StarRocksは、SQLブラックリストで指定されたパターンに合致するクエリを拒否し、エラーを返します。詳細については、[SQLブラックリストの管理](../administration/Blacklist.md)を参照してください。

SQLブラックリストを有効にするには、次のステートメントを実行します:

```SQL
ADMIN SET FRONTEND CONFIG ("enable_sql_blacklist" = "true");
```

その後、[ADD SQLBLACKLIST](../sql-reference/sql-statements/Administration/ADD_SQLBLACKLIST.md) を使用して、SQLパターンを表す正規表現をSQLブラックリストに追加できます。

次の例では、 `COUNT(DISTINCT)` をSQLブラックリストに追加します:

```SQL
ADD SQLBLACKLIST "SELECT COUNT(DISTINCT .+) FROM .+";
```