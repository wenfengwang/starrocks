```yaml
---
displayed_sidebar: "日本語"
---

# クエリープロファイルの解析

このトピックでは、クエリープロファイルのチェック方法について説明します。クエリープロファイルは、クエリに関与するすべてのワーカーノードの実行情報を記録します。クエリープロファイルは、StarRocksクラスタのクエリーパフォーマンスに影響を与えるボトルネックを迅速に特定するのに役立ちます。

## クエリープロファイルの有効化

StarRocksのv2.5より前のバージョンでは、変数 `is_report_success` を `true` に設定することでクエリープロファイルを有効にできます。

```SQL
SET is_report_success = true;
```

StarRocks v2.5以降のバージョンでは、変数 `enable_profile` を `true` に設定することでクエリープロファイルを有効にできます。

```SQL
SET enable_profile = true;
```

### ランタイムプロファイル

StarRocksのv3.1以降、StarRocksはランタイムプロファイル機能をサポートしており、クエリが完了する前にクエリープロファイルにアクセスできるようになります。

この機能を使用するには、`enable_profile` を `true` に設定することに加えて、セッション変数 `runtime_profile_report_interval` を設定する必要があります。`runtime_profile_report_interval`（単位: 秒、デフォルト: `10`）は、プロファイルのレポート間隔を制御し、クエリが10秒を超える場合、ランタイムプロファイル機能が自動的に有効になります。

```SQL
SET runtime_profile_report_interval = 10;
```

ランタイムプロファイルは通常のクエリープロファイルと同様の情報を表示します。実行中のクエリのパフォーマンスに関する貴重な洞察を得るために、通常のクエリープロファイルと同様に分析できます。

ただし、実行計画のいくつかの演算子は他の演算子に依存する場合があるため、ランタイムプロファイルは不完全である場合があります。実行中の演算子と完了した演算子を簡単に区別するために、実行中の演算子には `ステータス: 実行中` と表示されます。

## クエリープロファイルへのアクセス

> **注意**
>
> StarRocksのエンタープライズエディションを使用している場合は、StarRocks Managerを使用してクエリープロファイルにアクセスし、視覚化できます。

StarRocksのコミュニティエディションを使用している場合は、次の手順に従ってクエリープロファイルにアクセスしてください。

1. ブラウザーで `http://<fe_ip>:<fe_http_port>` を入力します。
2. 表示されるページで、上部のナビゲーションペインで **queries** をクリックします。
3. **Finished Queries** リストで、確認したいクエリを選択し、**Profile** 列のリンクをクリックします。

![img](../assets/profile-1.png)

ブラウザーは、対応するクエリープロファイルが含まれる新しいページにリダイレクトします。

![img](../assets/profile-2.png)

## クエリープロファイルの解釈

### クエリープロファイルの構造

以下はクエリープロファイルの例です。

```SQL
クエリー:
  概要:
  プランナー:
  実行プロファイル 7de16a85-761c-11ed-917d-00163e14d435:
    Fragment 0:
      パイプライン（id=2）:
        EXCHANGE_SINK（plan_node_id=18）:
        LOCAL_MERGE_SOURCE（plan_node_id=17）:
      パイプライン（id=1）:
        LOCAL_SORT_SINK（plan_node_id=17）:
        AGGREGATE_BLOCKING_SOURCE（plan_node_id=16）:
      パイプライン（id=0）:
        AGGREGATE_BLOCKING_SINK（plan_node_id=16）:
        EXCHANGE_SOURCE（plan_node_id=15）:
    Fragment 1:
       ...
    Fragment 2:
       ...
```

クエリープロファイルには、3つのセクションがあります。

- Fragment: 実行ツリー。1つのクエリーは1つ以上のフラグメントに分割できます。
- Pipeline: 実行チェーン。実行チェーンには枝がありません。フラグメントは複数のパイプラインに分かれることができます。
- Operator: パイプラインは複数の演算子で構成されます。

![img](../assets/profile-3.png)

*フラグメントは複数のパイプラインから成ります。*

### 主要なメトリック

クエリープロファイルには、クエリーの実行の詳細を示す多くのメトリックが含まれています。ほとんどの場合、演算子の実行時間とそれらが処理したデータのサイズを確認するだけで十分です。ボトルネックを見つけた後は、それに応じて解決できます。

#### 概要

| メトリック       | 説明                                              |
| --------------- | ------------------------------------------------ |
| Total           | プランニング、実行、プロファイリングに費やされた合計時間。 |
| QueryCpuCost    | クエリーの合計CPU時間コスト。CPU時間コストは並行処理のために集約されます。そのため、このメトリックの値はクエリーの実際の実行時間よりも大きくなる場合があります。 |
| QueryMemCost    | クエリーの合計メモリコスト。                        |

#### 演算子の汎用メトリック

| メトリック           | 説明                                               |
| ------------------ | ------------------------------------------------- |
| OperatorTotalTime | 演算子の合計CPU時間コスト。                        |
| PushRowNum        | 演算子がプッシュしたデータの総行数。                |
| PullRowNum        | 演算子がプルしたデータの総行数。                    |

#### ユニークメトリック

| メトリック           | 説明                                                  |
| ------------------ | ---------------------------------------------------- |
| IOTaskExecTime    | すべてのI/Oタスクの合計実行時間。                       |
| IOTaskWaitTime    | すべてのI/Oタスクの合計待機時間。                       |
| MorselsCount      | I/Oタスクの総数。                                     |

#### スキャン演算子

| メトリック                          | 説明                                                              |
| -------------------------------- | ------------------------------------------------------------------ |
| Table                            | テーブル名。                                                         |
| ScanTime                         | 合計スキャン時間。スキャンは非同期I/Oスレッドプールで実行されます。              |
| TabletCount                      | タブレットの数。                                                     |
| PushdownPredicates               | プッシュダウンされた述語の数。                                           |
| BytesRead                        | StarRocksが読み取ったデータのサイズ。                                       |
| CompressedBytesRead              | StarRocksが読み取った圧縮データのサイズ。                                     |
| IOTime                           | 合計I/O時間。                                                       |
| BitmapIndexFilterRows            | Bitmapインデックスによってフィルタリングされたデータ行数。                              |
| BloomFilterFilterRows            | Bloomフィルタによってフィルタリングされたデータ行数。                                 |
| SegmentRuntimeZoneMapFilterRows  | ランタイムZone Mapによってフィルタリングされたデータ行数。                              |
| SegmentZoneMapFilterRows         | Zone Mapによってフィルタリングされたデータ行数。                                     |
| ShortKeyFilterRows               | Short Keyによってフィルタリングされたデータ行数。                                      |
| ZoneMapIndexFilterRows           | Zone Mapインデックスによってフィルタリングされたデータ行数。                             |

#### Exchange演算子

| メトリック           | 説明                                                   |
| ---------------- | ----------------------------------------------------- |
| PartType         | データ分布タイプ。有効な値: `UNPARTITIONED`、`RANDOM`、`HASH_PARTITIONED`、`BUCKET_SHUFFLE_HASH_PARTITIONED`。 |
| BytesSent        | 送信されたデータのサイズ。                                   |
| OverallThroughput | 全体のスループット。                                          |
| NetworkTime      | データパッケージの転送時間（受信後の処理時間を除く）。このメトリックの計算方法と例外の発生については、以下のFAQを参照してください。 |
| WaitTime         | 送信側のキューがいっぱいになるまでの待ち時間。                 |

#### Aggregate演算子

| メトリック              | 説明                                                   |
| --------------------- | ----------------------------------------------------- |
| GroupingKeys          | グルーピングキーの名前（GROUP BY列）。                       |
| AggregateFunctions    | 集約関数。                                                |
| AggComputeTime        | 集約関数によって消費された計算時間。                            |
| ExprComputeTime       | 式によって消費された計算時間。                               |
| HashTableSize         | ハッシュテーブルのサイズ。                                 |

#### Join演算子

| メトリック            | 説明                                  |
| ------------------- | ------------------------------------ |
| JoinPredicates      | JOIN操作の述語。                        |
| JoinType            | JOINタイプ。                           |
| BuildBuckets        | ハッシュテーブルのバケット数。               |
| BuildHashTableTime  | ハッシュテーブルの構築にかかった時間。         |
| ProbeConjunctEvaluateTime | Probe Conjunctにかかった時間。     |
| SearchHashTableTimer      | ハッシュテーブルの検索にかかった時間。 |

#### Window Function演算子

| メトリック        | 説明                                               |
| ----------------- | ------------------------------------------------- |
| ComputeTime       | ウィンドウ関数によって消費された計算時間。                    |
| PartitionKeys     | パーティションキーの名前（PARTITION BY列）。                  |
| AggregateFunctions | 集約関数。                                           |

#### Sort演算子

| メトリック  | 説明                                                |
| --------- | -------------------------------------------------- |
| SortKeys  | ソートキーの名前（ORDER BY列）。                        |
| SortType  | 結果のソートタイプ: すべての結果をリストアップするか、上位n件の結果をリストアップするか。 |

#### TableFunction演算子

| メトリック                   | 説明                                                       |
| -------------------------- | --------------------------------------------------------- |
| TableFunctionExecTime      | テーブル関数によって消費された計算時間。                          |
| TableFunctionExecCount     | テーブル関数が実行された回数。                                    |

#### Project演算子

| メトリック               | 説明                                                   |
| ----------------------  | ----------------------------------------------------- |
| ExprComputeTime         | 式によって消費された計算時間。                            |
| CommonSubExprComputeTime | 共通部分式によって消費された計算時間。                        |

#### LocalExchange演算子

| メトリック | 説明                                                            |
| -------- | -------------------------------------------------------------- |
| Type     | ローカルExchangeタイプ。有効な値: `Passthrough`、`Partition`、`Broadcast`。 |
| ShuffleNum | シャッフルの数。このメトリックは、`Type`が`Partition`の場合のみ有効です。 |

#### Hiveコネクタ

| メトリック        | 説明                                               |
| ----------------- | ------------------------------------------------- |
| ScanRanges       | スキャンされたタブレットの数。                          |
| ReaderInit       | Readerの初期化時間。                                |
```
| ColumnReadTime              | リーダーがデータを読み込み、解析するのに要した時間です。        |
| ExprFilterTime              | 式をフィルタリングするために使用される時間です。                       |
| RowsRead                    | 読み込まれたデータ行の数です。                                       |

#### 入力ストリーム

| メトリック                    | 説明                                                               |
| ------------------------- | ------------------------------------------------------------------------- |
| AppIOBytesRead            | アプリケーション層からのI/Oタスクによって読み込まれたデータサイズです。            |
| AppIOCounter              | アプリケーション層からのI/Oタスクの数です。                           |
| AppIOTime                 | アプリケーション層からのI/Oタスクがデータの読み込みに要した合計時間です。 |
| FSBytesRead               | ストレージシステムによって読み込まれたデータのサイズです。                              |
| FSIOCounter               | ストレージ層からのI/Oタスクの数です。                               |
| FSIOTime                  | ストレージ層がデータの読み込みに要した合計時間です。                    |

### オペレーターによる時間

- OlapScanおよびConnectorScanオペレーターの場合、それらの時間消費は `OperatorTotalTime + ScanTime` と同等です。スキャンオペレーターは非同期I/OスレッドプールでI/O操作を実行するため、ScanTime は非同期I/O時間を表します。
- Exchangeオペレーターの時間消費は、 `OperatorTotalTime + NetworkTime` と同等です。ExchangeオペレーターはbRPCスレッドプールでデータパッケージを送受信するため、NetworkTime はネットワーク転送に要した時間を表します。
- その他のすべてのオペレーターの時間コストは `OperatorTotalTime` です。

### メトリックの統合とMIN/MAX

パイプラインエンジンは並列計算エンジンです。各フラグメントは複数のマシンに分散して並列処理され、各マシン上のパイプラインは複数の同時インスタンスとして並行して実行されます。したがって、プロファイリング中には、StarRocksは同じメトリックをマージし、すべての同時インスタンスの中で各メトリックの最小値と最大値を記録します。

異なる種類のメトリックに対して異なる統合戦略が採用されています:

- 時間メトリックは平均値です。例:
  - `OperatorTotalTime` は、すべての同時インスタンスの平均時間コストを表します。
  - `__MAX_OF_OperatorTotalTime` はすべての同時インスタンスの中での最大時間コストです。
  - `__MIN_OF_OperatorTotalTime` はすべての同時インスタンスの中での最小時間コストです。

```SQL
             - OperatorTotalTime: 2.192us
               - __MAX_OF_OperatorTotalTime: 2.502us
               - __MIN_OF_OperatorTotalTime: 1.882us
```

- 時間ではないメトリックは合計されます。例:
  - `PullChunkNum` は、すべての同時インスタンスの総数を表します。
  - `__MAX_OF_PullChunkNum` はすべての同時インスタンスの中での最大値です。
  - `__MIN_OF_PullChunkNum` はすべての同時インスタンスの中での最小値です。

  ```SQL
                 - PullChunkNum: 146.66K (146660)
                   - __MAX_OF_PullChunkNum: 24.45K (24450)
                   - __MIN_OF_PullChunkNum: 24.435K (24435)
  ```

- すべての同時インスタンスの間で最小値と最大値を持たない特別なメトリックもあります（例: `DegreeOfParallelism`）。

#### MINとMAXの間の著しい違い

通常、MINとMAXの値で著しい違いがある場合、データがスキューしていることを示します。これは通常、集約やJOIN操作中に発生します。

```SQL
             - OperatorTotalTime: 2m48s
               - __MAX_OF_OperatorTotalTime: 10m30s
               - __MIN_OF_OperatorTotalTime: 279.170us
```

## テキストベースのプロファイル解析を実行

v3.1以降、StarRocksでは、よりユーザーフレンドリーなテキストベースのプロファイル解析機能が提供されています。この機能を使用すると、ボトルネックやクエリの最適化の機会を効率的に特定できます。

### 既存のクエリを分析

実行中または完了したクエリのプロファイルをその `QueryID` を使用して分析できます。

#### プロファイルの一覧

次のSQLステートメントを実行して、既存のプロファイルの一覧を表示できます:

```sql
SHOW PROFILELIST;
```

例:

```sql
MySQL > show profilelist;
+--------------------------------------+---------------------+-------+----------+--------------------------------------------------------------------------------------------------------------------------------------+
| QueryId                              | StartTime           | Time  | State    | Statement                                                                                                                            |
+--------------------------------------+---------------------+-------+----------+--------------------------------------------------------------------------------------------------------------------------------------+
| b8289ffc-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:27 | 86ms  | Finished | SELECT o_orderpriority, COUNT(*) AS order_count\nFROM orders\nWHERE o_orderdate >= DATE '1993-07-01'\n    AND o_orderdate < DAT ...  |
| b5be2fa8-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:23 | 67ms  | Finished | SELECT COUNT(*)\nFROM (\n    SELECT l_orderkey, SUM(l_extendedprice * (1 - l_discount)) AS revenue\n        , o_orderdate, o_sh ...  |
| b36ac9c6-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:19 | 320ms | Finished | SELECT COUNT(*)\nFROM (\n    SELECT s_acctbal, s_name, n_name, p_partkey, p_mfgr\n        , s_address, s_phone, s_comment\n    F ... |
| b037b245-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:14 | 175ms | Finished | SELECT l_returnflag, l_linestatus, SUM(l_quantity) AS sum_qty\n    , SUM(l_extendedprice) AS sum_base_price\n    , SUM(l_exten ...   |
| a9543cf4-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:02 | 40ms  | Finished | select count(*) from lineitem                                                                                                        |
+--------------------------------------+---------------------+-------+----------+--------------------------------------------------------------------------------------------------------------------------------------+
5 rows in set
Time: 0.006s


MySQL > show profilelist limit 1;
+--------------------------------------+---------------------+------+----------+-------------------------------------------------------------------------------------------------------------------------------------+
| QueryId                              | StartTime           | Time | State    | Statement                                                                                                                           |
+--------------------------------------+---------------------+------+----------+-------------------------------------------------------------------------------------------------------------------------------------+
| b8289ffc-3049-11ee-838f-00163e0a894b | 2023-08-01 16:59:27 | 86ms | Finished | SELECT o_orderpriority, COUNT(*) AS order_count\nFROM orders\nWHERE o_orderdate >= DATE '1993-07-01'\n    AND o_orderdate < DAT ... |
+--------------------------------------+---------------------+------+----------+-------------------------------------------------------------------------------------------------------------------------------------+
1 row in set
Time: 0.005s
```

このSQLステートメントにより、各クエリに関連付けられた `QueryId` を簡単に取得できます。`QueryId` は追加のプロファイル解析や調査にとって重要な識別子となります。

#### プロファイルの分析

`QueryId` を入手したら、特定のクエリについてより詳細な分析を実行できます。ANALYZE PROFILE ステートメントを使用すると、クエリのパフォーマンス特性や最適化に関する深い洞察が提供されます。

```sql
ANALYZE PROFILE FROM '<QueryId>' [, <plan_node_id>, ...]
```

デフォルトでは、解析の出力には各オペレーターの最も重要なメトリックのみが表示されます。ただし、1つ以上のプランノードのIDを指定することで、対応するメトリックを詳細に表示できます。この機能により、クエリのパフォーマンスをより網羅的に調査し、ターゲットの最適化を行うことができます。

例1: プランノードIDを指定せずにプロファイルを解析する:

![img](../assets/profile-16.png)

例2: プランノードのIDを指定してプロファイルを解析する:

![img](../assets/profile-17.png)

ANALYZE PROFILE ステートメントは、ランタイムプロファイルの解析と理解を向上させる手段を提供します。ブロックされた、実行中、完了など、異なるステータスを持つオペレーターを区別します。また、このステートメントは処理された行数に基づいてオペレーター全体の進捗状況および個々のオペレーターの進捗状況を包括的に表示し、クエリの実行とパフォーマンスについてより深く理解することができます。この機能は、StarRocksにおけるクエリのプロファイリングと最適化をさらに容易にします。

例3: 実行中のクエリのランタイムプロファイルを解析する:

![img](../assets/profile-20.png)

### シミュレートされたクエリを分析

指定されたクエリをシミュレートし、そのプロファイルを解析することもできます。これには、EXPLAIN ANALYZE ステートメントを使用します。

```sql
EXPLAIN ANALYZE <sql>
```

現在、EXPLAIN ANALYZE は2種類のSQLステートメント（クエリ（SELECT）ステートメントとINSERT INTOステートメント）をサポートしています。INSERT INTOステートメントのプロファイルをシミュレートして解析できますが、実際にデータは挿入されません。デフォルトではトランザクションは中止され、解析の過程でデータに意図しない変更が加えられないようになっています。

例1: 特定のクエリのプロファイルを解析する:

![img](../assets/profile-18.png)

例1: INSERT INTO操作のプロファイルを解析する:

![img](../assets/profile-19.png)

## クエリプロファイルを視覚化
StarRocksエンタープライズエディションのユーザーであれば、StarRocksマネージャーを使用してクエリプロファイルを視覚化できます。

**プロファイル概要** ページには、合計実行時間の`ExecutionWallTime`、I/Oメトリクス、ネットワーク伝送サイズ、CPUとI/O時間の割合など、いくつかのサマリーメトリクスが表示されます。

![img](../assets/profile-4.jpeg)

オペレーター（ノード）のカードをクリックすると、ページの右側にその詳細情報が表示されます。3つのタブがあります。

- **Node**: このオペレーターのコアメトリクス。
- **Node Detail**: このオペレーターのすべてのメトリクス。
- **Pipeline**: オペレーターが所属するパイプラインのメトリクス。これはスケジューリングに関係するため、このタブにはあまり注意を払う必要はありません。

![img](../assets/profile-5.jpeg)

### ボトルネックの特定

オペレーターが占める時間の割合が大きいほど、そのカードの色が濃くなります。これにより、クエリのボトルネックを簡単に特定できます。

![img](../assets/profile-6.jpeg)

### データが偏っていないか確認する

時間の大部分を取るオペレーターのカードをクリックし、その`MaxTime`と`MinTime`を確認します。通常、`MaxTime`と`MinTime`の間に顕著な違いがあると、データが偏っていることを示します。

次に、**Node Detail**タブをクリックし、メトリックに例外が表示されていないかを確認します。この例では、Aggregateオペレーターのメトリック`PushRowNum`がデータの偏りを示しています。

![img](../assets/profile-7.jpeg)

### パーティショニングまたはバケティング戦略が効果を発揮しているか確認する

`EXPLAIN <sql_statement>`を使用して対応するクエリプランを表示することで、パーティショニングまたはバケティング戦略が効果を発揮しているかを確認できます。

![img](../assets/profile-9.png)

### 正しいマテリアライズドビューが使用されているかどうかを確認する

対応するスキャンオペレーターをクリックし、**Node Detail**タブで`Rollup`フィールドを確認します。

![img](../assets/profile-10.jpeg)

### JOINプランが左右のテーブルに対して適切かどうかを確認する

通常、StarRocksはJOINの右テーブルとして小さいテーブルを選択します。クエリプロファイルが異なることが表示されると例外が発生します。

![img](../assets/profile-11.jpeg)

### JOINの分散タイプが正しいかどうかを確認する

Exchangeオペレーターはデータの分散タイプに従って3つのタイプに分類されます。

- `UNPARTITIONED`: ブロードキャスト。データは複数のBEにコピーされ、配布されます。
- `RANDOM`: ラウンドロビン。
- `HASH_PARTITIONED`および`BUCKET_SHUFFLE_HASH_PARTITIONED`: シャッフル。`HASH_PARTITIONED`と`BUCKET_SHUFFLE_HASH_PARTITIONED`の違いは、ハッシュコードを計算するために使用されるハッシュ関数にあります。

インナージョインの場合、右テーブルは`HASH_PARTITIONED`および`BUCKET_SHUFFLE_HASH_PARTITIONED`タイプ、または`UNPARTITIONED`タイプです。通常、右テーブルに100K行未満がある場合にのみ`UNPARTITIONED`タイプが採用されます。

次の例では、Exchangeオペレーターのタイプがブロードキャストですが、オペレーターによって送信されるデータのサイズが大幅に閾値を超えています。

![img](../assets/profile-12.jpeg)

### JoinRuntimeFilterが効果を発揮しているかどうかを確認する

JOINの右子がハッシュテーブルを構築している場合、ランタイムフィルタが作成されます。このランタイムフィルタは、左の子ツリーに送信され、可能であればスキャンオペレーターにプッシュダウンされます。スキャンオペレーターの**Node Detail**タブで`JoinRuntimeFilter`関連のメトリクスを確認できます。

![img](../assets/profile-13.jpeg)

## よくある質問

### なぜExchangeオペレーターのタイムコストが異常なのですか？

![img](../assets/profile-14.jpeg)

ExchangeオペレーターのタイムコストにはCPU時間とネットワーク時間の2つの部分が含まれます。ネットワーク時間はシステムクロックに依存します。ネットワーク時間は次のように計算されます。

1. 送信者は、パッケージを送信する前に`send_timestamp`を記録します。
2. 受信者は、bRPCインターフェースからパッケージを受信した後（受信後の処理時間は除外）、`receive_timestamp`を記録します。
3. 処理が完了した後、受信者は応答を送信し、ネットワークレイテンシを計算します。パッケージの送信レイテンシは`receive_timestamp`-`send_timestamp`に相当します。

異なるマシン間のシステムクロックが一貫しない場合、Exchangeオペレーターのタイムコストに例外が発生します。

### すべてのオペレーターの合計時間コストがクエリの実行時間よりかなり短いのはなぜですか？

原因: 高同時実行シナリオでは、いくつかのパイプラインドライバーがスケジュール可能であるにもかかわらず、キューに入れられるために時間内に処理されない場合があります。待機時間はオペレーターのメトリクスではなく、`PendingTime`、`ScheduleTime`、`IOTaskWaitTime`に記録されます。

例:

プロファイルから、`ExecutionWallTime`が約55ミリ秒であることがわかります。しかし、すべてのオペレーターの合計時間コストは10ミリ秒未満であり、`ExecutionWallTime`よりかなり短いです。

![img](../assets/profile-15.jpeg)