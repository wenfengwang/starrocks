---
displayed_sidebar: "Japanese"
---

# アーキテクチャ

StarRocksはシンプルなアーキテクチャを持っています。システム全体はフロントエンド（FE）とバックエンド（BE）またはコンピュートノード（CN）の2つのタイプのコンポーネントのみで構成されています。StarRocksは外部コンポーネントに依存せず、展開とメンテナンスを簡素化しています。ノードはサービス停止時間なしに水平にスケーリングすることができます。さらに、StarRocksはメタデータとサービスデータのレプリカメカニズムを持っており、データの信頼性を高め、単一障害点（SPOF）を効率的に防止します。

StarRocksはMySQLプロトコルに互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントから簡単にStarRocksに接続して、即座に価値ある洞察を得ることができます。

## アーキテクチャの進化

StarRocksは進化を続けるにつれて、システムアーキテクチャは元のストレージ-コンピュートカップルアーキテクチャ（共有なし）からストレージ-コンピュート分離アーキテクチャ（共有データ）へと移行しました。

- バージョン3.0より前のStarRocksでは、ストレージ-コンピュートカップルアーキテクチャを使用しています。BEはデータのストレージと計算の両方を担当しています。データアクセスと計算はローカルノードで行われ、データの移動を最小限に抑え、クエリのレイテンシを低減することで、超高速なクエリと分析体験を提供します。

- バージョン3.0以降、StarRocksはストレージ-コンピュート分離アーキテクチャを導入しました。データストレージはBEから分離され、BEはステートレスのCNノードにアップグレードされました。データはリモートオブジェクトストレージまたはHDFSに永続的に保存され、CNのローカルディスクはクエリの高速化のためにホットデータのキャッシュに使用されます。ストレージ-コンピュート分離アーキテクチャは、コンピュートノードの動的な追加と削除をサポートし、オンデマンドのスケーリングを実現します。

以下の図はアーキテクチャの進化を示しています。

![アーキテクチャの進化](../assets/architecture_evolution.png)

## ストレージ-コンピュートカップル

StarRocksは典型的なマルチパラレル処理（MPP）データベースとして、3.0より前のバージョンではストレージ-コンピュートカップルアーキテクチャを使用しています。このアーキテクチャでは、BEがデータのストレージと計算の両方を担当しています。BEモードのローカルデータへの直接アクセスにより、ローカル計算が可能となり、データの転送やコピーを回避し、超高速なクエリと分析パフォーマンスを提供します。このアーキテクチャはマルチレプリカのデータストレージをサポートし、高並行性クエリの処理能力を向上させ、データの信頼性を確保するために適しています。

### ノード

ストレージ-コンピュートカップルアーキテクチャでは、StarRocksは2つのタイプのノード、FEとBEで構成されています。

- FEはメタデータの管理と実行計画の構築を担当します。
- BEはクエリの実行とデータの保存を行います。BEはローカルストレージを使用してクエリを高速化し、マルチレプリカメカニズムを使用してデータの高い可用性を確保します。

### FE

FEはメタデータの管理、クライアント接続の管理、クエリの計画、クエリのスケジューリングを担当します。各FEはメモリに完全なメタデータのコピーを保存および維持し、FE間での無差別なサービスを保証します。FEはリーダー、フォロワー、オブザーバーとして動作することができます。フォロワーはPaxosのようなBDB JEプロトコルに基づいてリーダーを選出することができます。BDB JEはBerkeley DB Java Editionの略です。

| **FEの役割** | **メタデータの管理**                                               | **リーダー選出**                                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| リーダーFE      | リーダーFEはメタデータの読み書きを行います。フォロワーとオブザーバーFEはメタデータの読み取りのみが可能です。メタデータの書き込みリクエストはリーダーFEにルーティングされます。リーダーFEはメタデータを更新し、BDE JEを使用してメタデータの変更をフォロワーとオブザーバーFEに同期します。データの書き込みは、メタデータの変更がフォロワーFEの半数以上に同期された後にのみ成功と見なされます。 | リーダーFEはフォロワーFEから選出されます。リーダー選出を行うには、クラスタ内のフォロワーFEの半数以上がアクティブである必要があります。リーダーFEが失敗した場合、フォロワーFEは別のリーダー選出を開始します。 |
| フォロワーFE    | フォロワーはメタデータの読み取りのみが可能です。フォロワーはリーダーFEからログを同期し、再生してメタデータを更新します。 | フォロワーはリーダー選出に参加し、クラスタ内のフォロワーの半数以上がアクティブである必要があります。 |
| オブザーバーFE   | オブザーバーはリーダーFEからログを同期し、再生してメタデータを更新します。     | オブザーバーはクエリの同時実行性を向上させるために主に使用されます。オブザーバーはリーダー選出に参加せず、クラスタにリーダー選択の圧力を加えません。|

### BE

BEはデータの保存とSQLの実行を担当します。

- データの保存：BEは同等のデータの保存機能を持っています。FEは事前に定義されたルールに基づいてデータをBEに分散します。BEは受け入れたデータを変換し、必要な形式でデータを書き込み、データのインデックスを生成します。

- SQLの実行：SQLクエリが到着すると、FEはクエリの意味に従って論理的な実行計画にパースし、論理計画をBEで実行可能な物理的な実行計画に変換します。宛先データを保存しているBEがクエリを実行します。これにより、データの転送やコピーの必要性がなくなり、高いクエリパフォーマンスが実現されます。

### データ管理

StarRocksは列指向のデータベースシステムです。データの管理にはパーティショニングとバケット分割のメカニズムが使用されます。テーブルのデータはまず複数のパーティションに分割され、さらに複数のタブレットに分割されます。タブレットはStarRocksのデータ管理の基本的な論理単位です。各タブレットは複数のレプリカを持つことができ、異なるBEに保存することができます。タブレットの数を指定し、StarRocksにタブレットの管理を任せることができます。

パーティションとタブレットにより、テーブルのスキャンを減らし、クエリの同時実行性を高めることができます。レプリカにより、データのバックアップと復元が容易になり、データの損失を防ぎます。

以下の図では、テーブルが時間に基づいて4つのパーティションに分割されています。最初のパーティションのデータはさらに4つのタブレットに分割されます。各タブレットには3つのレプリカがあり、それぞれ異なるBEに保存されています。

![データ管理](../assets/data_manage.png)

1つのテーブルが複数のタブレットに分割されているため、StarRocksは1つのSQLステートメントをすべてのタブレットに並列処理することができます。これにより、複数の物理マシンとコアの計算能力を最大限に活用することができます。また、クエリの圧力を複数のノードにオフロードすることで、サービスの可用性を高めることができます。高い並行性を実現するために、必要に応じて物理マシンを追加することができます。

タブレットの分布は物理ノードに影響を受けません。BEの数が変更された場合（例：BEを追加または削除する場合）、実行中のサービスは中断することなく継続されます。ノードの変更により、タブレットの自動移行がトリガーされます。BEが追加されると、一部のタブレットはより均等なデータ分布のために新しいBEに自動的に移行されます。BEが削除されると、これらのBE上のタブレットは他のBEに自動的に移行され、レプリカの数は変わらないようになります。自動タブレット移行により、StarRocksクラスタの自動スケーリングを容易に実現し、手動のデータ再分配の必要性を排除します。

StarRocksはタブレットに対してマルチレプリカメカニズム（デフォルトで3つ）を使用しています。レプリカはデータの高い信頼性とサービスの可用性を保証します。1つのノードの障害は全体のサービスの可用性に影響を与えません。また、クエリの同時実行性を高めるためにレプリカの数を増やすこともできます。

### 制限事項

このアーキテクチャにはいくつかの制限事項があります：

- 成長コスト：ユーザーはストレージと計算をスケーリングする必要があり、望ましくないストレージコストが増加します。データ量が増えるにつれて、ストレージと計算リソースの需要が不均衡に増加し、リソースの効率が低下します。
- 複雑なアーキテクチャ：複数のレプリカ間でデータの一貫性を維持することは、システムの複雑さを増し、障害のリスクを高めます。
- 限られた弾力性：スケーリング操作によりデータの再バランスが発生し、ユーザーエクスペリエンスが満足のいくものにならない場合があります。

## ストレージ-コンピュート分離

新しいストレージ-コンピュート分離アーキテクチャでは、データのストレージ機能がBEから分離されます。BEは「コンピュートノード（CN）」と呼ばれるようになり、データの計算とホットデータのキャッシュのみを担当します。データは低コストで信頼性の高いリモートストレージシステム（例：Amazon S3、GCP、Azure Blob Storage、MinIOなどのS3互換ストレージ）に保存されます。キャッシュがヒットすると、クエリのパフォーマンスはストレージ-コンピュートカップルアーキテクチャと同等になります。CNノードは数秒で追加または削除することができます。このアーキテクチャはストレージコストを削減し、リソースの分離、高い弾力性とスケーラビリティを確保します。

ストレージ-コンピュート分離アーキテクチャは、ストレージ-コンピュートカップルアーキテクチャと同様にシンプルなアーキテクチャを維持しています。FEとCNの2つのタイプのノードで構成されています。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![共有データアーキテクチャ](../assets/architecture_shared_data.png)

### ノード

ストレージ-コンピュート分離アーキテクチャのFEは、ストレージ-コンピュートカップルアーキテクチャと同じ機能を提供します。

BEのストレージ機能は分離されます。ローカルストレージは共有ストレージに移行されます。BEノードはデータのロード、クエリの計算、キャッシュの管理などのタスクを担当するステートレスのCNノードにアップグレードされます。

### ストレージ

現在、StarRocksの共有データクラスタは2つのストレージソリューションをサポートしています：オブジェクトストレージ（例：AWS S3、Google GCS、Azure Blob Storage、MinIO）および従来のデータセンターに展開されたHDFS。この技術により、指定されたバケットまたはHDFSディレクトリ内のデータのストレージが統一されます。

共有データクラスタでは、データファイルの形式は共有なしクラスタ（ストレージとコンピュートがカップルされている）と同じままです。データはセグメントファイルに組織され、クラウドネイティブテーブルで再利用されるさまざまなインデックス技術が使用されます。

### キャッシュ

StarRocksの共有データクラスタは、データのストレージと計算を分離し、それぞれを独立してスケーリングすることで、コストを削減し、弾力性を向上させることができます。ただし、このアーキテクチャはクエリのパフォーマンスに影響を与える可能性があります。

この影響を軽減するために、StarRocksはメモリ、ローカルディスク、リモートストレージを含むマルチティアデータアクセスシステムを確立して、さまざまなビジネスニーズに対応しています。

ホットデータに対するクエリはキャッシュとローカルディスクを直接スキャンし、一方、コールドデータはオブジェクトストレージからローカルキャッシュにロードして、後続のクエリを高速化する必要があります。ホットデータをコンピュートユニットに近づけることで、StarRocksは本当の高性能な計算とコスト効果の高いストレージを実現しています。さらに、コールドデータへのアクセスはデータプリフェッチ戦略で最適化されており、クエリのパフォーマンスの制限を効果的に排除しています。

ユーザーはテーブル作成時にキャッシュを有効にするかどうかを決定することができます。キャッシュが有効になっている場合、データはローカルディスクとバックエンドオブジェクトストレージの両方に書き込まれます。クエリの際、CNノードはまずローカルディスクからデータを読み取ります。データが見つからない場合、バックエンドオブジェクトストレージから取得し、同時にローカルディスクにキャッシュされます。
