---
displayed_sidebar: "Japanese"
---

# プライマリキーテーブル

テーブルを作成する際に、プライマリキーとソートキーを別々に定義することができます。プライマリキーテーブルにデータがロードされると、StarRocksはデータを保存する前にソートキーに従ってデータをソートします。クエリは、同じプライマリキーを持つレコードのグループの中で最新のレコードを返します。ユニークキーテーブルとは異なり、プライマリキーテーブルではクエリ中に集計操作を必要とせず、述語とインデックスのプッシュダウンをサポートしています。そのため、プライマリキーテーブルはリアルタイムで頻繁にデータが更新される場合でも高いクエリパフォーマンスを提供することができます。

> **注意**
>
> - v3.0より前のバージョンでは、プライマリキーテーブルはプライマリキーとソートキーを切り離すことができません。
> - v3.1以降、StarRocksの共有データモードはプライマリキーテーブルをサポートしています。v3.1.4以降、StarRocksの共有データクラスターで作成されたプライマリキーテーブルは、ローカルディスクへのインデックスの永続化もサポートしています。

## シナリオ

- プライマリキーテーブルは、次のようなリアルタイムで頻繁にデータが更新されるシナリオに適しています：
  - **トランザクション処理システムからリアルタイムにストリームデータをStarRocksにロードする場合**。通常、トランザクション処理システムでは、挿入操作に加えて大量の更新操作と削除操作が行われます。トランザクション処理システムからデータをStarRocksに同期する必要がある場合は、プライマリキーテーブルを使用するテーブルを作成することをお勧めします。その後、Apache Flink®のCDCコネクタなどのツールを使用して、トランザクション処理システムのバイナリログをStarRocksに同期します。StarRocksはバイナリログを使用して、テーブルのデータをリアルタイムに追加、削除、更新します。これにより、データの同期が簡素化され、ユニークキーテーブルのマージオンリード（MoR）テーブルを使用する場合よりも3倍から10倍高いクエリパフォーマンスが提供されます。たとえば、flink-connector-starrocksを使用してデータをロードすることができます。詳細については、[flink-connector-starrocksを使用したデータのロード](../../loading/Flink-connector-starrocks.md)を参照してください。

  - **個々の列に対して更新操作を実行することで、複数のストリームを結合する**。ユーザープロファイリングなどのビジネスシナリオでは、データアナリストが使用する分析モデルを単純化し、多次元分析のパフォーマンスを向上させるために、フラットテーブルが好まれます。これらのシナリオでの上流データは、ショッピングアプリ、配送アプリ、銀行アプリなどのさまざまなアプリ、またはユーザーの異なるタグやプロパティを取得するための計算を実行する機械学習システムなどから提供される場合があります。プライマリキーテーブルは、個々の列の更新をサポートするため、これらのシナリオに適しています。各アプリやシステムは、自分自身のサービス範囲内のデータを保持する列のみを更新できます。これにより、リアルタイムのデータの追加、削除、更新が高いクエリパフォーマンスで実現されます。

- プライマリキーテーブルは、プライマリキーが占有するメモリ量を制御できるシナリオに適しています。

  StarRocksのストレージエンジンは、プライマリキーテーブルを使用する各テーブルのプライマリキーに対してインデックスを作成します。また、テーブルにデータをロードする際に、StarRocksはプライマリキーインデックスをメモリにロードします。そのため、プライマリキーテーブルは他の3つのテーブルタイプよりも大きなメモリ容量を必要とします。StarRocksは、プライマリキーを構成するフィールドの合計長さをエンコード後の127バイトに制限しています。

  テーブルが次の特性を持つ場合は、プライマリキーテーブルを使用することを検討してください：

  - テーブルには、頻繁に更新されるデータとあまり更新されないデータの両方が含まれています。頻繁に更新されるデータは最近の日数で頻繁に更新され、あまり更新されないデータはほとんど更新されません。たとえば、MySQLの注文テーブルをリアルタイムにStarRocksに同期して分析とクエリを行う必要があるとします。この例では、テーブルのデータは日ごとにパーティション分割され、最近の日に作成された注文に対してほとんどの更新が行われます。履歴的な注文は完了後に更新されなくなります。データロードジョブを実行する場合、プライマリキーインデックスはメモリにロードされず、最近更新された注文のインデックスエントリのみがメモリにロードされます。

    次の図に示すように、テーブルのデータは日ごとにパーティション分割され、最近の2つのパーティションのデータが頻繁に更新されます。

    ![Primary index -1](../../assets/3.2-1.png)

  - テーブルは、数百または数千の列で構成されるフラットテーブルです。プライマリキーはテーブルデータの一部であり、メモリの一部しか使用しません。たとえば、ユーザーステータスやプロファイルテーブルは、数千万のユーザーで構成される大量の列からなりますが、プライマリキーが占有するメモリ量は制御可能です。

    次の図に示すように、テーブルにはわずかな行しか含まれておらず、テーブルのプライマリキーはテーブルの一部のみを占めています。

    ![Primary index -2](../../assets/3.2.4-2.png)

### 原則

プライマリキーテーブルは、StarRocksが提供する新しいストレージエンジンに基づいて設計されています。プライマリキーテーブルのメタデータ構造と読み書きメカニズムは、ユニークキーテーブルとは異なります。そのため、プライマリキーテーブルは集計操作を必要とせず、述語とインデックスのプッシュダウンをサポートしています。これにより、クエリパフォーマンスが大幅に向上します。

ユニークキーテーブルはMoRポリシーを採用しています。MoRはデータの書き込みを効率化しますが、複数のデータバージョンのオンライン集計が必要です。また、マージオペレータは述語とインデックスのプッシュダウンをサポートしていません。その結果、クエリパフォーマンスが低下します。

プライマリキーテーブルは、各レコードに一意のプライマリキーがあることを保証するために、削除+挿入ポリシーを採用しています。つまり、StarRocksは、レコードの更新操作を削除操作と挿入操作に変換し、レコードを検索して削除マークを付け、新しいレコードを挿入します。

## テーブルの作成

例1：日次で注文を分析する必要があるとします。この例では、`orders`という名前のテーブルを作成し、`dt`と`order_id`をプライマリキーとして定義し、他の列をメトリック列として定義します。

```SQL
create table orders (
    dt date NOT NULL,
    order_id bigint NOT NULL,
    user_id int NOT NULL,
    merchant_id int NOT NULL,
    good_id int NOT NULL,
    good_name string NOT NULL,
    price int NOT NULL,
    cnt int NOT NULL,
    revenue int NOT NULL,
    state tinyint NOT NULL
) PRIMARY KEY (dt, order_id)
PARTITION BY RANGE(`dt`) (
    PARTITION p20210820 VALUES [('2021-08-20'), ('2021-08-21')),
    PARTITION p20210821 VALUES [('2021-08-21'), ('2021-08-22')),
    ...
    PARTITION p20210929 VALUES [('2021-09-29'), ('2021-09-30')),
    PARTITION p20210930 VALUES [('2021-09-30'), ('2021-10-01'))
) DISTRIBUTED BY HASH(order_id)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

> **注意**
>
> - テーブルを作成する際には、`DISTRIBUTED BY HASH`句を使用してバケット化列を指定する必要があります。詳細については、[バケット化](../Data_distribution.md#design-partitioning-and-bucketing-rules)を参照してください。
> - v2.5.7以降、StarRocksはテーブルを作成するかパーティションを追加する際に、バケットの数（BUCKETS）を自動的に設定することができます。バケットの数を手動で設定する必要はありません。詳細については、[バケットの数を決定する](../Data_distribution.md#determine-the-number-of-buckets)を参照してください。

例2：ユーザーの住所や最終アクティブ時間などの次元からリアルタイムにユーザーの行動を分析する必要があるとします。この場合、テーブルを作成する際に、`user_id`列をプライマリキーとし、`address`列と`last_active`列の組み合わせをソートキーとして定義することができます。

```SQL
create table users (
    user_id bigint NOT NULL,
    name string NOT NULL,
    email string NULL,
    address string NULL,
    age tinyint NULL,
    sex tinyint NULL,
    last_active datetime,
    property0 tinyint NOT NULL,
    property1 tinyint NOT NULL,
    property2 tinyint NOT NULL,
    property3 tinyint NOT NULL,
    ....
) PRIMARY KEY (user_id)
DISTRIBUTED BY HASH(user_id)
ORDER BY(`address`,`last_active`)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

## 使用上の注意

- テーブルのプライマリキーに関しては、次の点に注意してください：
  - プライマリキーは、`PRIMARY KEY`キーワードを使用して定義します。

  - プライマリキーは、一意制約が適用されている列に作成する必要があり、プライマリキーの列の名前を変更することはできません。

  - プライマリキーの列は、次のデータ型のいずれかである必要があります：BOOLEAN、TINYINT、SMALLINT、INT、BIGINT、LARGEINT、STRING、VARCHAR、DATE、DATETIME。ただし、プライマリキーの列は`NULL`として定義することはできません。

  - パーティション列とバケット列は、プライマリキーに参加する必要があります。

  - プライマリキーの列の数と総長さは、メモリを節約するために適切に設計する必要があります。メモリを占有するデータ型が少ない列を特定し、それらの列をプライマリキーとして定義することをお勧めします。このようなデータ型にはINTとBIGINTがあります。VARCHARデータ型の列をプライマリキーに参加させないようにしてください。

  - テーブルを作成する前に、プライマリキーの列のデータ型とテーブルの行数に基づいて、プライマリキーインデックスが占有するメモリ量を推定することをお勧めします。これにより、テーブルがメモリ不足になることを防ぐことができます。次の例では、プライマリキーインデックスが占有するメモリ量の計算方法を説明します：
    - DATEデータ型で4バイトを占有する`dt`列と、BIGINTデータ型で8バイトを占有する`id`列をプライマリキーとして定義するとします。この場合、プライマリキーは12バイトです。

    - テーブルには10,000,000行のホットデータが含まれ、3つのレプリカに格納されているとします。

    - 上記の情報に基づいて、プライマリキーインデックスが占有するメモリ量は次の式によって945 MBとなります：

      (12 + 9) x 10,000,000 x 3 x 1.5 = 945 (MB)

      上記の式では、`9`は行ごとの不変のオーバーヘッドであり、`1.5`はハッシュテーブルごとの平均的な追加のオーバーヘッドです。

- `enable_persistent_index`：プライマリキーインデックスをディスクに永続化し、メモリに保存することで、メモリを過剰に消費することを防ぐことができます。通常、プライマリキーインデックスは以前の1/10のメモリを占有することができます。テーブルを作成する際に、このプロパティを`PROPERTIES`で設定することができます。有効な値はtrueまたはfalseです。デフォルト値はfalseです。

  > - テーブル作成後にこのパラメータを変更する場合は、[ALTER TABLE](../../sql-reference/sql-statements/data-definition/ALTER_TABLE.md)の「テーブルのプロパティを変更する」の部分を参照してください。
  > - ディスクがSSDの場合は、このプロパティをtrueに設定することをお勧めします。
  > - v2.3.0以降、StarRocksはこのプロパティをサポートしています。
  > - v3.1以降、StarRocksの共有データモードはプライマリキーテーブルをサポートしています。v3.1.4以降、StarRocksの共有データクラスターで作成されたプライマリキーテーブルは、ローカルディスクへのインデックスの永続化もサポートしています。

- `ORDER BY`キーワードを使用して、ソートキーを任意の列の組み合わせとして指定することができます。

  > **注意**
  >
  > ソートキーが指定されている場合、プレフィックスインデックスはソートキーに基づいて構築されます。ソートキーが指定されていない場合、プレフィックスインデックスはプライマリキーに基づいて構築されます。

- ALTER TABLEを使用してテーブルスキーマを変更することができますが、次の制限があります：
  - プライマリキーの変更はサポートされていません。
  - ALTER TABLE ... ORDER BY ...を使用してソートキーを再割り当てすることはサポートされていますが、ソートキーの削除はサポートされていません。ソートキーの列のデータ型を変更することもサポートされていません。
  - 列の順序の調整はサポートされていません。

- v2.3.0以降、プライマリキーの列以外の列は、BITMAPおよびHLLデータ型をサポートしています。

- テーブルを作成する際に、プライマリキーの列以外の列に対してBITMAPインデックスまたはBloom Filterインデックスを作成することができます。

- v2.4.0以降、プライマリキーテーブルを基に非同期マテリアライズドビューを作成することができます。

## 次の手順

テーブルの作成後、ロードジョブを実行してデータをプライマリキーテーブルにロードすることができます。サポートされるロード方法の詳細については、[データのロードの概要](../../loading/Loading_intro.md)を参照してください。

プライマリキーテーブルのデータを更新する必要がある場合は、[ロードジョブを実行](../../loading/Load_to_Primary_Key_tables.md)するか、DMLステートメント（[UPDATE](../../sql-reference/sql-statements/data-manipulation/UPDATE.md)または[DELETE](../../sql-reference/sql-statements/data-manipulation/DELETE.md)）を実行することができます。これらの更新操作は、アトミック性を保証します。
