---
displayed_sidebar: "Japanese"
---

# テーブルデザインの理解

## 列指向ストレージ

![列指向ストレージ](../assets/3.1-1.png)

StarRocksでは、他のリレーショナルデータベースと同様に、テーブルは行と列で構成されています。各行はユーザーデータのレコードを保持し、各列のデータは同じタイプです。テーブルのすべての行は同じ数の列を持ちます。テーブルの列は次元列とメトリック列に分類されます。次元列はキーカラムとも呼ばれ、メトリック列は値カラムとも呼ばれます。次元列の値はデータのグループ化やソートに使用され、メトリック列の値はsum、count、min、max、hll_union_agg、bitmap_unionなどの関数を使用して蓄積することができます。

StarRocksはテーブルに対して列指向ストレージを使用しています。物理的には、列のデータはデータブロックに分割され、エンコードされ、圧縮され、そして永続的にディスク上に保存されます。論理的には、列のデータは、同じデータ型の要素からなる配列と比較することができます。行に保持されている列の値は、それぞれの配列内の要素として列の順序でリストアップされます。つまり、行に保持されている列の値は同じ配列インデックスを持ちます。配列インデックスは暗黙的であり、保存する必要はありません。テーブルのすべての行は、1つ以上の次元列で指定された順序でソートされます。ソートされたテーブル内の行の位置は、その行のシーケンス番号で表されます。

テーブルのクエリにおいて、特定の次元列に対して等価または範囲条件を指定する場合、StarRocksはソートされたデータの中から興味のある行を迅速に検索するためにバイナリ検索を実行することができます。例えば、`table1`という名前のテーブルからデータをクエリしたい場合、テーブルは`event_day`、`siteid`、`citycode`、`username`の4つの列で構成されており、そのうち`event_day`と`siteid`は次元列です。クエリ条件として`event_day = 2020-09-18`と`siteid = 2`を指定した場合、StarRocksはバイナリ検索を実行し、指定された範囲内のデータのみを処理する必要があります。なぜなら、`event_day`と`siteid`は次元列のプレフィックスを構成することができるからです。一方、`citycode = 4`と`username = Andy`をクエリ条件として指定した場合、StarRocksはバイナリ検索を実行することができず、テーブル全体のデータを処理する必要があります。なぜなら、`citycode`と`username`は次元列のプレフィックスを構成することができないからです。

## インデックス

StarRocksは、プレフィックスインデックスと列ごとのインデックスを使用して、興味のある行が占めるデータブロックの開始行を迅速に検索します。

次の図は、StarRocksのテーブルデザインがStarRocksのテーブル上のクエリを高速化する方法を示しています。

![インデックスの概要](../assets/3.1-2.png)

StarRocksのテーブルのデータは、次の3つの部分に分けられます。

- プレフィックスインデックス

  StarRocksは、1024行ごとにデータブロックとしてデータを保存し、プレフィックスインデックステーブルにエントリを保持します。各データブロックのプレフィックスインデックスエントリの内容は、データブロックの開始行の次元列で構成されるプレフィックスであり、長さは36バイトを超えることはありません。プレフィックスインデックスはスパースインデックスです。行をクエリする場合、StarRocksはプレフィックスインデックステーブルを検索して、行の次元列で構成されるプレフィックスを取得します。その後、StarRocksは興味のある行が占めるデータブロックの開始行のシーケンス番号を迅速に特定することができます。

- 列ごとのデータブロック

  StarRocksは、各列のデータを複数の64KBのデータブロックに分割します。各データブロックは独立してエンコードおよび圧縮され、最小のI/O単位としてディスクから読み取られたり、ディスクに書き込まれたりします。

- 列ごとのインデックス

  StarRocksは、各列に対して行番号インデックスを維持します。行番号インデックステーブルでは、列のデータブロックが列に保持されている行のシーケンス番号に1対1でマッピングされます。さらに、行番号インデックステーブルの各エントリは、特定の行番号にマッピングされるデータブロックの開始行番号、アドレス、および長さで構成されています。行をクエリする場合、StarRocksは行番号インデックステーブルを検索して、行のシーケンス番号にマッピングされるデータブロックのアドレスを取得します。その後、StarRocksはデータブロックを読み取り、行を特定します。

要約すると、StarRocksは次元列で構成される行のプレフィックスを使用して、テーブルの行を特定するために次の5つのステップを実行します。

1. プレフィックスインデックステーブルを検索して、興味のある行が占めるデータブロックの開始行のシーケンス番号を特定します。

2. 各次元列の行番号インデックステーブルを検索して、次元列のデータブロックを特定します。

3. データブロックを読み取ります。

4. データブロックを解凍およびデコードします。

5. データブロックを検索して、次元列インデックスがマッピングされる行を特定します。

## 高速処理

このセクションでは、StarRocksがデータを高速に処理するためのメカニズムについて紹介します。

### プリアグリゲーション

StarRocksでは、集計テーブルを提供しています。集計テーブルでは、テーブルの次元列の値が同じ行は1つの行に集約されます。集約から生成された新しい行では、各次元列の値は変わらず、各メトリック列の値は指定した集計関数によって集約され、メトリック列の新しい行の結果値が生成されます。プリアグリゲーションは、集計操作を高速化するのに役立ちます。

### パーティショニングとバケット分割

StarRocksの各テーブルは複数のタブレットに分割されます。各タブレットは複数のBE上のレプリカに格納されます。BEの数とタブレットの数は、計算リソースとデータサイズの変化に合わせて柔軟にスケーリングすることができます。クエリを開始すると、複数のBEが並列でタブレットを検索して興味のあるデータを迅速に特定することができます。また、タブレットのレプリカは複製および移行することができ、データの信頼性を高め、データの偏りを防ぎます。パーティショニングとバケット分割は、データの取得の効率と安定性を確保するのに役立ちます。

### マテリアライズドビュー

テーブルのプレフィックスインデックスは、テーブルの次元列のシーケンスに依存してクエリを高速化するのに役立ちます。ただし、次元列プレフィックスに含まれていない次元列を使用してクエリ述語を構築する場合、プレフィックスインデックスは機能しません。この場合、テーブルのためにマテリアライズドビューを作成することができます。マテリアライズドビューのデータは、テーブルのデータと同じように組織化され、保存されます。ただし、マテリアライズドビューには独自のプレフィックスインデックスを持つことができます。マテリアライズドビューのためにプレフィックスインデックスを作成する場合、適切な集計粒度、列数、および次元列の順序を指定して、よく使用されるクエリ条件がマテリアライズドビューのプレフィックスインデックステーブルの予想されるエントリにヒットするようにすることができます。

### 列ごとのインデックス

StarRocksは、Bloomフィルタ、ゾーンマップ、ビットマップインデックスなどの列ごとのインデックスをサポートしています。

- Bloomフィルタは、データブロックがクエリしたい値を含んでいるかどうかを判断するために使用されます。

- ゾーンマップは、指定された範囲内の値を特定するために使用されます。

- ビットマップインデックスは、ENUMデータ型の列内で指定されたクエリ条件を満たす行を特定するために使用されます。
