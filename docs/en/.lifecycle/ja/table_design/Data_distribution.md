データ分散

テーブルの作成時に適切なパーティショニングとバケット分割を設定することで、均等なデータ分散を実現することができます。均等なデータ分散とは、データを特定のルールに従ってサブセットに分割し、異なるノードに均等に分散させることを意味します。これにより、スキャンするデータ量を減らし、クラスタの並列処理能力を最大限に活用することができ、クエリのパフォーマンスを向上させることができます。

> **注意**
>
> - v3.1以降、テーブルの作成やパーティションの追加時にDISTRIBUTED BY句でバケットキーを指定する必要はありません。StarRocksはランダムバケット分割をサポートしており、データをランダムにすべてのバケットに分散させることができます。詳細については、[ランダムバケット分割](#random-bucketing-since-v31)を参照してください。
> - v2.5.7以降、テーブルの作成やパーティションの追加時にバケットの数を手動で設定することができます。StarRocksはバケットの数（BUCKETS）を自動的に設定することもできます。ただし、StarRocksがバケットの数を自動的に設定した後でもパフォーマンスが期待通りでない場合や、バケット分割のメカニズムに詳しい場合は、[バケットの数を手動で設定](#determine-the-number-of-buckets)することもできます。

## 分散方法

### 一般的な分散方法

現代の分散データベースシステムでは、一般的に次の基本的な分散方法が使用されます：Round-Robin、Range、List、およびHash。

![データ分散方法](../assets/3.3.2-1.png)

- **Round-Robin**：データをサイクリックに異なるノードに分散します。
- **Range**：パーティショニング列の値の範囲に基づいてデータを異なるノードに分散します。図に示すように、範囲[1-3]と[4-6]は異なるノードに対応しています。
- **List**：パーティショニング列の離散値に基づいてデータを異なるノードに分散します。各離散値はノードにマップされ、複数の異なる値が同じノードにマップされる場合があります。
- **Hash**：ハッシュ関数に基づいてデータを異なるノードに分散します。

より柔軟なデータパーティショニングを実現するために、上記のデータ分散方法のいずれかを使用するだけでなく、特定のビジネス要件に基づいてこれらの方法を組み合わせることもできます。一般的な組み合わせには、Hash+Hash、Range+Hash、およびHash+Listがあります。

### StarRocksでの分散方法

StarRocksは、データ分散方法を個別にまたは複合して使用することができます。

> **注意**
>
> 一般的な分散方法に加えて、StarRocksはランダム分散もサポートしており、バケット分割の設定を簡素化することができます。

また、StarRocksは2段階のパーティショニング+バケット分割方式を実装してデータを分散します。

- 第1段階はパーティショニングです：テーブル内のデータをパーティションに分割することができます。サポートされているパーティショニング方法は、式パーティショニング、範囲パーティショニング、およびリストパーティショニングです。または、パーティションを使用しないことも選択できます（テーブル全体を1つのパーティションと見なす）。
- 第2段階はバケット分割です：パーティション内のデータをさらに小さなバケットに分散する必要があります。サポートされているバケット分割方法は、ハッシュとランダムの2つです。

| **分散方法**         | **パーティショニングとバケット分割方法**                        | **説明**                                              |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ランダム分散       | ランダムバケット分割                                             | テーブル全体を1つのパーティションと見なします。テーブル内のデータはランダムに異なるバケットに分散されます。これはデフォルトのデータ分散方法です。 |
| ハッシュ分散         | ハッシュバケット分割                                               | テーブル全体を1つのパーティションと見なします。テーブル内のデータは、ハッシュ関数を使用してデータのバケットキーのハッシュ値に基づいて対応するバケットに分散されます。 |
| 範囲+ランダム分散 | <ol><li>式パーティショニングまたは範囲パーティショニング </li><li>ランダムバケット分割 </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が含まれる範囲に基づいて対応するパーティションに分散されます。 </li><li>パーティション内のデータは、異なるバケットにランダムに分散されます。 </li></ol> |
| 範囲+ハッシュ分散   | <ol><li>式パーティショニングまたは範囲パーティショニング</li><li>ハッシュバケット分割 </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が含まれる範囲に基づいて対応するパーティションに分散されます。</li><li>パーティション内のデータは、データのバケットキーのハッシュ値に基づいて対応するバケットに分散されます。</li></ol> |
| リスト+ランダム分散  | <ol><li>式パーティショニングまたは範囲パーティショニング</li><li>ランダムバケット分割 </li></ol> | <ol><li>テーブル内のデータは、パーティション列の値が含まれる範囲に基づいて対応するパーティションに分散されます。</li><li>パーティション内のデータは、異なるバケットにランダムに分散されます。</li></ol> |
| リスト+ハッシュ分散    | <ol><li>式パーティショニングまたはリストパーティショニング</li><li>ハッシュバケット分割 </li></ol> | <ol><li>テーブル内のデータは、パーティショニング列の値が属する値リストに基づいてパーティションに分割されます。</li><li>パーティション内のデータは、データのバケットキーのハッシュ値に基づいて対応するバケットに分散されます。</li></ol> |

- **ランダム分散**

  テーブルの作成時にパーティショニングとバケット分割方法を設定しない場合、デフォルトでランダム分散が使用されます。この分散方法は、Duplicate Keyテーブルを作成するためにのみ使用できます。

  ```SQL
  CREATE TABLE site_access1 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY (event_day,site_id,pv);
  -- パーティショニングとバケット分割方法が設定されていないため、デフォルトでランダム分散が使用されます。
  ```

- **ハッシュ分散**

  ```SQL
  CREATE TABLE site_access2 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code SMALLINT,
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY (event_day, site_id, city_code, user_name)
  -- バケット分割方法としてハッシュ分割を使用し、バケットキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day,site_id); 
  ```

- **範囲+ランダム分散**（この分散方法は、Duplicate Keyテーブルを作成するためにのみ使用できます。）

  ```SQL
  CREATE TABLE site_access3 (
      event_day DATE,
      site_id INT DEFAULT '10', 
      pv BIGINT DEFAULT '0' ,
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT ''
  )
  DUPLICATE KEY(event_day,site_id,pv)
  -- パーティショニング方法として式パーティショニングを使用し、時間関数式を設定します。
  -- 範囲パーティショニングも使用できます。
  PARTITION BY date_trunc('day', event_day);
  -- バケット分割方法が設定されていないため、デフォルトでランダムバケット分割が使用されます。
  ```

- **範囲+ハッシュ分散**

  ```SQL
  CREATE TABLE site_access4 (
      event_day DATE,
      site_id INT DEFAULT '10',
      city_code VARCHAR(100),
      user_name VARCHAR(32) DEFAULT '',
      pv BIGINT SUM DEFAULT '0'
  )
  AGGREGATE KEY(event_day, site_id, city_code, user_name)
  -- パーティショニング方法として式パーティショニングを使用し、時間関数式を設定します。
  -- 範囲パーティショニングも使用できます。
  PARTITION BY date_trunc('day', event_day)
  -- バケット分割方法としてハッシュ分割を使用し、バケットキーを指定する必要があります。
  DISTRIBUTED BY HASH(event_day, site_id);
  ```

#### パーティショニング

パーティショニング方法は、テーブルを複数のパーティションに分割します。パーティショニングは、パーティションキーに基づいてテーブルを異なる管理単位（パーティション）に分割するために主に使用されます。各パーティションには、バケットの数、ホットデータとコールドデータの格納戦略、ストレージメディアのタイプ、およびレプリカの数など、ストレージ戦略を設定することができます。StarRocksでは、クラスタ内で異なるタイプのストレージメディアを使用することができます。たとえば、クエリのパフォーマンスを向上させるために最新のデータをSSDに保存し、ストレージコストを削減するために過去のデータをSATAハードドライブに保存することができます。

| **パーティショニング方法**                   | **シナリオ**                                                    | **パーティションの作成方法**               |
| ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| 式パーティショニング（推奨） | 以前は自動パーティショニングとして知られていました。このパーティショニング方法は、より柔軟で使いやすくなっています。連続する日付範囲や列挙値に基づいてデータをクエリや管理する場合など、ほとんどのシナリオに適しています。 | データのロード時に自動的に作成されます |
| 範囲パーティショニング                    | 典型的なシナリオは、単純で順序のあるデータを格納し、連続する日付/数値の範囲に基づいて頻繁にクエリや管理を行うことです。たとえば、特定の場合では、過去のデータを月ごとにパーティション分割し、最新のデータを日ごとにパーティション分割する必要があります。 | 手動で、動的に、または一括で作成されます |
| リストパーティショニング                     | 列挙値に基づいてデータをクエリや管理する場合で、パーティションには各パーティショニング列の異なる値を含める必要がある場合に適しています。たとえば、国と都市に基づいて頻繁にデータをクエリや管理する場合、この方法を使用して、パーティション化列として`city`を選択することができます。したがって、1つのパーティションには同じ国に属する複数の都市のデータを格納することができます。 | 手動で作成されます                           |

##### パーティショニング列と粒度の選択方法

- 適切なパーティショニング列を選択することで、クエリ時のスキャンデータ量を効果的に削減することができます。ほとんどのビジネスシステムでは、期限切れのデータの削除によって引き起こされる特定の問題を解決するために、時間に基づいてパーティショニングが一般的に採用されています。この場合、式パーティショニングまたは範囲パーティショニングを使用し、時間列をパーティショニング列として指定することができます。さらに、データが列挙値に基づいて頻繁にクエリや管理される場合は、式パーティショニングまたはリストパーティショニングを使用し、これらの値を含む列をパーティショニング列として指定することができます。
- パーティショニングの粒度を選択する際には、データのボリューム、クエリパターン、およびデータ管理の粒度などの要素を考慮する必要があります。
  - 例1：テーブルの月間データボリュームが小さい場合、月ごとにパーティション分割することで、メタデータの量をパーティション分割することで削減し、メタデータ管理とスケジューリングのリソース消費を削減することができます。
  - 例2：テーブルの月間データボリュームが大きく、クエリで特定の日のデータをリクエストすることが多い場合、日ごとにパーティション分割することで、クエリ時のスキャンデータ量を効果的に削減することができます。
  - 例3：データが毎日期限切れになる必要がある場合は、日ごとにパーティション分割することをおすすめします。

#### バケット分割

バケット分割方法は、パーティション内のデータを複数のバケットに分割します。バケット内のデータはタブレットと呼ばれます。

サポートされているバケット分割方法は、[ランダムバケット分割](#random-bucketing-since-v31)（v3.1以降）と[ハッシュバケット分割](#hash-bucketing)です。

- ランダムバケット分割：テーブルの作成やパーティションの追加時にバケットキーを設定する必要はありません。パーティション内のデータはランダムに異なるバケットに分散されます。
- ハッシュバケット分割：テーブルの作成やパーティションの追加時にバケットキーを指定する必要があります。同じパーティション内のデータは、バケットキーの値に基づいてバケットに分割され、バケットキーの値が同じ行は対応するユニークなバケットに分散されます。

バケットの数：デフォルトでは、StarRocksはバケットの数を自動的に設定します（v2.5.7以降）。また、バケットの数を手動で設定することもできます。詳細については、[バケットの数を決定する](#determine-the-number-of-buckets)を参照してください。

## パーティションの作成と管理

### パーティションの作成

#### 式パーティショニング（推奨）

> **注意**
>
> v3.1以降、StarRocksの[共有データモード](../deployment/shared_data/s3.md)は時間関数式をサポートしており、列式はサポートしていません。

v3.0以降、StarRocksは[式パーティショニング](./expression_partitioning.md)（以前は自動パーティショニングとして知られていました）をサポートしており、より柔軟で使いやすくなっています。このパーティショニング方法は、連続する日付範囲や列挙値に基づいてデータをクエリや管理するなど、ほとんどのシナリオに適しています。

テーブル作成時にパーティション式（時間関数式または列式）を設定するだけで、StarRocksはデータのロード時に自動的にパーティションを作成します。事前に多数のパーティションを手動で作成する必要はなく、動的パーティションプロパティを設定する必要もありません。

#### 範囲パーティショニング

範囲パーティショニングは、時間系列データ（日付またはタイムスタンプ）や連続した数値データなど、単純で連続したデータを格納するのに適しています。また、連続する日付/数値の範囲に基づいて頻繁にクエリや管理を行う場合にも使用できます。また、過去のデータを月ごとにパーティション分割し、最新のデータを日ごとにパーティション分割する必要がある特定の場合にも適用できます。

StarRocksは、明示的に定義された各パーティションの範囲の明示的なマッピングに基づいてデータを対応するパーティションに格納します。

##### 動的パーティショニング

[動的パーティショニング](./dynamic_partitioning.md)関連のプロパティは、テーブル作成時に設定します。StarRocksは、データの新しいパーティションを事前に自動的に作成し、期限切れのパーティションを削除してデータの新鮮さを確保し、パーティションのタイムツーライブ（TTL）管理を実現します。

式パーティショニングが提供する自動パーティション作成機能とは異なり、動的パーティショニングはプロパティに基づいて定期的に新しいパーティションを作成し、新しいデータがこれらのパーティションに属していない場合は、ロードジョブに対してエラーが返されます。ただし、式パーティショニングが提供する自動パーティション作成機能は、常にロードされたデータに基づいて対応する新しいパーティションを作成することができます。

##### 手動でパーティションを作成する

適切なパーティショニングキーを使用することで、クエリ時のスキャンデータ量を効果的に削減することができます。現在、パーティショニングキーとしては、日付または整数型の列のみを選択できます。ビジネスシナリオでは、パーティショニングキーは通常、データ管理の観点から選択されます。一般的なパーティショニング列には、日付または場所を表す列などがあります。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

##### 一括で複数のパーティションを作成する

テーブル作成後、ALTER TABLEステートメントを使用して一括で複数のパーティションを作成することができます。構文は、テーブル作成時に一括で複数のパーティションを作成する場合と似ています。`START()`と`END()`で一括で作成されるすべてのパーティションの開始日と終了日を指定し、`EVERY()`でパーティションの増分値を指定します。

```SQL
ALTER TABLE site_access 
ADD PARTITIONS START ("2021-01-04") END ("2021-01-06") EVERY (INTERVAL 1 DAY);
```

#### パーティションの削除

次のステートメントは、テーブル`site_access`からパーティション`p1`を削除します。

> **注意**
>
> この操作は、パーティション内のデータをすぐに削除しません。データは一定期間（デフォルトでは1日）トラッシュに保持されます。パーティションが誤って削除された場合は、[RECOVER](../sql-reference/sql-statements/data-definition/RECOVER.md)コマンドを使用してパーティションとそのデータを復元することができます。

```SQL
ALTER TABLE site_access
DROP PARTITION p1;
```

#### パーティションの復元

次のステートメントは、テーブル`site_access`にパーティション`p1`とそのデータを復元します。

```SQL
RECOVER PARTITION p1 FROM site_access;
```

#### パーティションの表示

次のステートメントは、テーブル`site_access`のすべてのパーティションの詳細を返します。

```SQL
SHOW PARTITIONS FROM site_access;
```

## バケット分割の設定

### ランダムバケット分割（v3.1以降）

StarRocksは、パーティション内のデータをランダムにすべてのバケットに分散します。データサイズが小さく、クエリのパフォーマンス要件が比較的低いシナリオに適しています。バケット分割方法を設定しない場合、StarRocksはデフォルトでランダムバケット分割を使用し、バケットの数を自動的に設定します。

ただし、大量のデータをクエリし、特定の列をフィルタ条件として頻繁に使用する場合、ランダムバケット分割によるクエリのパフォーマンスが最適でない場合があります。そのようなシナリオでは、[ハッシュバケット分割](#hash-bucketing)を使用することをおすすめします。これらの列をクエリのフィルタ条件として使用する場合、クエリがヒットした一部のバケットのみをスキャンおよび計算する必要があり、クエリのパフォーマンスを大幅に向上させることができます。

#### 制限事項

- ランダムバケット分割は、Duplicate Keyテーブルを作成するためにのみ使用できます。
- ランダムバケット分割のテーブルは、[共有データモード](../using_starrocks/Colocate_join.md)の[コロケーショングループ](../using_starrocks/Colocate_join.md)に所属することはできません。
- [Spark Load](../loading/SparkLoad.md)を使用してランダムバケット分割のテーブルにデータをロードすることはできません。

次のCREATE TABLEの例では、`DISTRIBUTED BY xxx`ステートメントが使用されていないため、StarRocksはデフォルトでランダムバケット分割を使用し、バケットの数を自動的に設定します。

```SQL
CREATE TABLE site_access1(
    event_day DATE,
    site_id INT DEFAULT '10', 
    pv BIGINT DEFAULT '0' ,
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT ''
)
DUPLICATE KEY(event_day,site_id,pv);
```

### ハッシュバケット分割

StarRocksは、ハッシュバケット分割を使用して、パーティション内のデータをバケットにサブディバイドすることができます。ハッシュバケット分割では、ハッシュ関数がデータのバケットキーの値を入力として受け取り、ハッシュ値を計算します。データはハッシュ値とバケットのマッピングに基づいて対応するバケットに格納されます。

#### 利点

- クエリのパフォーマンスが向上します：バケットキーの値が同じ行は同じバケットに格納されるため、クエリ時のスキャンデータ量が削減されます。
- 均等なデータ分散：カーディナリティ（一意の値の数）が高い列をバケットキーとして選択することで、データをより均等にバケットに分散させることができます。

#### バケットキーの選択方法

バケットキーとして次の2つの要件を満たす列を選択することをおすすめします。

- IDなどのカーディナリティが高い列
- クエリのフィルタ条件として頻繁に使用される列

ただし、両方の要件を満たす列がない場合は、クエリの複雑さに応じてバケットキーを決定する必要があります。

- クエリが複雑な場合は、データが可能な限り均等にすべてのバケットに分散するように、カーディナリティが高い列をバケットキーとして選択することをおすすめします。これにより、クラスタのリソース利用率が向上します。
- クエリが比較的単純な場合は、クエリの効率を向上させるために、クエリのフィルタ条件として頻繁に使用される列をバケットキーとして選択することをおすすめします。

1つのバケットキーでパーティションデータをすべてのバケットに均等に分散できない場合は、複数のバケットキーを選択することもできます。ただし、3つ以上の列を使用しないことをおすすめします。

#### 注意事項

- **テーブルを作成する際には、バケットキーを指定する必要があります**。
- バケットキーのデータ型はINTEGER、DECIMAL、DATE/DATETIME、またはCHAR/VARCHAR/STRINGである必要があります。
- バケットキーは指定した後に変更することはできません。

#### 例

次の例では、`site_id`をバケットキーとして使用して`site_access`テーブルを作成します。また、`site_access`テーブルのデータをクエリする際には、データがよくフィルタ条件として使用されるサイトでフィルタリングされることがよくあります。`site_id`をバケットキーとして使用することで、クエリ中の関係のないバケットの数を大幅に削減することができます。

```SQL
CREATE TABLE site_access(
    event_day DATE,
    site_id INT DEFAULT '10',
    city_code VARCHAR(100),
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
DISTRIBUTED BY HASH(site_id);
```

```
user_name VARCHAR(32) DEFAULT '',
pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(event_day, site_id, city_code, user_name)
PARTITION BY RANGE(event_day)
(
    PARTITION p1 VALUES LESS THAN ("2020-01-31"),
    PARTITION p2 VALUES LESS THAN ("2020-02-29"),
    PARTITION p3 VALUES LESS THAN ("2020-03-31")
)
DISTRIBUTED BY HASH(site_id);
```

テーブル`site_access`の各パーティションは10個のバケットを持っていると仮定します。次のクエリでは、10個のバケットのうち9個がプルーニングされるため、StarRocksは`site_access`テーブルのデータの1/10のみをスキャンする必要があります。

```SQL
select sum(pv)
from site_access
where site_id = 54321;
```

しかし、`site_id`が均等に分布しておらず、多くのクエリがわずかなサイトのデータのみを要求する場合、1つのバケット列のみを使用するとデータの偏りが生じ、システムのパフォーマンスのボトルネックになる可能性があります。この場合、複数のバケット列を使用することができます。例えば、次のステートメントでは`site_id`と`city_code`をバケット列として使用しています。

```SQL
CREATE TABLE site_access
(
    site_id INT DEFAULT '10',
    city_code SMALLINT,
    user_name VARCHAR(32) DEFAULT '',
    pv BIGINT SUM DEFAULT '0'
)
AGGREGATE KEY(site_id, city_code, user_name)
DISTRIBUTED BY HASH(site_id,city_code);
```

実際のところ、ビジネスの特性に基づいて1つまたは2つのバケット列を使用することができます。1つのバケット列`site_id`を使用することは、データノード間のデータ交換を減らすため、短いクエリには非常に有益であり、クラスタ全体のパフォーマンスを向上させることができます。一方、2つのバケット列`site_id`と`city_code`を採用することは、長いクエリには有利であり、分散クラスタ全体の並列性を活用してパフォーマンスを大幅に向上させることができます。

> **注意**
>
> - 短いクエリは少量のデータをスキャンし、単一のノードで完了することができます。
> - 長いクエリは大量のデータをスキャンし、分散クラスタの複数のノードで並列スキャンすることにより、パフォーマンスを大幅に向上させることができます。

### バケットの数を決定する

バケットは、StarRocksでデータファイルが実際にどのように組織されているかを反映しています。

- テーブル作成時にバケットの数を設定する方法

  - 方法1: バケットの数を自動的に設定する（推奨）

    - ハッシュバケット設定のテーブル

      StarRocksはv2.5.7以降、テーブル作成時にパーティションごとにマシンリソースとデータ量に基づいてバケットの数を自動的に設定することができます。
      > **注意**
      >
      > パーティションの生データサイズが100GBを超える場合、バケットの数を手動で設定することをお勧めします。

      例:

      ```sql
      CREATE TABLE site_access (
          site_id INT DEFAULT '10',
          city_code SMALLINT,
          user_name VARCHAR(32) DEFAULT '',
          pv BIGINT SUM DEFAULT '0')
      AGGREGATE KEY(site_id, city_code, user_name)
      DISTRIBUTED BY HASH(site_id,city_code); -- バケットの数を設定する必要はありません
      ```

    - ランダムバケット設定のテーブル

      StarRocksはv2.5.7以降、テーブル作成時にパーティションごとにマシンリソースとデータ量に基づいてバケットの数を自動的に設定することができます。v3.2.0以降、StarRocksはバケットの数を自動的に設定するロジックをさらに最適化しました。テーブル作成時だけでなく、データのロード中にもクラスタの容量とロードされたデータのボリュームに基づいて、パーティションごとのバケットの数を**動的に増やす**ことができます。これにより、パーティションの作成が容易になるだけでなく、バルクロードのパフォーマンスも向上します。
      > **注意**
      >
      > バケットのサイズはデフォルトで`1024 * 1024 * 1024 B`（1GB）です。テーブルを作成する際には、`PROPERTIES ("bucket_size"="xxx")`でバケットのサイズを指定することができます。最大バケットサイズは4GBです。

      例:

      ```SQL
      CREATE TABLE site_access1 (
          event_day DATE,
          site_id INT DEFAULT '10', 
          pv BIGINT DEFAULT '0' ,
          city_code VARCHAR(100),
          user_name VARCHAR(32) DEFAULT ''
      )
      DUPLICATE KEY (event_day,site_id,pv)
      ;-- バケットの数とバケットのキーを設定する必要はありません
      ```

    テーブルを作成した後、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md)を実行して、StarRocksが各パーティションに設定したバケットの数を表示することができます。ハッシュバケット設定のテーブルの場合、各パーティションのバケットの数は**固定**です。

    ランダムバケット設定のテーブルの場合、各パーティションのバケットの数は**動的に変更**されることがあります。そのため、返される結果は新しいパーティションの**現在の**バケットの数を表示します。
    > **注意**
    >
    > このテーブルタイプでは、パーティション内の実際の階層は次のようになります: パーティション > サブパーティション > バケット。バケットの数を増やすために、StarRocksは実際には一定数のバケットを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS`ステートメントは、同じパーティション名の複数のデータ行を返す場合がありますが、これは同じパーティション内のサブパーティションの情報を示しています。

  - 方法2: バケットの数を手動で設定する

     StarRocksはv2.4.0以降、クエリ中に複数のスレッドを使用してテーブルットを並列でスキャンすることができるため、スキャンパフォーマンスがテーブルの数に依存しなくなります。おおよそ各テーブルに10GBの生データが含まれるようにすることをお勧めします。バケットの数を手動で設定する場合は、テーブルの各パーティションのデータ量を推定し、その後テーブルットの数を決定することができます。

     テーブルットで並列スキャンを有効にするには、システム全体で`enable_tablet_internal_parallel`パラメータが`TRUE`に設定されていることを確認してください（`SET GLOBAL enable_tablet_internal_parallel = true;`）。

    ```SQL
    CREATE TABLE site_access (
        site_id INT DEFAULT '10',
        city_code SMALLINT,
        user_name VARCHAR(32) DEFAULT '',
        pv BIGINT SUM DEFAULT '0')
    AGGREGATE KEY(site_id, city_code, user_name)
    -- パーティションにロードする生データの量が300GBであると仮定します。
    -- 各テーブルットに10GBの生データを含めることをお勧めしますので、バケットの数を30に設定することができます。
    DISTRIBUTED BY HASH(site_id,city_code) BUCKETS 30;
    ```

- 新しいパーティションを追加する際のバケットの数の設定方法

  - 方法1: バケットの数を自動的に設定する（推奨）
    - ハッシュバケット設定のテーブル

      StarRocksはv2.5.7以降、パーティション作成時にマシンリソースとデータ量に基づいてバケットの数を自動的に設定することができます。
      > **注意**
      >
      > パーティションの生データサイズが100GBを超える場合、バケットの数を手動で設定することをお勧めします。

    - ランダムバケット設定のテーブル

      StarRocksはv2.5.7以降、パーティション作成時にマシンリソースとデータ量に基づいてバケットの数を自動的に設定することができます。v3.2.0以降、StarRocksはバケットの数を自動的に設定するロジックをさらに最適化しました。パーティション作成時だけでなく、データのロード中にもクラスタの容量とロードされたデータのボリュームに基づいて、パーティションごとのバケットの数を**動的に増やす**ことができます。これにより、テーブルの作成が容易になるだけでなく、バルクロードのパフォーマンスも向上します。
      > **注意**
      >
      > バケットのサイズはデフォルトで`1024 * 1024 * 1024 B`（1GB）です。パーティションを追加する際には、`PROPERTIES ("bucket_size"="xxx")`でバケットのサイズを指定することができます。最大バケットサイズは4GBです。

    パーティションを追加した後、[SHOW PARTITIONS](../sql-reference/sql-statements/data-manipulation/SHOW_PARTITIONS.md)を実行して、新しいパーティションにStarRocksが設定したバケットの数を表示することができます。ハッシュバケット設定のテーブルの場合、新しいパーティションのバケットの数は**固定**です。
    ランダムバケット設定のテーブルの場合、新しいパーティションのバケットの数は**動的に変更**されることがあります。そのため、返される結果は新しいパーティションの**現在の**バケットの数を表示します。
    > **注意**
    >
    > このテーブルタイプでは、パーティション内の実際の階層は次のようになります: パーティション > サブパーティション > バケット。バケットの数を増やすために、StarRocksは実際には一定数のバケットを含む新しいサブパーティションを追加します。その結果、`SHOW PARTITIONS`ステートメントは、同じパーティション名の複数のデータ行を返す場合がありますが、これは同じパーティション内のサブパーティションの情報を示しています。

  - 方法2: バケットの数を手動で設定する

    新しいパーティションを追加する際にバケットの数を手動で指定することもできます。新しいパーティションのバケットの数を計算するには、前述のテーブル作成時にバケットの数を手動で設定する場合と同じ方法を参考にすることができます。

    ```SQL
    -- パーティションを手動で作成する
    ALTER TABLE <table_name> 
    ADD PARTITION <partition_name>
        [DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num]];
        
    -- ダイナミックパーティショニング
    ALTER TABLE <table_name> 
    SET ("dynamic_partition.buckets"="xxx");
    ```
