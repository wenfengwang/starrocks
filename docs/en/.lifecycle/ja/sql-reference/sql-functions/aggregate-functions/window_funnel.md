---
displayed_sidebar: "Japanese"
---

# window_funnel

## 説明

スライディングウィンドウ内のイベントチェーンを検索し、イベントチェーン内の連続イベントの最大数を計算します。この関数は、変換率の分析によく使用されます。v2.3からサポートされています。

この関数は、次のルールに従って動作します。

- イベントチェーン内の最初のイベントからカウントを開始します。最初のイベントが見つかった場合、イベントカウンターは1に設定され、スライディングウィンドウが開始されます。最初のイベントが見つからない場合、0が返されます。

- スライディングウィンドウ内では、イベントチェーン内のイベントが連続して発生した場合、カウンターが増加します。スライディングウィンドウを超えると、イベントカウンターは増加しなくなります。

- 指定された条件に一致する複数のイベントチェーンがある場合、最長のイベントチェーンが返されます。

## 構文

```Plain
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメータ

- `window`: スライディングウィンドウの長さです。サポートされているデータ型はBIGINTです。単位は`time`パラメータに依存します。`time`のデータ型がDATEの場合、単位は日です。`time`のデータ型がDATETIMEの場合、単位は秒です。

- `time`: タイムスタンプが含まれる列です。DATEおよびDATETIMEのデータ型がサポートされています。

- `mode`: イベントチェーンがフィルタリングされるモードです。サポートされているデータ型はINTです。値の範囲: 0、1、2。
  - `0`はデフォルト値で、一般的なファネル計算を示します。
  - `1`は`DEDUPLICATION`モードを示し、フィルタリングされたイベントチェーンには繰り返しイベントが含まれていない必要があります。`array`パラメータが`[event_type = 'A', event_type = 'B', event_type = 'C', event_type = 'D']`であり、元のイベントチェーンが"A-B-C-B-D"である場合、イベントBが繰り返され、フィルタリングされたイベントチェーンは"A-B-C"です。
  - `2`は`FIXED`モードを示し、フィルタリングされたイベントチェーンには指定されたシーケンスを妨げるイベントが含まれていない必要があります。前述の`array`パラメータを使用し、元のイベントチェーンが"A-B-D-C"である場合、イベントDがシーケンスを中断し、フィルタリングされたイベントチェーンは"A-B"です。
  - `4`は`INCREASE`モードを示し、フィルタリングされたイベントは厳密に増加するタイムスタンプを持つ必要があります。重複するタイムスタンプはイベントチェーンを中断します。このモードはバージョン2.5からサポートされています。

- `array`: 定義されたイベントチェーンです。配列である必要があります。

## 戻り値

BIGINT型の値を返します。

## 例

**例1**: `uid`に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは`0`です。

この例では、`action`テーブルを使用し、データは`uid`でソートされています。

```Plaintext
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:20:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Order      | 2020-01-02 11:00:00 |
| 2    | Pay        | 2020-01-02 11:10:00 |
| 3    | Browse     | 2020-01-02 11:20:00 |
| 3    | Click      | 2020-01-02 12:00:00 |
| 4    | Browse     | 2020-01-02 11:50:00 |
| 4    | Click      | 2020-01-02 12:00:00 |
| 5    | Browse     | 2020-01-02 11:50:00 |
| 5    | Click      | 2020-01-02 12:00:00 |
| 5    | Order      | 2020-01-02 11:10:00 |
| 6    | Browse     | 2020-01-02 11:50:00 |
| 6    | Click      | 2020-01-02 12:00:00 |
| 6    | Order      | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action
group by uid
order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

結果の説明:

- `uid = 1`に対する一致するイベントチェーンは"Browse-Click-Order-Pay"であり、`4`が返されます。最後の"Browse"イベントの時刻(2020-01-02 11:00:00)が条件を満たさず、カウントされません。

- `uid = 2`のイベントチェーンは最初のイベント"Browse"から始まらず、`0`が返されます。

- `uid = 3`に対する一致するイベントチェーンは"Browse"であり、`1`が返されます。"Click"イベントは1800秒の時間ウィンドウを超えているため、カウントされません。

- `uid = 4`に対する一致するイベントチェーンは"Browse-Click"であり、`2`が返されます。

- `uid = 5`に対する一致するイベントチェーンは"Browse-Click"であり、`2`が返されます。"Order"イベント(2020-01-02 11:10:00)はイベントチェーンに属しておらず、カウントされません。

- `uid = 6`に対する一致するイベントチェーンは"Browse-Click-Order"であり、`3`が返されます。

**例2**: `uid`に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは`0`および`1`を使用します。

この例では、`action1`テーブルを使用し、データは`time`でソートされています。

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:29:00 |
| 1    | Click      | 2020-01-02 11:29:50 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Click      | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1800,time,0,[event_type='Browse', 
        event_type='Click', event_type='Order', event_type='Pay']) AS level
from action1
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1`の場合、"Click"イベント(2020-01-02 11:29:50)は繰り返されたイベントですが、モード`0`が使用されているため、カウントされます。したがって、`4`が返されます。

`mode`を`1`に変更して、ステートメントを再度実行します。

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

重複を削除した後の最長のイベントチェーンは"Browse-Click-Order"であり、`3`が返されます。

**例3**: `uid`に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルタリングモードは`0`および`2`を使用します。

この例では、`action2`テーブルを使用し、データは`time`でソートされています。

```Plaintext
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Order      | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1`の場合、モード`0`が使用されており、"Pay"イベント(2020-01-02 11:30:00)はイベントチェーンを妨げないため、`3`が返されます。

`mode`を`2`に変更して、ステートメントを再度実行します。

```Plaintext
select uid,
       window_funnel(1900,time,2,[event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

"Pay"イベントがイベントチェーンを妨げ、イベントカウンターが停止するため、`2`が返されます。フィルタリングされたイベントチェーンは"Browse-Click"です。

**例4**: `uid`に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルタリングモードは`0`および`4`を使用します。

この例では、`action3`テーブルを使用し、データは`time`でソートされています。

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:00:01 |
| 2    | Browse     | 2020-01-02 11:00:03 |
| 1    | Order      | 2020-01-02 11:00:31 |
| 2    | Click      | 2020-01-02 11:00:03 |
| 2    | Order      | 2020-01-02 11:01:03 |
+------+------------+---------------------+
3 rows in set (0.02 sec)
```

次のステートメントを実行します:

```Plaintext
select uid,
       window_funnel(1900,time,0,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
```

`uid = 1`および`uid = 2`に対して`3`が返されます。

`mode`を`4`に変更して、ステートメントを再度実行します。

```Plaintext
select uid,
       window_funnel(1900,time,4,[event_type='Browse', event_type='Click',
        event_type='Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
1 row in set (0.02 sec)
```

`uid = 2`の場合、モード`4` (厳密に増加)が使用されています。"Click"は"BROWSE"と同じ秒に発生します。したがって、"Click"と"Order"はカウントされません。`1`が返されます。

## キーワード

window funnel, funnel, window_funnel
