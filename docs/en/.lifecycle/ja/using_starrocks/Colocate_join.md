---
displayed_sidebar: "Japanese"
---

# Colocate Join（コロケーションジョイン）

シャッフルジョインとブロードキャストジョインの場合、ジョイン条件が満たされると、ジョインする2つのテーブルのデータ行が1つのノードにマージされ、ジョインが完了します。これらの2つのジョイン方法のいずれも、ノード間のデータネットワーク転送によって引き起こされる遅延やオーバーヘッドを回避することはできません。

コロケーションジョインのコアアイデアは、同じコロケーショングループ内のテーブルのバケットキー、コピー数、およびコピー配置を一貫させることです。ジョインカラムがバケットキーである場合、計算ノードは他のノードからデータを取得せずにローカルジョインを行うだけで済みます。コロケーションジョインは等価ジョインをサポートしています。

このドキュメントでは、コロケーションジョインの原理、実装、使用方法、および考慮事項について説明します。

## 用語

* **コロケーショングループ（CG）**：CGには1つ以上のテーブルが含まれます。CG内のテーブルは、同じバケット化とレプリカ配置を持ち、コロケーショングループスキーマを使用して記述されます。
* **コロケーショングループスキーマ（CGS）**：CGSには、CGのバケットキー、バケット数、およびレプリカ数が含まれます。

## 原理

コロケーションジョインは、同じCGSを持つテーブルのセットでCGを形成し、これらのテーブルの対応するバケットコピーが同じBEノードのセットに配置されるようにします。CG内のテーブルがバケット化された列でジョイン操作を実行する場合、ローカルデータを直接ジョインすることができ、ノード間でデータを転送する時間を節約できます。

バケットシーケンスは、`hash(key) mod buckets`によって取得されます。テーブルに8つのバケットがあるとすると、\[0, 1, 2, 3, 4, 5, 6, 7\]の8つのバケットがあり、各バケットには1つ以上のサブテーブルがあります。サブテーブルの数はパーティションの数によって異なります。複数のパーティション化されたテーブルの場合、複数のタブレットが存在します。

同じCG内のテーブルは、以下の条件を満たす必要があります。

1. 同じCG内のテーブルは、データスライスを1つずつ分散および制御できるように、同一のバケットキー（タイプ、数、順序）と同じバケット数を持つ必要があります。バケットキーは、テーブル作成ステートメントの`DISTRIBUTED BY HASH(col1, col2, ...)`で指定された列です。バケットキーは、データのどの列が異なるバケットシーケンスにハッシュ化されるかを決定します。バケットキーの名前は、同じCG内のテーブルによって異なる場合があります。バケット化された列は作成ステートメントで異なる場合がありますが、`DISTRIBUTED BY HASH(col1, col2, ...)`の対応するデータ型の順序は完全に同じである必要があります。
2. 同じCG内のテーブルは、同じ数のパーティションコピーを持つ必要があります。そうでない場合、同じBEのパーティションに対応するコピーが存在しない可能性があります。
3. 同じCG内のテーブルは、異なる数のパーティションと異なるパーティションキーを持つ場合があります。

テーブルを作成する際には、テーブルのPROPERTIESで属性`"colocate_with" = "group_name"`を指定します。CGが存在しない場合、テーブルはCGの最初のテーブルであるとみなされ、親テーブルと呼ばれます。親テーブルのデータ分布（スプリットバケットキーのタイプ、数、順序、コピー数、スプリットバケットの数）がCGSを決定します。CGが存在する場合、テーブルのデータ分布がCGSと一致しているかどうかを確認します。

同じCG内のテーブルのコピー配置は次の条件を満たします。

1. すべてのテーブルのバケットシーケンスとBEノードのマッピングは、親テーブルのバケットシーケンスとBEノードのマッピングと同じである必要があります。
2. 親テーブルのすべてのパーティションのバケットシーケンスとBEノードのマッピングは、最初のパーティションのバケットシーケンスとBEノードのマッピングと同じである必要があります。
3. 親テーブルの最初のパーティションのバケットシーケンスとBEノードのマッピングは、ネイティブのラウンドロビンアルゴリズムを使用して決定されます。

一貫したデータ分布とマッピングにより、バケットキーでデータの同じ値を持つデータ行が同じBEに配置されます。したがって、バケットキーを使用して列をジョインする場合、ローカルジョインのみが必要です。

## 使用方法

### テーブルの作成

テーブルを作成する際に、PROPERTIESで属性`"colocate_with" = "group_name"`を指定して、テーブルがコロケーションジョインテーブルであることと指定したコロケーショングループに属することを示すことができます。
> **注意**
>
> バージョン2.5.4以降、異なるデータベースのテーブルでコロケーションジョインを実行することができます。テーブルを作成する際に、同じ`colocate_with`プロパティを指定するだけです。

例：

~~~SQL
CREATE TABLE tbl (k1 int, v1 int sum)
DISTRIBUTED BY HASH(k1)
BUCKETS 8
PROPERTIES(
    "colocate_with" = "group1"
);
~~~

指定したグループが存在しない場合、StarRocksは自動的に現在のテーブルのみを含むグループを作成します。グループが存在する場合、StarRocksは現在のテーブルがコロケーショングループスキーマを満たしているかどうかを確認し、テーブルを作成してグループに追加します。同時に、テーブルは既存のグループのデータ分布ルールに基づいてパーティションとタブレットを作成します。

コロケーショングループはデータベースに属します。コロケーショングループの名前はデータベース内で一意です。内部ストレージでは、コロケーショングループの完全な名前は`dbId_groupName`ですが、`groupName`のみが表示されます。
> **注意**
>
> 異なるデータベースのテーブルをコロケーションジョインするために同じコロケーショングループを指定する場合、そのコロケーショングループはそれぞれのデータベースに存在します。異なるデータベースのコロケーショングループを確認するには、`show proc "/colocation_group"`を実行してください。

### 削除

完全な削除は、リサイクルビンからの削除です。通常、`DROP TABLE`コマンドでテーブルを削除した後、デフォルトでは1日間リサイクルビンに保持された後に削除されます。グループ内の最後のテーブルが完全に削除されると、グループも自動的に削除されます。

### グループ情報の表示

次のコマンドを使用すると、クラスタ内に既に存在するグループ情報を表示できます。

~~~Plain Text
SHOW PROC '/colocation_group';

+-------------+--------------+--------------+------------+----------------+----------+----------+
| GroupId     | GroupName    | TableIds     | BucketsNum | ReplicationNum | DistCols | IsStable |
+-------------+--------------+--------------+------------+----------------+----------+----------+
| 10005.10008 | 10005_group1 | 10007, 10040 | 10         | 3              | int(11)  | true     |
+-------------+--------------+--------------+------------+----------------+----------+----------+
~~~

* **GroupId**：グループのクラスタ全体で一意の識別子であり、前半がdb idで、後半がグループ idです。
* **GroupName**：グループの完全な名前です。
* **TabletIds**：グループ内のテーブルのIDのリストです。
* **BucketsNum**：バケットの数です。
* **ReplicationNum**：レプリカの数です。
* **DistCols**：ディストリビューション列、つまりバケット化列のタイプです。
* **IsStable**：グループが安定しているかどうか（安定性の定義については、コロケーションレプリカのバランシングと修復のセクションを参照してください）。

次のコマンドを使用すると、グループのデータ分布をさらに表示できます。

~~~Plain Text
SHOW PROC '/colocation_group/10005.10008';

+-------------+---------------------+
| BucketIndex | BackendIds          |
+-------------+---------------------+
| 0           | 10004, 10002, 10001 |
| 1           | 10003, 10002, 10004 |
| 2           | 10002, 10004, 10001 |
| 3           | 10003, 10002, 10004 |
| 4           | 10002, 10004, 10003 |
| 5           | 10003, 10002, 10001 |
| 6           | 10003, 10004, 10001 |
| 7           | 10003, 10004, 10002 |
+-------------+---------------------+
~~~

* **BucketIndex**：バケットシーケンスの添字です。
* **BackendIds**：バケット化データスライスが配置されているBEノードのIDです。

> 注意：上記のコマンドはAMDIN権限が必要です。一般ユーザーはアクセスできません。

### テーブルグループのプロパティの変更

テーブルのコロケーショングループのプロパティを変更することができます。例：

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "group2");
~~~

テーブルが以前に別のグループに割り当てられていた場合、コマンドはテーブルを元のグループから削除し、新しいグループに追加します（グループが存在しない場合は最初にグループを作成します）。

次のコマンドを使用すると、テーブルのコロケーションプロパティを削除することもできます。

~~~SQL
ALTER TABLE tbl SET ("colocate_with" = "");
~~~

### その他の関連操作

Colocate属性を持つテーブルにパーティションを追加する場合や、コロケーション属性を持つテーブルのコピー数を変更する場合、StarRocksはColocationグループスキーマを違反する操作かどうかをチェックし、違反する場合は拒否します。

## コロケーションレプリカのバランシングと修復

コロケーションテーブルのレプリカ配布は、グループスキーマで指定された配布ルールに従う必要があるため、通常のシャーディングとは異なるレプリカの修復とバランシングの観点で異なります。

グループ自体には`stable`プロパティがあります。`stable`が`true`の場合、現在のグループのテーブルスライスに変更が加えられておらず、コロケーション機能が正常に動作していることを意味します。`stable`が`false`の場合、現在のグループの一部のテーブルスライスが修復または移行されていることを意味し、影響を受けるテーブルのコロケーションジョインは通常のジョインに低下します。

### レプリカの修復

レプリカは指定されたBEノードにのみ保存されます。StarRocksは、利用できないBE（例：ダウン、廃止）を置き換えるために、最も負荷の少ないBEを探します。置換後、古いBE上のすべてのバケット化データスライスが修復されます。移行中は、グループは**不安定**とマークされます。

### レプリカのバランシング

StarRocksは、コロケーションテーブルスライスをすべてのBEノードに均等に分散させようとします。通常のテーブルのバランシングはレプリカレベルで行われますが、コロケーションテーブルのバランシングはバケットレベルで行われます。つまり、バケット内のすべてのレプリカが一緒に移行されます。実際のレプリカのサイズではなく、レプリカの数のみを考慮して、`BucketsSequnce`をすべてのBEノードに均等に分散する単純なバランシングアルゴリズムを使用します。詳細なアルゴリズムは、`ColocateTableBalancer.java`のコードコメントで確認できます。

> 注意1：現在のコロケーションレプリカのバランシングと修復アルゴリズムは、異種デプロイメントを持つStarRocksクラスタに対してうまく機能しない場合があります。異種デプロイメントとは、BEノードのディスク容量、ディスク数、およびディスクタイプ（SSDおよびHDD）が一致していない場合を指します。異種デプロイメントの場合、小容量のBEノードが大容量のBEノードと同じ数のレプリカを保存する可能性があります。
>
> 注意2：グループが不安定な状態にある場合、そのテーブルのジョインは通常のジョインに低下し、クラスタのクエリパフォーマンスが著しく低下する可能性があります。システムが自動的にバランスを取らないようにする場合は、適切なタイミングでFE設定`disable_colocate_balance`を無効にし、自動バランスを無効にし、適切なタイミングで有効に戻します（詳細については、詳細操作（#詳細操作）のセクションを参照してください）。

## クエリ

コロケーションテーブルは通常のテーブルと同じようにクエリされます。コロケーションテーブルが存在するグループが不安定な状態にある場合、自動的に通常のジョインに低下します。次の例に示すように。

テーブル1：

~~~SQL
CREATE TABLE `tbl1` (
    `k1` date NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` int(11) SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
PARTITION BY RANGE(`k1`)
(
    PARTITION p1 VALUES LESS THAN ('2019-05-31'),
    PARTITION p2 VALUES LESS THAN ('2019-06-30')
)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

テーブル2：

~~~SQL
CREATE TABLE `tbl2` (
    `k1` datetime NOT NULL COMMENT "",
    `k2` int(11) NOT NULL COMMENT "",
    `v1` double SUM NOT NULL COMMENT ""
) ENGINE=OLAP
AGGREGATE KEY(`k1`, `k2`)
DISTRIBUTED BY HASH(`k2`)
PROPERTIES (
    "colocate_with" = "group1"
);
~~~

ビュークエリプラン：

~~~Plain Text
DESC SELECT * FROM tbl1 INNER JOIN tbl2 ON (tbl1.k2 = tbl2.k2);

+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN                           |
|   |  hash predicates:                              |
|   |  colocate: true                                |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----1:OlapScanNode                              |
|   |       TABLE: tbl2                              |
|   |       PREAGGREGATION: OFF. Reason: null        |
|   |       partitions=0/1                           |
|   |       rollup: null                             |
|   |       buckets=0/0                              |
|   |       cardinality=-1                           |
|   |       avgRowSize=0.0                           |
|   |       numNodes=0                               |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
+----------------------------------------------------+
~~~

コロケーションジョインが有効になる場合、HASH JOINノードに`colocate: true`と表示されます。

有効にならない場合、クエリプランは次のようになります。

~~~Plain Text
+----------------------------------------------------+
| Explain String                                     |
+----------------------------------------------------+
| PLAN FRAGMENT 0                                    |
|  OUTPUT EXPRS:`tbl1`.`k1` |                        |
|   PARTITION: RANDOM                                |
|                                                    |
|   RESULT SINK                                      |
|                                                    |
|   2:HASH JOIN                                      |
|   |  join op: INNER JOIN (BROADCAST)               |
|   |  hash predicates:                              |
|   |  colocate: false, reason: group is not stable  |
|   |    `tbl1`.`k2` = `tbl2`.`k2`                   |
|   |  tuple ids: 0 1                                |
|   |                                                |
|   |----3:EXCHANGE                                  |
|   |       tuple ids: 1                             |
|   |                                                |
|   0:OlapScanNode                                   |
|      TABLE: tbl1                                   |
|      PREAGGREGATION: OFF. Reason: No AggregateInfo |
|      partitions=0/2                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 0                                  |
|                                                    |
| PLAN FRAGMENT 1                                    |
|  OUTPUT EXPRS:                                     |
|   PARTITION: RANDOM                                |
|                                                    |
|   STREAM DATA SINK                                 |
|     EXCHANGE ID: 03                                |
|     UNPARTITIONED                                  |
|                                                    |
|   1:OlapScanNode                                   |
|      TABLE: tbl2                                   |
|      PREAGGREGATION: OFF. Reason: null             |
|      partitions=0/1                                |
|      rollup: null                                  |
|      buckets=0/0                                   |
|      cardinality=-1                                |
|      avgRowSize=0.0                                |
|      numNodes=0                                    |
|      tuple ids: 1                                  |
+----------------------------------------------------+
~~~

HASH JOINノードには、対応する理由が表示されます：`colocate: false, reason: group is not stable`。同時にEXCHANGEノードも生成されます。

## 詳細操作

### FE設定項目

* **disable_colocate_relocate**

StarRocksの自動コロケーションレプリカ修復を無効にするかどうかを指定します。デフォルトはfalseで、オンになっています。このパラメータはコロケーションテーブルのレプリカ修復にのみ影響を与え、通常のテーブルには影響しません。

* **disable_colocate_balance**

StarRocksの自動コロケーションレプリカバランシングを無効にするかどうかを指定します。デフォルトはfalseで、オンになっています。このパラメータはコロケーションテーブルのレプリカバランシングにのみ影響を与え、通常のテーブルには影響しません。

* **disable_colocate_join**

    この変数を変更することで、セッション単位でColocateジョインを無効にすることができます。

* **disable_colocate_join**

    この変数を変更することで、Colocateジョイン機能を無効にすることができます。

### HTTP Restful API

StarRocksは、Colocate Joinに関連するいくつかのHTTP Restful APIを提供しており、Colocationグループの表示や変更ができます。

このAPIはFE上で実装されており、ADMIN権限を持つユーザーが`fe_host:fe_http_port`を使用してアクセスできます。

1. クラスタのすべてのColocation情報を表示する

    ~~~bash
    curl --location-trusted -u<username>:<password> 'http://<fe_host>:<fe_http_port>/api/colocate'  
    ~~~

    ~~~JSON
    // 内部のColocation情報がJson形式で返されます。
    {
        "colocate_meta": {
            "groupName2Id": {
                "g1": {
                    "dbId": 10005,
                    "grpId": 10008
                }
            },
            "group2Tables": {},
            "table2Group": {
                "10007": {
                    "dbId": 10005,
                    "grpId": 10008
                },
                "10040": {
                    "dbId": 10005,
                    "grpId": 10008
                }
            },
            "group2Schema": {
                "10005.10008": {
                    "groupId": {
                        "dbId": 10005,
                        "grpId": 10008
                    },
                    "distributionColTypes": [{
                        "type": "INT",
                        "len": -1,
                        "isAssignedStrLenInColDefinition": false,
                        "precision": 0,
                        "scale": 0
                    }],
                    "bucketsNum": 10,
                    "replicationNum": 2
                }
            },
            "group2BackendsPerBucketSeq": {
                "10005.10008": [
                    [10004, 10002],
                    [10003, 10002],
                    [10002, 10004],
                    [10003, 10002],
                    [10002, 10004],
                    [10003, 10002],
                    [10003, 10004],
                    [10003, 10004],
                    [10003, 10004],
                    [10002, 10004]
                ]
            },
            "unstableGroups": []
        },
        "status": "OK"
    }
    ~~~

2. グループを安定または不安定にマークする

    ~~~bash
    # 安定にマークする
    curl -XPOST --location-trusted -u<username>:<password> ​'http://<fe_host>:<fe_http_port>/api/colocate/group_stable?db_id=<dbId>&group_id=<grpId>​'
    # 不安定にマークする
    curl -XPOST --location-trusted -u<username>:<password> ​'http://<fe_host>:<fe_http_port>/api/colocate/group_unstable?db_id=<dbId>&group_id=<grpId>​'
    ~~~

    返される結果が`200`の場合、グループは正常に安定または不安定にマークされます。

3. グループのデータ分布を設定する

    このインターフェースを使用すると、グループの数分布を強制的に設定することができます。

    `POST /api/colocate/bucketseq?db_id=10005&group_id= 10008`

    `Body:`

    `[[10004,10002],[10003,10002],[10002,10004],[10003,10002],[10002,10004],[10003,10002],[10003,10004],[10003,10004],[10003,10004],[10002,10004]]`

    `returns: 200`

    `Body`は、バケット化スライスが配置されるBEのIDのネストされた配列として表される`BucketsSequence`です。

    > このコマンドを使用するには、FE設定`disable_colocate_relocate`と`disable_colocate_balance`をtrueに設定する必要がある場合があります。つまり、システムが自動的にColocationレプリカの修復とバランシングを実行しないようにするためです。それ以外の場合、変更後にシステムによって自動的にリセットされる可能性があります。
