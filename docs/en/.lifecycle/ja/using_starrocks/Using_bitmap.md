---
displayed_sidebar: "Japanese"
---

# 正確なCount Distinctのためのビットマップの使用方法

このトピックでは、StarRocksでビットマップを使用して一意の値の数を計算する方法について説明します。

ビットマップは、配列内の一意の値の数を計算するための便利なツールです。この方法は、従来のCount Distinctと比較して、ストレージスペースを少なく占有し、計算を高速化することができます。[0、n)の値範囲を持つ配列Aがあるとします。n+7)/8バイトのビットマップを使用することで、配列内の一意の要素の数を計算できます。これを行うには、すべてのビットを0で初期化し、要素の値をビットの添字として設定し、すべてのビットを1に設定します。ビットマップ内の1の数が配列内の一意の要素の数です。

## 従来のCount Distinct

StarRocksはMPPアーキテクチャを使用しており、Count Distinctを使用する場合でも詳細なデータを保持することができます。ただし、Count Distinct機能はクエリ処理中に複数のデータシャッフルが必要であり、データ量が増加するにつれてパフォーマンスが線形に低下します。

以下のシナリオでは、テーブル（dt、page、user_id）の詳細データを基にUVを計算します。

|  dt   |   page  | user_id |
| :---: | :---: | :---:|
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 102 |
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 101 |
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 101 |

StarRocksは以下の図に示すようにデータを計算します。まず、データを`page`と`user_id`の列でグループ化し、その後処理結果をカウントします。

![alter](../assets/6.1.2-2.png)

* 注意：図は2つのBEノードで計算された6行のデータの概略を示しています。

複数のシャッフル操作が必要な大量のデータを処理する場合、必要な計算リソースが大幅に増加することがあります。これによりクエリが遅くなります。しかし、ビットマップ技術を使用することで、この問題を解決し、このようなシナリオでクエリのパフォーマンスを向上させることができます。

`page`でグループ化した`uv`をカウントする：

```sql
select page, count(distinct user_id) as uv from table group by page;

|  page   |   uv  |
| :---: | :---: |
|   game  |  1   |
|   shopping  |   2  |
```

## ビットマップを使用したCount Distinctの利点

COUNT(DISTINCT expr)と比較して、ビットマップを使用することで以下の点で利点があります：

* ストレージスペースの削減：INT32データの一意の値の数をビットマップで計算する場合、必要なストレージスペースはCOUNT(DISTINCT expr)の1/32だけです。StarRocksでは、圧縮されたローリングビットマップを使用して計算を実行し、従来のビットマップと比較してストレージスペースの使用量をさらに削減しています。
* 高速な計算：ビットマップはビット演算を使用するため、COUNT(DISTINCT expr)と比較して高速な計算が可能です。StarRocksでは、一意の値の数の計算を並列で処理することができるため、クエリのパフォーマンスがさらに向上します。

ローリングビットマップの実装については、[特定の論文と実装](https://github.com/RoaringBitmap/RoaringBitmap)を参照してください。

## 使用上の注意

* ビットマップインデックスとビットマップCount Distinctの両方がビットマップ技術を使用しています。ただし、導入目的と解決する問題はまったく異なります。前者は、カーディナリティの低い列を列挙してフィルタリングするために使用され、後者はデータ行の値列の一意の要素の数を計算するために使用されます。
* StarRocks 2.3以降のバージョンでは、テーブルの種類（集計テーブル、重複キーテーブル、プライマリキーテーブル、またはユニークキーテーブル）に関係なく、値列をBITMAPとして定義することができます。ただし、テーブルの[ソートキー](../table_design/Sort_key.md)はBITMAPタイプにすることはできません。
* テーブルを作成する際に、値列をBITMAPとして定義し、集計関数を[BITMAP_UNION](../sql-reference/sql-functions/bitmap-functions/bitmap_union.md)として定義することができます。
* ローリングビットマップを使用して、次のタイプのデータの一意の値の数を計算することができます：TINYINT、SMALLINT、INT、BIGINT。他のタイプのデータについては、[グローバル辞書を構築する](#global-dictionary)必要があります。

## ビットマップを使用したCount Distinct

ページのUVを計算する例を挙げます。

1. BITMAP_UNIONを使用したBITMAP列`visit_users`を持つ集計テーブルを作成します。

    ```sql
    CREATE TABLE `page_uv` (
      `page_id` INT NOT NULL COMMENT 'ページID',
      `visit_date` datetime NOT NULL COMMENT 'アクセス時間',
      `visit_users` BITMAP BITMAP_UNION NOT NULL COMMENT 'ユーザーID'
    ) ENGINE=OLAP
    AGGREGATE KEY(`page_id`, `visit_date`)
    DISTRIBUTED BY HASH(`page_id`)
    PROPERTIES (
      "replication_num" = "3",
      "storage_format" = "DEFAULT"
    );
    ```

2. このテーブルにデータをロードします。

    INSERT INTOを使用してデータをロードします：

    ```sql
    INSERT INTO page_uv VALUES
    (1, '2020-06-23 01:30:30', to_bitmap(13)),
    (1, '2020-06-23 01:30:30', to_bitmap(23)),
    (1, '2020-06-23 01:30:30', to_bitmap(33)),
    (1, '2020-06-23 02:30:30', to_bitmap(13)),
    (2, '2020-06-23 01:30:30', to_bitmap(23));
    ```

    データがロードされた後：

    * 行`page_id = 1, visit_date = '2020-06-23 01:30:30'`では、`visit_users`フィールドに3つのビットマップ要素（13、23、33）が含まれています。
    * 行`page_id = 1, visit_date = '2020-06-23 02:30:30'`では、`visit_users`フィールドに1つのビットマップ要素（13）が含まれています。
    * 行`page_id = 2, visit_date = '2020-06-23 01:30:30'`では、`visit_users`フィールドに1つのビットマップ要素（23）が含まれています。

   ローカルファイルからデータをロードします：

    ```shell
    echo -e '1,2020-06-23 01:30:30,130\n1,2020-06-23 01:30:30,230\n1,2020-06-23 01:30:30,120\n1,2020-06-23 02:30:30,133\n2,2020-06-23 01:30:30,234' > tmp.csv | 
    curl --location-trusted -u <username>:<password> -H "label:label_1600960288798" \
        -H "column_separator:," \
        -H "columns:page_id,visit_date,visit_users, visit_users=to_bitmap(visit_users)" -T tmp.csv \
        http://StarRocks_be0:8040/api/db0/page_uv/_stream_load
    ```

3. ページのUVを計算します。

    ```sql
    SELECT page_id, count(distinct visit_users) FROM page_uv GROUP BY page_id;
    +-----------+------------------------------+
    |  page_id  | count(DISTINCT `visit_users`)|
    +-----------+------------------------------+
    |         1 |                            3 |
    |         2 |                            1 |
    +-----------+------------------------------+
    2 行が返されました (0.00 秒)
    ```

## グローバル辞書

現在、ビットマップベースのCount Distinctメカニズムでは、入力は整数である必要があります。ユーザーがビットマップ以外のデータ型をビットマップに入力する必要がある場合は、他のデータ型（文字列型など）を整数型にマッピングするために独自のグローバル辞書を構築する必要があります。グローバル辞書を構築するためのいくつかのアイデアがあります。

### Hiveテーブルベースのグローバル辞書

このスキームでは、グローバル辞書自体がHiveテーブルであり、生の値とエンコードされたInt値の2つの列を持ちます。グローバル辞書を生成するための手順は次のとおりです。

1. 辞書の列を重複排除して一時テーブルを生成します。
2. 一時テーブルとグローバル辞書を左結合し、`new value`を一時テーブルに追加します。
3. `new value`をエンコードしてグローバル辞書に挿入します。
4. ファクトテーブルと更新されたグローバル辞書を左結合し、IDで辞書の項目を置き換えます。

この方法により、グローバル辞書を更新し、ファクトテーブルの値列をSparkまたはMRを使用して置き換えることができます。トライツリーベースのグローバル辞書と比較して、このアプローチは分散可能であり、グローバル辞書を再利用することができます。

ただし、いくつかの注意点があります：元のファクトテーブルは複数回読み込まれ、グローバル辞書の計算中に多くの余分なリソースを消費する2つの結合があります。

### トライツリーに基づくグローバル辞書の構築

ユーザーは、トライツリー（プレフィックスツリーまたは辞書ツリーとも呼ばれる）を使用して独自のグローバル辞書を構築することもできます。トライツリーは、ノードの子孫の共通の接頭辞を持ち、クエリ時間を短縮し、文字列比較を最小限に抑えることができるため、辞書エンコーディングの実装に適しています。ただし、トライツリーの実装は分散化が容易ではなく、データ量が比較的大きい場合にパフォーマンスのボトルネックを引き起こす可能性があります。

グローバル辞書を構築し、他のタイプのデータを整数データに変換することで、非整数データ列の正確なCount Distinct分析をビットマップを使用して実行することができます。
