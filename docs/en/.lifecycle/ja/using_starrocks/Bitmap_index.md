---
displayed_sidebar: "Japanese"
---

# ビットマップインデックス

このトピックでは、ビットマップインデックスの作成と管理方法について説明します。

ビットマップインデックスは、ビットの配列であるビットマップを使用する特殊なデータベースインデックスです。ビットは常に0と1のいずれかの値を持ちます。ビットマップの各ビットはテーブルの1つの行に対応しており、対応する行の値によって各ビットの値が決まります。

ビットマップインデックスは、特定の列に対するクエリのパフォーマンスを向上させるのに役立ちます。クエリがソートキーカラムにヒットする場合、StarRocksは[プレフィックスインデックス](../table_design/Sort_key.md)を使用してクエリ結果を効率的に返します。ただし、データブロックのプレフィックスインデックスエントリは36バイトを超えることはできません。ソートキーとして使用されない列のクエリパフォーマンスを向上させる場合は、その列に対してビットマップインデックスを作成することができます。

## 利点

ビットマップインデックスの利点は以下の通りです：

- 列のカーディナリティが低い場合（ENUM型の列など）、応答時間を短縮することができます。列のユニークな値の数が比較的多い場合は、クエリの速度を向上させるためにブルームフィルタインデックスを使用することをおすすめします。詳細については、[ブルームフィルタインデックス](../using_starrocks/Bloomfilter_index.md)を参照してください。
- 他のインデックス技術と比較して、より少ないストレージスペースを使用します。ビットマップインデックスは通常、テーブル内のインデックス化されたデータの一部のサイズしか占めません。
- 複数のビットマップインデックスを組み合わせて複数の列に対するクエリを実行することができます。詳細については、[複数の列に対するクエリ](#複数の列に対するクエリ)を参照してください。

## 使用上の注意

- 等しい（`=`）または[NOT] IN演算子を使用してフィルタリングできる列に対してビットマップインデックスを作成することができます。
- 重複キーテーブルまたはユニークキーテーブルのすべての列に対してビットマップインデックスを作成することができます。集計テーブルまたはプライマリキーテーブルの場合、キーカラムに対してのみビットマップインデックスを作成することができます。
- FLOAT、DOUBLE、BOOLEAN、DECIMAL型の列はビットマップインデックスの作成をサポートしていません。
- クエリがビットマップインデックスを使用しているかどうかは、クエリのプロファイルの`BitmapIndexFilterRows`フィールドを表示することで確認できます。

## ビットマップインデックスの作成

列に対してビットマップインデックスを作成する方法は2つあります。

- テーブルを作成する際に列に対してビットマップインデックスを作成します。例：

    ```SQL
    CREATE TABLE d0.table_hash
    (
        k1 TINYINT,
        k2 DECIMAL(10, 2) DEFAULT "10.5",
        v1 CHAR(10) REPLACE,
        v2 INT SUM,
        INDEX index_name (column_name [, ...]) [USING BITMAP] [COMMENT '']
    )
    ENGINE = olap
    AGGREGATE KEY(k1, k2)
    DISTRIBUTED BY HASH(k1)
    PROPERTIES ("storage_type" = "column");
    ```

    以下の表は、ビットマップインデックスに関連するパラメータを説明しています。

    | **パラメータ** | **必須** | **説明**                                                     |
    | -------------- | -------- | ------------------------------------------------------------ |
    | index_name     | Yes      | ビットマップインデックスの名前です。以下の命名規則に従う必要があります：<ul><li>名前には、文字、数字（0-9）、アンダースコア（_）を含めることができます。ただし、文字で始める必要があります。</li><li>名前の長さは64文字を超えることはできません。</li></ul>ビットマップインデックスの名前はテーブル内で一意である必要があります。                              |
    | column_name    | Yes      | ビットマップインデックスが作成される列の名前です。複数の列名を指定して一度に複数の列に対するビットマップインデックスを作成することができます。複数の列はカンマ（`,`）で区切ります。  |
    | COMMENT        | No       | ビットマップインデックスのコメントです。                             |

    `INDEX index_name (column_name [, ...]) [USING BITMAP] [COMMENT '']`コマンドをカンマ（`,`）で区切って指定することで、複数の列に対して一度にビットマップインデックスを作成することができます。CREATE TABLEステートメントの他のパラメータの説明については、[CREATE TABLE](../sql-reference/sql-statements/data-definition/CREATE_TABLE.md)を参照してください。

- CREATE INDEXステートメントを使用してテーブルの列に対してビットマップインデックスを作成します。パラメータの説明と例については、[CREATE INDEX](../sql-reference/sql-statements/data-definition/CREATE_INDEX.md)を参照してください。

    ```SQL
    CREATE INDEX index_name ON table_name (column_name) [USING BITMAP] [COMMENT ''];
    ```

## ビットマップインデックスの表示

SHOW INDEXステートメントを使用して、テーブルに作成されたすべてのビットマップインデックスを表示することができます。パラメータの説明と例については、[SHOW INDEX](../sql-reference/sql-statements/Administration/SHOW_INDEX.md)を参照してください。

```SQL
SHOW { INDEX[ES] | KEY[S] } FROM [db_name.]table_name [FROM db_name];
```

> **注意**
>
> インデックスの作成は非同期プロセスです。そのため、作成プロセスが完了したインデックスのみ表示されます。

## ビットマップインデックスの削除

DROP INDEXステートメントを使用して、テーブルからビットマップインデックスを削除することができます。パラメータの説明と例については、[DROP INDEX](../sql-reference/sql-statements/data-definition/DROP_INDEX.md)を参照してください。

```SQL
DROP INDEX index_name ON [db_name.]table_name;
```

## 使用例

たとえば、以下の表`employee`は会社の従業員情報の一部を示しています。

| **ID** | **Gender** | **Position** | **Income_level** |
| ------ | ---------- | ------------ | ---------------- |
| 01     | 女性       | 開発者       | レベル1          |
| 02     | 女性       | アナリスト   | レベル2          |
| 03     | 女性       | セールスマン | レベル1          |
| 04     | 男性       | 会計士       | レベル3          |

### 単一列のクエリ

たとえば、`Gender`列のクエリパフォーマンスを向上させたい場合、次のステートメントを使用して列に対してビットマップインデックスを作成することができます。

```SQL
CREATE INDEX index1 ON employee (Gender) USING BITMAP COMMENT 'index1';
```

上記のステートメントを実行すると、次の図に示すようにビットマップインデックスが生成されます。

![figure](../assets/3.6.1-2.png)

1. 辞書の作成：StarRocksは`Gender`列のための辞書を作成し、`female`と`male`をINT型のコード化された値（`0`と`1`）にマッピングします。
2. ビットマップの生成：StarRocksはコード化された値に基づいて`female`と`male`のビットマップを生成します。`female`のビットマップは`1110`であり、`female`は最初の3行に表示されるためです。`male`のビットマップは`0001`であり、`male`は4行目にのみ表示されるためです。

会社の男性従業員を見つけたい場合、次のようなクエリを送信することができます。

```SQL
SELECT xxx FROM employee WHERE Gender = male;
```

クエリが送信されると、StarRocksは辞書を検索して`male`のコード化された値（`1`）を取得し、`male`のビットマップ（`0001`）を取得します。これは、クエリ条件に一致するのは4行目のみであることを意味します。その後、StarRocksは最初の3行をスキップして、4行目のみを読み取ります。

### 複数の列のクエリ

たとえば、`Gender`列と`Income_level`列のクエリパフォーマンスを向上させたい場合、次のステートメントを使用してこれらの2つの列に対してビットマップインデックスを作成することができます。

- `Gender`

    ```SQL
    CREATE INDEX index1 ON employee (Gender) USING BITMAP COMMENT 'index1';
    ```

- `Income_level`

    ```SQL
    CREATE INDEX index2 ON employee (Income_level) USING BITMAP COMMENT 'index2';
    ```

上記の2つのステートメントを実行すると、次の図に示すようにビットマップインデックスが生成されます。

![figure](../assets/3.6.1-3.png)

StarRocksはそれぞれ`Gender`列と`Income_level`列のための辞書を作成し、これら2つの列の異なる値に対してビットマップを生成します。

- `Gender`：`female`のビットマップは`1110`であり、`male`のビットマップは`0001`です。
- `Income_level`：`level_1`のビットマップは`1010`、`level_2`のビットマップは`0100`、`level_3`のビットマップは`0001`です。

`level_1`の給与をもらっている女性従業員を見つけたい場合、次のようなクエリを送信することができます。

```SQL
SELECT xxx FROM employee 
WHERE Gender = female AND Income_level = level_1;
```

クエリが送信されると、StarRocksは`Gender`と`Income_level`の辞書を同時に検索して次の情報を取得します：

- `female`のコード化された値は`0`であり、`female`のビットマップは`1110`です。
- `level_1`のコード化された値は`0`であり、`level_1`のビットマップは`1010`です。

StarRocksは`AND`演算子に基づいて`1110 & 1010`のビットごとの論理演算を実行し、結果として`1010`を取得します。この結果に基づいて、StarRocksは最初の行と3行目のみを読み取ります。
