---
displayed_sidebar: "Japanese"
---

# マテリアライズドビューを使用したデータモデリング

このトピックでは、StarRocksの非同期マテリアライズドビューを使用してデータモデリングを行う方法について説明します。これにより、データウェアハウスのETLパイプラインを大幅に簡素化し、データ品質とクエリパフォーマンスを大幅に向上させることができます。

## 概要

データモデリングは、データのクリーニング、レイヤリング、集約、関連付けを合理的な方法論で行うプロセスです。これにより、直接分析するには荒すぎる、複雑すぎる、またはコストがかかりすぎる生データの理解可能な表現を作成し、データに対する具体的な洞察を提供することができます。

しかし、現実のデータモデリングでは、モデリングプロセスがビジネスの発展のペースに追いつくのに苦労し、データモデリングの投資対効果を測定することが難しいという共通の課題があります。モデリングの方法論はシンプルですが、ビジネスの専門家はデータの組織とガバナンスについての堅固なバックグラウンドを持つ必要があり、これは複雑なプロセスです。ビジネスの初期段階では、意思決定者はデータモデリングに十分なリソースを割くことはほとんどありませんし、データモデリングがもたらす価値を見ることは難しいです。さらに、ビジネスモデルは急速に変化することがあり、モデリングの方法論自体も反復と進化が必要です。そのため、多くのデータアナリストはモデリングを避け、生データを直接使用する傾向があります。その結果、データ品質とクエリパフォーマンスの問題が必然的に生じます。モデリングの必要性が生じた場合、既に確立されたデータモデルのデータ分析パターンをデータモデルに合わせて再構築することは困難です。

マテリアライズドビューを使用したデータモデリングは、これらの問題を効果的に解決することができます。StarRocksの非同期マテリアライズドビューは以下のような機能を持っています。

- **データウェアハウスのアーキテクチャを簡素化**：StarRocksはワンストップのデータガバナンス体験を提供できるため、他のデータ処理システムを維持する必要がありません。これにより、それらに費やされる人的およびシステムリソースを節約することができます。
- **データモデリングの経験を容易に**：基本的なSQLの知識だけであれば、誰でもStarRocksを使用してデータモデリングができます。データモデリングはもはや経験豊富なデータエンジニアの専売特許ではありません。
- **メンテナンスの複雑さを削減**：StarRocksの非同期マテリアライズドビューは、データレイヤー間の系統関係と依存関係を自動的に管理するため、このタスクを処理するためのデータプラットフォーム全体を必要としません。

![Modeling-1](../assets/Modeling-1.png)

実際のシナリオでは、StarRocksのビュー（論理ビュー）と非同期マテリアライズドビューの使用を組み合わせてデータモデリングを行うことができます。

1. ビューを使用してリアルタイムデータと次元データを関連付け、マテリアライズドビューを使用してデータレイクからの過去のデータを次元データと関連付けます。必要なデータクリーニングと意味マッピングを実行して、ビジネスシナリオで必要な詳細データを反映したIntermediate Layerのデータを取得します。
2. アプリケーションレイヤーでは、異なるビジネスシナリオに合わせてデータの結合、集計、結合、ウィンドウ計算を実行します。これにより、リアルタイムパイプライン用のビューとネアリアルタイムパイプライン用のマテリアライズドビューが生成されます。
3. アプリケーション側では、タイムリネスとパフォーマンスの要件に基づいて適切な分析データストア（ADS）を選択します。これらのADSはリアルタイムダッシュボード、ネアリアルタイムBI、アドホッククエリ、スケジュールされたレポートに使用することができます。

このプロセスでは、StarRocksのいくつかの組み込み機能を活用します。これらの機能については、次のセクションで詳しく説明します。

## 非同期マテリアライズドビューの機能

StarRocksの非同期マテリアライズドビューには、データモデリングに役立つ以下のアトミックな機能があります。

- **自動リフレッシュ**：データがベーステーブルにロードされた後、マテリアライズドビューは自動的にリフレッシュされます。外部のスケジューリングタスクを維持する必要はありません。
- **パーティションリフレッシュ**：時間系列を持つテーブル上に構築されたマテリアライズドビューのパーティションリフレッシュにより、ネアリアルタイムな計算が実現できます。
- **ビューとのシナジー**：マテリアライズドビューと論理ビューを使用することで、マルチレベルのモデリングを実現し、Intermediate Layerの再利用とデータモデルの簡素化を可能にします。
- **スキーマ変更**：複雑なデータパイプラインを変更することなく、簡単なSQLステートメントで計算結果を変更することができます。

これらの機能を使用することで、さまざまなビジネスニーズとシナリオに対応した包括的で適応性のあるデータモデルを設計することができます。

### 自動リフレッシュ

非同期マテリアライズドビューを作成する際に、REFRESH句を使用してリフレッシュ戦略を指定することができます。現在、StarRocksは非同期マテリアライズドビューの以下のリフレッシュ戦略をサポートしています。

- **自動リフレッシュ**（`REFRESH ASYNC`）：ベーステーブルのデータが変更されるたびにリフレッシュタスクがトリガーされます。データの依存関係はマテリアライズドビューによって自動的に管理されます。
- **スケジュールされたリフレッシュ**（`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`）：定期的な間隔（例：毎分、毎日、毎月）でリフレッシュタスクがトリガーされます。ベーステーブルのデータに変更がない場合、リフレッシュタスクはトリガーされません。
- **マニュアルリフレッシュ**（`REFRESH MANUAL`）：REFRESH MATERIALIZED VIEWを手動で実行することでのみリフレッシュタスクがトリガーされます。このリフレッシュ戦略は、外部のスケジューリングフレームワークを維持してリフレッシュタスクをトリガーする場合に使用できます。

構文:

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### パーティションリフレッシュ

非同期マテリアライズドビューを作成する際に、PARTITION BY句を使用してベーステーブルのパーティションとマテリアライズドビューのパーティションを関連付け、パーティションレベルのリフレッシュを実現することができます。

- `PARTITION BY <column>`：ベーステーブルとマテリアライズドビューで同じパーティショニング列を参照することができます。その結果、ベーステーブルとマテリアライズドビューは同じ粒度でパーティション分割されます。
- `PARTITION BY date_trunc(<column>)`：date_trunc関数を使用して、時間単位を切り捨てることで、マテリアライズドビューのパーティショニング戦略（粒度レベル）を異なるものにすることができます。
- `PARTITION BY { time_slice | date_slice }(<column>)`：date_truncよりも柔軟な時間粒度の調整が可能なtime_sliceおよびdate_sliceを使用することで、時間に基づいたパーティショニングの制御をより細かく行うことができます。

構文:

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### ビューとのシナジー

- ビューを基にしてマテリアライズドビューを作成することができます。この場合、ビューが参照するベーステーブルのデータが変更されると、マテリアライズドビューが自動的にリフレッシュされます。
- 他のマテリアライズドビューを基にしてマテリアライズドビューを作成することもできます。これにより、マルチレベルの連鎖リフレッシュメカニズムが可能になります。
- マテリアライズドビューを基にしてビューを作成することもできます。これは通常のテーブルと同等です。

### スキーマ変更

- ALTER MATERIALIZED VIEW SWAPステートメントを使用して、2つの非同期マテリアライズドビュー間でアトミックな交換を行うことができます。これにより、新しいマテリアライズドビューを作成し、列を追加したり列の型を変更したりしてから、古いマテリアライズドビューと置き換えることができます。
- ALTER VIEWステートメントを使用してビューの定義を直接変更することができます。
- StarRocksの通常のテーブルは、SWAPまたはALTER操作のいずれかを使用して変更することができます。
- さらに、ベーステーブル（マテリアライズドビュー、ビュー、または通常のテーブル）の変更がある場合、それに応じて対応するマテリアライズドビューの変更がトリガーされます。

## レイヤードモデリング

多くの実世界のビジネスシナリオでは、リアルタイムの詳細データ、次元データ、データレイクからの過去のデータなど、さまざまな形式のデータソースが存在します。一方、ビジネスの要件では、リアルタイムダッシュボード、ネアリアルタイムのBIクエリ、アドホッククエリ、スケジュールされたレポートなど、さまざまな分析手法が求められます。異なるシナリオにはさまざまな要求があります - 柔軟性が必要なもの、パフォーマンスが重視されるもの、コスト効果が重視されるものなど。

明らかに、単一のソリューションではこれらの多様な要求に十分に対応することはできません。StarRocksは、ビューとマテリアライズドビューの使用を組み合わせることで、これらのニーズに効率的に対応することができます。ビューは物理データを保持しないため、ビューがクエリされるたびにクエリが解析され、ビューの定義に従って実行されます。これに対して、事前計算結果を保持するマテリアライズドビューは、繰り返し実行のオーバーヘッドを防ぐことができます。ビューはビジネスの意味を表現し、SQLの複雑さを簡素化するのに適していますが、クエリの実行コストを削減することはできません。一方、マテリアライズドビューは事前計算によるクエリのパフォーマンスを最適化し、ETLパイプラインを効率化するのに適しています。

以下は、ビューとマテリアライズドビューの違いの要約です。

|                                      | **ビュー**                                                     | **マテリアライズドビュー**                                        |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **使用例**                        | ビジネスモデリング、データガバナンス                           | データモデリング、透過的なアクセラレーション、データレイクの統合 |
| **ストレージコスト**                     | ストレージコストなし                                              | 事前計算結果の保存によって発生するストレージコスト        |
| **更新コスト**                      | 更新コストなし                                               | ベーステーブルのデータが更新されたときに発生するリフレッシュコスト           |
| **パフォーマンスの利点**             | パフォーマンスの利点なし                                       | 事前計算結果の再利用によって導入されるクエリのアクセラレーション |
| **データのリアルタイム属性** | ビューはリアルタイムで計算されるため、最新のデータが返されます。 | データは事前計算された結果であるため、最新のデータであるとは限りません。 |
| **依存関係**                       | ビューはベーステーブルの名前で参照されるため、ベーステーブルの名前が変更されるとビューが無効になります。 | ベーステーブルの名前の変更は、マテリアライズドビューに影響を与えず、マテリアライズドビューはベーステーブルをIDで参照します。 |
| **作成構文**              | CREATE VIEW                                                  | CREATE MATERIALIZED VIEW                                     |
| **変更構文**          | ALTER VIEW                                                   | ALTER MATERIALIZED VIEW                                      |

ビュー、マテリアライズドビュー、およびベーステーブルを変更するために次のステートメントを使用することができます。

```SQL
-- テーブルの変更
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 2つのテーブルを交換する
ALTER TABLE <table1> SWAP WITH <table2>;

-- ビューの定義を変更する
ALTER VIEW <view_name> AS <query>;

-- 2つのマテリアライズドビューを交換する
-- （2つのマテリアライズドビューの名前を交換して、データには影響を与えない）
ALTER MATERIALIZED VIWE <mv1> SWAP WITH <mv2>;

-- マテリアライズドビューを再アクティブ化する
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

スキーマの変更は次の原則に従います。

- テーブルの名前変更およびスワップ操作は、依存するマテリアライズドビューを非アクティブに設定します。スキーマ変更操作では、マテリアライズドビューが参照するベーステーブルの列に対してスキーマ変更操作が実行された場合にのみ、依存するマテリアライズドビューが非アクティブに設定されます。
- ビューの定義を変更すると、依存するマテリアライズドビューが非アクティブに設定されます。
- マテリアライズドビューがスワップされると、それに基づいて構築されたネストされたマテリアライズドビューは非アクティブに設定されます。
- 非アクティブなマテリアライズドビューはリフレッシュできず、自動クエリの書き換えに使用することはできません。
- 非アクティブなマテリアライズドビューは直接クエリできますが、データの整合性は再度アクティブになるまで保証されません。

非アクティブなマテリアライズドビューのデータ整合性は保証されませんが、次の方法を使用して機能を復元することができます。

- **手動修復**：ALTER MATERIALIZED VIEW `<mv_name>` ACTIVEを実行することで、非アクティブなマテリアライズドビューを手動で修復することができます。このステートメントは、元のSQL定義に基づいてマテリアライズドビューを再作成します。ただし、SQL定義は基礎となるスキーマの変更後も有効である必要があります。そうでない場合、操作は失敗します。
- **自動修復**：StarRocksは非アクティブなマテリアライズドビューを自動的にアクティブ化しようとします。ただし、このプロセスのタイムリネスは保証されません。

## パーティションモデリング

レイヤードモデリングに加えて、パーティションモデリングもデータモデリングの重要な側面です。データモデリングでは、ビジネスの意味に基づいてデータを関連付け、データのTime-To-Live（TTL）をタイムリネスの要件に応じて設定することがよくあります。パーティションモデリングはこのプロセスにおいて重要な役割を果たします。

パーティションモデリングは、レイヤードモデリングを補完するデータモデリングの重要な側面であり、ビジネスの意味に基づいてデータを関連付け、データのTime-To-Live（TTL）をタイムリネスの要件に応じて設定することを意味します。データのパーティショニングはこのプロセスにおいて重要な役割を果たします。

データの関連付け方によって、スタースキーマやスノーフレークスキーマなど、さまざまなモデリングアプローチが生まれます。これらのモデルには共通点があります - すべてのモデルがファクトテーブルとディメンションテーブルを使用しています。一部のビジネスシナリオでは複数の大規模なファクトテーブルが必要であり、他のシナリオでは複雑なディメンションテーブルとその関係が必要です。StarRocksのマテリアライズドビューは、ファクトテーブルのパーティション関連付けをサポートしており、ファクトテーブルがパーティション分割され、マテリアライズドビューの結合結果も同じようにパーティション分割されます。

![Modeling-2](../assets/Modeling-2.png)

上記の図は、マテリアライズドビューがファクトテーブルと複数のディメンションテーブルを関連付けている様子を示しています。

- マテリアライズドビューのパーティショニングキー（`PARTITION BY fact_tbl.col`）として、特定のベーステーブル（通常はファクトテーブル）のパーティションキーを参照する必要があります。各マテリアライズドビューは、1つのベーステーブルにのみ関連付けることができます。
- 参照テーブルのパーティションのデータが変更されると、マテリアライズドビューの対応するパーティションが他のパーティションに影響を与えることなく自動的にリフレッシュされます。
- 参照されていないテーブルのデータが変更されると、デフォルトではマテリアライズドビュー全体がリフレッシュされます。ただし、特定の参照されていないベーステーブルのデータ変更を無視するように選択することもできます。

このようなパーティション関連付けは、さまざまなビジネスシナリオをサポートします。

- **ファクトテーブルの更新**：ファクトテーブルを日次または時間単位などの細かい粒度でパーティション分割することができます。ファクトテーブルが更新されると、マテリアライズドビューの対応するパーティションが自動的にリフレッシュされます。
- **ディメンションテーブルの更新**：通常、ディメンションテーブルのデータ更新は関連するすべての結果のリフレッシュを引き起こしますが、これはコストがかかる場合があります。一部のディメンションテーブルのデータ更新を無視して、マテリアライズドビュー全体をリフレッシュしないように選択することもできます。また、時間範囲を指定して、指定した時間範囲内のパーティションのみをリフレッシュすることもできます。
- **外部テーブルの自動リフレッシュ**：Apache HiveやApache Icebergなどの外部データソースでは、パーティションレベルでデータが変更されます。StarRocksのマテリアライズドビューは、外部カタログの変更をパーティションレベルで購読し、対応するマテリアライズドビューのパーティションのみをリフレッシュします。
- **TTL**：マテリアライズドビューのパーティショニング戦略を設定する際に、保持する最新のパーティションの数を設定することができます。これにより、特定の時間範囲の最新のデータのみを保持することができます。これは、アナリストが特定の時間ウィンドウから最新のデータのみをクエリし、すべての履歴データを保持する必要がないビジネスシナリオで役立ちます。

リフレッシュの動作を制御するために、いくつかのパラメータを使用することができます。

- `partition_refresh_number`：リフレッシュ操作ごとにリフレッシュするパーティションの数。
- `partition_ttl_number`：保持する最新のパーティションの数。
- `excluded_trigger_tables`：自動リフレッシュをトリガーするのを回避するために無視できるデータ変更のあるテーブル。
- `auto_refresh_partitions_limit`：自動リフレッシュ操作ごとにリフレッシュするパーティションの数。

詳細については、[CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)を参照してください。

現在、パーティション化されたマテリアライズドビューには以下の制限があります。

- パーティション化されたテーブルを基にしてのみパーティション化されたマテリアライズドビューを構築することができます。
- パーティショニングキーとしてDATEまたはDATETIME型の列のみを使用することができます。STRINGデータ型はサポートされていません。
- date_trunc、time_slice、date_slice関数を使用してパーティションのロールアップを実行することができます。
- 単一の列をパーティショニングキーとして指定することしかサポートされていません。

## まとめ

StarRocksの非同期マテリアライズドビューを使用したデータモデリングは、宣言的なモデリング言語を通じてパイプラインの管理を簡素化し、効率と柔軟性を向上させる利点を提供します。

データモデリング以外にも、StarRocksの非同期マテリアライズドビューは、透過的なアクセラレーションとデータレイクの統合を含むさまざまなシナリオで活用されます。これにより、データの価値をさらに探求し、データの効率を向上させることができます。
