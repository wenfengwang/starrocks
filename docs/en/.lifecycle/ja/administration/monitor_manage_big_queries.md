---
displayed_sidebar: "Japanese"
---

# 大規模クエリの監視と管理

このトピックでは、StarRocksクラスタでの大規模クエリの監視と管理方法について説明します。

大規模クエリには、多くの行をスキャンするクエリやCPUおよびメモリリソースを多く占有するクエリが含まれます。これらのクエリは、クラスタリソースを容易に枯渇させ、制限がない場合にはシステムの過負荷を引き起こす可能性があります。この問題に対処するため、StarRocksでは大規模クエリの監視と管理のための一連の手段を提供しており、クエリがクラスタリソースを独占することを防止しています。

StarRocksでの大規模クエリの処理方法の全体的なアイデアは次のとおりです。

1. リソースグループとクエリキューを使用して、大規模クエリに対する自動的な予防措置を設定します。
2. リアルタイムで大規模クエリを監視し、予防措置を回避するクエリを終了します。
3. オーディットログとBig Queryログを分析して、大規模クエリのパターンを研究し、以前に設定した予防メカニズムを微調整します。

この機能はv3.0以降でサポートされています。

## 大規模クエリに対する予防措置の設定

StarRocksでは、リソースグループとクエリキューの2つの予防手段を提供しています。リソースグループを使用して、大規模クエリの実行を停止することができます。一方、クエリキューは、同時実行の閾値やリソース制限に達した場合に、入力されたクエリをキューに入れてシステムの過負荷を防ぐのに役立ちます。

### リソースグループを使用して大規模クエリをフィルタリング

リソースグループは、大規模クエリを自動的に識別して終了することができます。リソースグループを作成する際に、クエリが許可されるCPU時間の上限、メモリ使用量の上限、またはスキャン行数の上限を指定することができます。リソースグループにヒットしたすべてのクエリのうち、より多くのリソースを必要とするクエリは拒否され、エラーが返されます。詳細については、[リソースの分離](../administration/resource_group.md)を参照してください。

リソースグループを作成する前に、リソースグループ機能に依存するパイプラインエンジンを有効にするために、次のステートメントを実行する必要があります。

```SQL
SET GLOBAL enable_pipeline_engine = true;
```

次の例では、CPU時間の上限を`100`秒、スキャン行数の上限を`100000`、メモリ使用量の上限を`1073741824`バイト（1 GB）に制限する`bigQuery`という名前のリソースグループを作成しています。

```SQL
CREATE RESOURCE GROUP bigQuery
TO 
    (db='sr_hub')
WITH (
    'cpu_core_limit' = '10',
    'mem_limit' = '20%',
    'big_query_cpu_second_limit' = '100',
    'big_query_scan_rows_limit' = '100000',
    'big_query_mem_limit' = '1073741824'
);
```

クエリの必要なリソースがいずれかの制限を超える場合、クエリは実行されずにエラーが返されます。次の例は、クエリがスキャン行数が多すぎる場合に返されるエラーメッセージを示しています。

```Plain
ERROR 1064 (HY000): exceed big query scan_rows limit: current is 4 but limit is 1
```

リソースグループを設定するのは初めての場合は、通常のクエリの実行を妨げないように比較的高い制限を設定することをお勧めします。大規模クエリのパターンをよりよく理解した後でこれらの制限を微調整することができます。

### クエリキューを使用してシステムの過負荷を緩和

クエリキューは、クラスタリソースの占有が事前に指定した閾値を超えた場合に、システムの過負荷の悪化を緩和するために設計されています。最大同時実行数、メモリ使用量、およびCPU使用量の閾値を設定することができます。StarRocksは、これらの閾値のいずれかに達した場合、入力されたクエリを自動的にキューに入れます。保留中のクエリは、キュー内で実行を待機するか、指定されたリソースの閾値に達した場合にキャンセルされます。詳細については、[クエリキュー](../administration/query_queues.md)を参照してください。

SELECTクエリに対してクエリキューを有効にするには、次のステートメントを実行します。

```SQL
SET GLOBAL enable_query_queue_select = true;
```

クエリキューの機能が有効になった後、クエリキューをトリガーするためのルールを定義することができます。

- クエリキューをトリガーするための同時実行数の閾値を指定します。

  次の例では、同時実行数の閾値を`100`に設定しています。

  ```SQL
  SET GLOBAL query_queue_concurrency_limit = 100;
  ```

- クエリキューをトリガーするためのメモリ使用率の閾値を指定します。

  次の例では、メモリ使用率の閾値を`0.9`に設定しています。

  ```SQL
  SET GLOBAL query_queue_mem_used_pct_limit = 0.9;
  ```

- クエリキューをトリガーするためのCPU使用率の閾値を指定します。

  次の例では、CPU使用率のパーミル（CPU使用率 * 1000）の閾値を`800`に設定しています。

  ```SQL
  SET GLOBAL query_queue_cpu_used_permille_limit = 800;
  ```

また、キュー内の各保留中のクエリの最大キュー長とタイムアウトを設定することで、これらの保留中のクエリの処理方法を決定することもできます。

- 最大クエリキュー長を指定します。この閾値に達すると、入力されたクエリは拒否されます。

  次の例では、クエリキューの長さを`100`に設定しています。

  ```SQL
  SET GLOBAL query_queue_max_queued_queries = 100;
  ```

- キュー内の保留中のクエリの最大タイムアウトを指定します。この閾値に達すると、対応するクエリは拒否されます。

  次の例では、最大タイムアウトを`480`秒に設定しています。

  ```SQL
  SET GLOBAL query_queue_pending_timeout_second = 480;
  ```

クエリが保留中かどうかは、[SHOW PROCESSLIST](../sql-reference/sql-statements/Administration/SHOW_PROCESSLIST.md)を使用して確認することができます。

```Plain
mysql> SHOW PROCESSLIST;
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
| Id   | User | Host                | Db    | Command | ConnectionStartTime | Time | State | Info              | IsPending |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
|    2 | root | xxx.xx.xxx.xx:xxxxx |       | Query   | 2022-11-24 18:08:29 |    0 | OK    | SHOW PROCESSLIST  | false     |
+------+------+---------------------+-------+---------+---------------------+------+-------+-------------------+-----------+
```

`IsPending`が`true`であれば、対応するクエリはクエリキューで保留中です。

## リアルタイムで大規模クエリを監視する

v3.0以降、StarRocksでは、クラスタで現在処理中のクエリとそれらが占有するリソースを表示することがサポートされています。これにより、大規模クエリが予防措置を回避して予期しないシステムの過負荷を引き起こす場合に、クラスタを監視することができます。

### MySQLクライアントを使用して監視する

1. [SHOW PROC](../sql-reference/sql-statements/Administration/SHOW_PROC.md)を使用して、現在処理中のクエリ（`current_queries`）を表示することができます。

   ```SQL
   SHOW PROC '/current_queries';
   ```

   StarRocksは、各クエリのクエリID（`QueryId`）、接続ID（`ConnectionId`）、およびスキャンされたデータサイズ（`ScanBytes`）、処理された行数（`ProcessRows`）、CPU時間（`CPUCostSeconds`）、メモリ使用量（`MemoryUsageBytes`）、および実行時間（`ExecTime`）を含む、各クエリのリソース消費量を返します。

   ```Plain
   mysql> SHOW PROC '/current_queries';
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | QueryId                              | ConnectionId | Database   | User | ScanBytes | ProcessRows    | CPUCostSeconds | MemoryUsageBytes | ExecTime |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   | 7c56495f-ae8b-11ed-8ebf-00163e00accc | 4            | tpcds_100g | root | 37.88 MB  | 1075769 Rows   | 11.13 Seconds  | 146.70 MB        | 3804     |
   | 7d543160-ae8b-11ed-8ebf-00163e00accc | 6            | tpcds_100g | root | 13.02 GB  | 487873176 Rows | 81.23 Seconds  | 6.37 GB          | 2090     |
   +--------------------------------------+--------------+------------+------+-----------+----------------+----------------+------------------+----------+
   2 rows in set (0.01 sec)
   ```

2. クエリIDを指定して、各BEノードでのクエリのリソース消費量をさらに調べることができます。

   ```SQL
   SHOW PROC '/current_queries/<QueryId>/hosts';
   ```

   StarRocksは、各BEノードでのクエリのスキャンされたデータサイズ（`ScanBytes`）、スキャンされた行数（`ScanRows`）、CPU時間（`CPUCostSeconds`）、およびメモリ使用量（`MemUsageBytes`）を返します。

   ```Plain
   mysql> show proc '/current_queries/7c56495f-ae8b-11ed-8ebf-00163e00accc/hosts';
   +--------------------+-----------+-------------+----------------+---------------+
   | Host               | ScanBytes | ScanRows    | CpuCostSeconds | MemUsageBytes |
   +--------------------+-----------+-------------+----------------+---------------+
   | 172.26.34.185:8060 | 11.61 MB  | 356252 Rows | 52.93 Seconds  | 51.14 MB      |
   | 172.26.34.186:8060 | 14.66 MB  | 362646 Rows | 52.89 Seconds  | 50.44 MB      |
   | 172.26.34.187:8060 | 11.60 MB  | 356871 Rows | 52.91 Seconds  | 48.95 MB      |
   +--------------------+-----------+-------------+----------------+---------------+
   3 rows in set (0.00 sec)
   ```

### FEコンソールを使用して監視する

MySQLクライアント以外にも、FEコンソールを使用して視覚化されたインタラクティブな監視が可能です。

1. 次のURLを使用して、ブラウザでFEコンソールに移動します。

   ```Bash
   http://<fe_IP>:<fe_http_port>/system?path=//current_queries
   ```

   ![FE console 1](../assets/console_1.png)

   **System Info**ページで、現在処理中のクエリとそのリソース消費量を表示することができます。

2. クエリの**QueryID**をクリックします。

   ![FE console 2](../assets/console_2.png)

   表示されるページで、ノードごとの詳細なリソース消費量情報を表示することができます。

### 大規模クエリを手動で終了する

設定した予防措置を回避してシステムの可用性を脅かすような大規模クエリがある場合は、[KILL](../sql-reference/sql-statements/Administration/KILL.md)ステートメントで対応する接続IDを使用して、手動で終了することができます。

```SQL
KILL QUERY <ConnectionId>;
```

## 大規模クエリログの分析

v3.0以降、StarRocksではBig Queryログがサポートされており、ファイル**fe/log/fe.big_query.log**に保存されます。StarRocksの監査ログと比較して、Big Queryログは次の3つの追加フィールドを出力します。

- `bigQueryLogCPUSecondThreshold`
- `bigQueryLogScanBytesThreshold`
- `bigQueryLogScanRowsThreshold`

これらの3つのフィールドは、クエリが大規模クエリであるかどうかを判断するために定義したリソース消費量の閾値に対応しています。

Big Queryログを有効にするには、次のステートメントを実行します。

```SQL
SET GLOBAL enable_big_query_log = true;
```

Big Queryログが有効になった後、Big Queryログをトリガーするためのルールを定義することができます。

- Big QueryログをトリガーするためのCPU時間の閾値を指定します。

  次の例では、CPU時間の閾値を`600`秒に設定しています。

  ```SQL
  SET GLOBAL big_query_log_cpu_second_threshold = 600;
  ```

- Big Queryログをトリガーするためのスキャンデータサイズの閾値を指定します。

  次の例では、スキャンデータサイズの閾値を`10737418240`バイト（10 GB）に設定しています。

  ```SQL
  SET GLOBAL big_query_log_scan_bytes_threshold = 10737418240;
  ```
  
- Big Queryログをトリガーするためのスキャン行数の閾値を指定します。

  次の例では、スキャン行数の閾値を`1500000000`に設定しています。

  ```SQL
  SET GLOBAL big_query_log_scan_rows_threshold = 1500000000;
  ```

## 予防措置の微調整

リアルタイムの監視とBig Queryログから得られた統計情報をもとに、クラスタ内の省略された大規模クエリ（または誤って大規模クエリと診断された通常のクエリ）のパターンを研究し、リソースグループとクエリキューの設定を最適化することができます。

大規模クエリの大部分が特定のSQLパターンに準拠しており、このSQLパターンを永久に禁止したい場合は、SQLブラックリストにこのパターンを追加することができます。StarRocksは、SQLブラックリストで指定されたパターンに一致するすべてのクエリを拒否し、エラーを返します。詳細については、[SQLブラックリストの管理](../administration/Blacklist.md)を参照してください。

SQLブラックリストを有効にするには、次のステートメントを実行します。

```SQL
ADMIN SET FRONTEND CONFIG ("enable_sql_blacklist" = "true");
```

その後、[ADD SQLBLACKLIST](../sql-reference/sql-statements/Administration/ADD_SQLBLACKLIST.md)を使用して、SQLパターンを表す正規表現をSQLブラックリストに追加することができます。

次の例では、`COUNT(DISTINCT)`をSQLブラックリストに追加しています。

```SQL
ADD SQLBLACKLIST "SELECT COUNT(DISTINCT .+) FROM .+";
```
