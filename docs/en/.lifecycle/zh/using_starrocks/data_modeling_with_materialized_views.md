---
displayed_sidebar: English
---

# 使用物化视图进行数据建模

本主题描述了如何借助 StarRocks 的异步物化视图来进行数据建模。通过这样做，您可以大大简化数据仓库的 ETL 管道，并显著提高数据质量和查询性能。

## 概述

数据建模是清理、分层、聚合和关联数据的过程，可以使用理性方法创建可理解的原始数据表示形式。这些原始数据可能过于粗糙、过于复杂或成本太高，无法直接进行分析，数据建模可以为这些数据提供可操作的见解。

然而，在实际的数据建模中，常见的挑战是建模过程难以跟上业务发展的步伐，难以衡量数据建模工作的投资回报。尽管建模方法很简单，但业务专家需要具备扎实的数据组织和治理背景，这是一个复杂的过程。在业务早期阶段，决策者很少会为数据建模投入足够的资源，很难看到数据建模所带来的价值。此外，商业模式可能会快速变化，建模方法本身也需要迭代和演进。因此，许多数据分析师倾向于避免建模，直接使用原始数据，从而不可避免地导致数据质量和查询性能的问题。当需要进行建模时，很难重构已经建立的数据分析模式以匹配数据模型的分析模式。

使用物化视图进行数据建模可以有效地解决这些问题。StarRocks 的异步物化视图可以：

- **简化数据仓库架构**：由于 StarRocks 可以提供一站式的数据治理体验，因此您无需维护其他数据处理系统，节省了在这些系统上花费的人力和系统资源。
- **简化数据建模体验**：任何只具备基本 SQL 知识的数据分析师都可以使用 StarRocks 进行数据建模。数据建模不再是经验丰富的数据工程师的专属领域。
- **降低维护复杂度**：StarRocks 的异步物化视图可以自动管理数据层之间的血缘关系和依赖关系，无需整个数据平台来处理这些任务。

![建模-1](../assets/Modeling-1.png)

在实际情况下，您可以通过结合使用 StarRocks 的视图（逻辑视图）和异步物化视图来执行数据建模，具体如下：

1. 使用视图将实时数据与维度数据关联，使用物化视图将数据湖中的历史数据与维度数据关联。进行必要的数据清洗和语义映射，获取中间层的详细数据，以反映业务场景中所需的语义。
2. 在应用层，根据不同的业务场景执行数据 Join、Aggregation、Union 和 Window 计算。这将为实时管道生成视图，并为近实时管道生成物化视图。
3. 在应用端，根据您的时效性和性能要求选择适当的分析数据存储（ADS）进行查询分析。这些 ADS 可以为实时仪表板、近实时 BI、临时查询和定期报告提供服务。

在此过程中，您将利用 StarRocks 的多项内置功能，这些功能将在下一节中详细介绍。

## 异步物化视图的功能

StarRocks 的异步物化视图具有以下原子功能，可帮助进行数据建模：

- **自动刷新**：在将数据加载到基本表后，物化视图可以自动刷新。您无需外部维护调度任务。
- **分区刷新**：通过使用 PARTITION BY 子句，可以将基表的分区与物化视图的分区关联起来，从而实现分区级别的刷新。
- **与视图协同**：通过使用物化视图和逻辑视图实现多层建模，实现中间层的重用和数据模型的简化。
- **模式更改**：您可以通过简单的 SQL 语句修改计算结果，而无需修改复杂的数据管道。

通过这些功能，您可以设计全面且适应性强的数据模型，以满足各种业务需求和场景。

### 自动刷新

在创建异步物化视图时，可以使用 REFRESH 子句指定刷新策略。目前，StarRocks 支持以下异步物化视图的刷新策略：

- **自动刷新**（`REFRESH ASYNC`）：每当基表中的数据发生变化时，都会触发刷新任务。数据依赖关系由物化视图自动管理。
- **定时刷新**（`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`）：刷新任务会定期触发，例如每分钟、每天或每月。如果基表中没有数据变化，则不会触发刷新任务。
- **手动刷新**（`REFRESH MANUAL`）：刷新任务只能通过手动执行 REFRESH MATERIALIZED VIEW 来触发。当您维护外部调度框架以触发刷新任务时，可以使用此刷新策略。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### 分区刷新

在创建异步物化视图时，可以使用 PARTITION BY 子句指定分区策略，将基表的分区与物化视图的分区关联起来，从而实现分区级别的刷新。

- `PARTITION BY <column>`：可以引用相同的分区列来对基表和物化视图进行分区。因此，基表和物化视图的粒度相同。
- `PARTITION BY date_trunc(<column>)`：您可以使用 date_trunc 函数通过截断时间单位为物化视图分配不同的分区策略（在粒度级别上）。
- `PARTITION BY { time_slice | date_slice }(<column>)`：与 date_trunc 相比，time_slice 和 date_slice 提供更灵活的时间粒度调整，允许根据时间对分区进行更精细的控制。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### 与视图的协同作用

- 可以基于视图创建物化视图。这种情况下，当视图引用的基表发生数据变化时，物化视图可以自动刷新。
- 您还可以基于其他物化视图创建物化视图，从而启用多级级联刷新机制。
- 视图可以基于物化视图创建，物化视图等同于常规表。

### 模式更改

- 可以使用 ALTER MATERIALIZED VIEW SWAP 语句在两个异步物化视图之间执行原子交换。这允许您使用添加的列或更改的列类型创建新的物化视图，然后用它替换旧视图。
- 可以使用 ALTER VIEW 语句直接修改视图的定义。
- StarRocks 中的常规表可以通过 SWAP 或 ALTER 操作进行修改。
- 此外，当基表（可以是物化视图、视图或常规表）发生更改时，会触发相应物化视图中的级联更改。

## 分层建模

在许多实际业务场景中，存在各种形式的数据源，包括实时详细数据、维度数据和数据湖中的历史数据。另一方面，业务需求需要多种分析方法，例如实时仪表板、近乎实时的 BI 查询、临时查询和定期报告。不同的场景有不同的需求，有些需要灵活性，有些优先考虑性能，而另一些则强调成本效益。

显然，单一的解决方案无法充分满足如此多样的需求。StarRocks 可以通过结合视图和物化视图的使用来有效地满足这些需求。由于视图不维护任何物理数据，因此每次查询视图时，都会根据视图的定义解析和执行查询。相比之下，包含预先计算结果的物化视图可以防止重复执行的开销。视图适合表达业务语义和简化 SQL 复杂度，但不能降低查询执行成本。而物化视图则通过预计算优化查询性能，适用于简化 ETL 流水线。

以下是视图和物化视图之间差异的摘要：

|                                      | **视图**                                                     | **物化视图**                                        |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **使用案例**                        | 业务建模、数据治理                           | 数据建模、透明加速、数据湖集成 |
| **存储成本**                     | 无存储成本                                              | 存储预先计算的结果所产生的存储成本        |
| **更新成本**                      | 无更新成本                                               | 基表数据更新时产生的刷新成本           |
| **性能优势**             | 无性能优势                                       | 通过重用预计算结果引入的查询加速 |
| **数据实时属性** | 返回最新数据，因为对视图的查询是实时计算的。 | 数据可能不是最新的，因为结果是预先计算的。 |
| **依赖关系**                       | 如果基表名称因按名称引用基表而更改，则视图将失效。 | 基表名称的更改不会影响物化视图的可用性，物化视图按 ID 引用基表。 |
| **创建语法**              | CREATE VIEW                                                  | CREATE MATERIALIZED VIEW                                     |
| **修改语法**          | ALTER VIEW                                                   | ALTER MATERIALIZED VIEW                                      |

您可以使用以下语句来修改视图、物化视图和基表：

```SQL
-- 修改表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 交换两个表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图的定义。
ALTER VIEW <view_name> AS <query>;

-- 交换两个物化视图 
-- （通过交换两个物化视图的名称而不影响其中的数据）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- 重新激活物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

架构更改遵循以下原则：

- 对表的重命名和交换操作会使依赖的物化视图处于非活动状态。对于架构更改操作，仅当对物化视图引用的基表列执行架构更改操作时，依赖物化视图才会设置为非活动状态。
- 如果更改视图的定义，则从属物化视图将设置为非活动状态。
- 如果交换了物化视图，则在其上构建的任何嵌套物化视图都将设置为非活动状态。
- 非活动状态向上级联，直到没有物化视图依赖关系。
- 非活动物化视图无法刷新或用于自动查询重写。
- 非活动物化视图仍可直接查询，但在其再次处于活动状态之前，无法保证数据一致性。

虽然无法保证非活动物化视图的数据一致性，但您可以使用以下方法恢复它们的功能：

- **手动修复**：您可以通过执行 ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE 来手动修复非活动的物化视图。此语句将基于其原始 SQL 定义重新创建物化视图。请注意，在基础架构更改后，SQL 定义必须仍然有效，否则操作将失败。
- **自动修复**：StarRocks 将尝试自动激活不活跃的物化视图。但是，无法保证这一过程的及时性。

## 分区建模

除了分层建模之外，分区建模也是数据建模的一个重要方面。数据建模通常涉及根据业务语义关联数据，并根据时效性要求设置数据的生存时间（TTL）。分区建模在此过程中起着重要作用。

分区建模是数据建模的一个重要方面，是对分层建模的补充。它涉及根据业务语义关联数据，并根据时效性要求为数据设置生存时间（TTL）。数据分区在此过程中起着重要作用。

不同的数据关联方式催生了各种建模方法，例如星型模式和雪花模式。这些模型有一些共同点 - 它们都使用事实表和维度表。某些业务场景需要多个大型事实数据表，而其他业务场景则需要处理复杂的维度表及其之间的关系。StarRocks 的物化视图支持对事实表进行分区关联，即对事实表进行分区，物化视图的连接结果也以同样的方式进行分区。

![建模-2](../assets/Modeling-2.png)

如上图所示，物化视图将事实表与多个维度表相关联：

- 您需要引用特定基表（通常是事实表）的分区键作为物化视图的分区键（`PARTITION BY fact_tbl.col`），以关联其分区策略。每个物化视图只能与一个基表相关联。
- 当引用表的某个分区中的数据发生更改时，将刷新物化视图中的相应分区，而不会影响其他分区。
- 当非引用表中的数据发生更改时，默认情况下会刷新整个物化视图。但是，您可以选择忽略某些非引用基表中的数据更改，以便在这些表中的数据发生更改时不会刷新物化视图。

这种分区关联支持各种业务场景：

- **事实数据表更新**：您可以对事实数据表进行细粒度分区，例如每天或每小时。事实数据表更新后，物化视图中对应的分区会自动刷新。
- **维度表更新**：通常，维度表中的数据更新将导致刷新所有关联结果，这可能代价高昂。您可以选择忽略某些维度表中的数据更新，以避免刷新整个物化视图，也可以指定时间范围，以便仅刷新时间范围内的分区。
- **外部表自动刷新**：在 Apache Hive 或 Apache Iceberg 等外部数据源中，数据在分区级别发生变化。StarRocks 的物化视图可以在分区级别订阅外部目录的更改，并且只刷新物化视图的对应分区。
- **TTL**：在设置物化视图的分区策略时，可以设置要保留的最近分区数，从而仅保留最新的数据。这在业务场景中非常有用，因为分析师只查询特定时间窗口的最新数据，并且不需要保留所有历史数据。

可以使用多个参数来控制刷新行为：

- `partition_refresh_number`：每次刷新操作中要刷新的分区数。
- `partition_ttl_number`：要保留的最近分区数。
- `excluded_trigger_tables`：可以忽略其数据更改以避免触发自动刷新的表。
- `auto_refresh_partitions_limit`：每次自动刷新操作中要刷新的分区数。

有关详细信息，请参阅 [CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

目前，分区物化视图具有以下限制：

- 只能基于分区表构建分区物化视图。
- 只能使用 DATE 或 DATETIME 类型列作为分区键。不支持 STRING 数据类型。
- 只能使用 date_trunc、time_slice 和 date_slice 函数执行分区汇总。
- 只能将单个列指定为分区键。不支持多个分区列。

## 总结
利用 StarRocks 的异步物化视图进行数据建模，可以简化流水线管理，并通过声明式建模语言提高数据建模的效率和灵活性。

除了数据建模之外，StarRocks 的异步物化视图还适用于各种场景，包括透明加速和数据湖集成。这有利于进一步挖掘数据的价值，提高数据的效率。