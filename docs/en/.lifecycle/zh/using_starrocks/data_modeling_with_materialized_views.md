---
displayed_sidebar: English
---

很明显，单一的解决方案无法充分满足如此多样化的需求。StarRocks可以通过结合使用视图和物化视图来高效地满足这些需求。因为视图不维护任何物理数据，每次查询视图时，都会根据视图的定义进行解析和执行。相比之下，物化视图持有预先计算的结果，可以避免重复执行的开销。视图适用于表达业务语义和简化SQL复杂性，但无法降低查询执行的成本。物化视图则通过预计算优化查询性能，适用于简化ETL管道。

下面是视图和物化视图之间的区别总结：

|**视图**|**物化视图**|
|---|---|---|
|**用途**|业务建模，数据治理|数据建模，透明加速，数据湖集成|
|**存储成本**|无存储成本|存储预计算结果所产生的存储成本|
|**更新成本**|无更新成本|基表数据更新时产生的刷新成本|
|**性能优势**|无性能优势|通过重用预计算结果引入的查询加速|
|**数据实时属性**|由于对视图的查询是实时计算的，因此返回的是最新数据。|由于结果是预先计算的，因此数据可能不是最新的。|
|**依赖关系**|如果基表名称发生更改，视图将变为无效，因为它们通过名称引用基表。|基表名称的更改不会影响物化视图的可用性，物化视图通过ID引用基表。|
|**创建语法**|CREATE VIEW|CREATE MATERIALIZED VIEW|
|**修改语法**|ALTER VIEW|ALTER MATERIALIZED VIEW|

您可以使用以下语句修改视图、物化视图和基表：

```SQL
-- 修改表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 交换两个表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图的定义。
ALTER VIEW <view_name> AS <query>;

-- 交换两个物化视图
-- （通过交换两个物化视图的名称而不影响其中的数据）。
ALTER MATERIALIZED VIWE <mv1> SWAP WITH <mv2>;

-- 重新激活物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

架构变更遵循以下原则：

- 对表进行重命名和交换操作将使依赖的物化视图无效。对于架构更改操作，只有在对物化视图引用的基表列执行架构更改操作时，才会将依赖的物化视图设置为无效。
- 如果更改视图的定义，则将依赖的物化视图设置为无效。
- 如果交换了物化视图，任何嵌套在其上构建的物化视图都将被设置为无效。
- 无效的物化视图无法刷新或用于自动查询重写。
- 无效的物化视图仍然可以直接查询，但在重新激活之前，数据一致性无法保证。

虽然无效物化视图的数据一致性无法保证，但您可以使用以下方法恢复它们的功能：

- **手动修复**：您可以通过执行 ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE 来手动修复无效的物化视图。此语句将根据其原始SQL定义重新创建物化视图。请注意，在底层模式更改后，SQL定义仍然必须有效，否则操作将失败。
- **自动修复**：StarRocks将尝试自动激活无效的物化视图。但无法保证此过程的及时性。

## 分区建模

除了分层建模，分区建模也是数据建模的一个重要方面。数据建模通常涉及基于业务语义关联数据，并根据时效性要求设置数据的存活时间（TTL）。分区建模在这个过程中起着重要的作用。

分区建模是数据建模的一个重要方面，是分层建模的补充。它涉及基于业务语义关联数据，并根据时效性要求设置数据的存活时间（TTL）。数据分区在这个过程中起着重要的作用。

不同的关联数据方式导致了各种建模方法，例如星型模式和雪花模式。这些模型有一个共同点 - 它们都使用事实表和维度表。一些业务场景需要多个大型事实表，而其他场景涉及复杂的维度表及其之间的关系。StarRocks的物化视图支持对事实表进行分区关联，即事实表进行分区，物化视图的连接结果也进行相同的分区。

![Modeling-2](../assets/Modeling-2.png)

如上图所示，物化视图将事实表与多个维度表关联起来：

- 您需要将特定基表（通常是事实表）的分区键（`PARTITION BY fact_tbl.col`）作为物化视图的分区键来关联它们的分区策略。每个物化视图只能与一个基表关联。
- 当引用表的分区中的数据发生变化时，物化视图中相应的分区将自动刷新，而不影响其他分区。
- 当非引用表中的数据发生变化时，默认情况下将刷新整个物化视图。但是，您可以选择忽略某些非引用基表中的数据更改，以避免在这些表中的数据更改时刷新整个物化视图。

这种分区关联支持各种业务场景：

- **事实表更新**：您可以将事实表进行细粒度的分区，例如按日或按小时。事实表更新后，物化视图中相应的分区将自动刷新。
- **维度表更新**：通常情况下，维度表中的数据更新将导致刷新所有关联的结果，这可能是昂贵的。您可以选择忽略某些维度表中的数据更新，以避免刷新整个物化视图，或者您可以指定一个时间范围，只刷新时间范围内的分区。
- **外部表自动刷新**：在Apache Hive或Apache Iceberg等外部数据源中，数据更改是在分区级别上进行的。StarRocks的物化视图可以订阅外部目录中的分区级别的更改，并仅刷新物化视图的相应分区。
- **TTL**：在为物化视图设置分区策略时，您可以设置保留的最近分区数，从而仅保留最近的数据。这在业务场景中非常有用，分析师只需要从一定时间窗口内查询最新的数据，而不需要保留所有的历史数据。

可以使用以下参数来控制刷新行为：

- `partition_refresh_number`：每次刷新操作中要刷新的分区数。
- `partition_ttl_number`：要保留的最近分区数。
- `excluded_trigger_tables`：可以忽略的数据更改表，以避免触发自动刷新。
- `auto_refresh_partitions_limit`：每次自动刷新操作中要刷新的分区数。

有关更多信息，请参见[CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

目前，分区物化视图具有以下限制：

- 只能基于分区表构建分区物化视图。
- 只能使用DATE或DATETIME类型的列作为分区键，不支持STRING数据类型。
- 只能使用date_trunc、time_slice和date_slice函数执行分区卷积。
- 只能指定单个列作为分区键，不支持多个分区列。

## 总结

利用StarRocks的异步物化视图进行数据建模，可以通过声明性建模语言简化管道管理，提高数据建模的效率和灵活性。

除了数据建模，StarRocks的异步物化视图在透明加速和数据湖集成等各种场景中都有应用。这有助于进一步探索数据价值并提高数据效率。
```
利用 StarRocks 的异步物化视图进行数据建模，可以简化管道管理，并通过声明式建模语言提高数据建模的效率和灵活性。

除了数据建模之外，StarRocks 的异步物化视图还适用于涉及透明加速和数据湖集成的各种场景。这有助于进一步探索数据价值并提高数据效率。
# 使用物化视图进行数据建模

本主题介绍了如何借助 StarRocks 的异步物化视图来进行数据建模。通过这样做，您可以极大地简化数据仓库的 ETL 流程，并显著提高数据质量和查询性能。

## 概述

数据建模是清洗、分层、聚合和关联数据的过程，采用合理的方法论。它可以创建一个可理解的表示原始数据的模型，这些数据过于粗糙、过于复杂或者分析成本过高，从而为数据提供可操作的洞察力。

然而，现实世界中数据建模面临的常见挑战是，建模过程难以跟上业务发展的速度，很难衡量数据建模工作的投资回报。尽管建模方法论很简单，但业务专家需要具备扎实的数据组织和治理背景，这是一个复杂的过程。在业务的早期阶段，决策者很少会为数据建模投入足够的资源，很难看到数据建模能带来的价值。此外，业务模型可能会迅速变化，建模方法论本身也需要迭代和演进。因此，许多数据分析师倾向于避免建模，直接使用原始数据，从而不可避免地导致数据质量和查询性能的问题。当需要建模时，已经建立的数据分析模式很难重构以匹配数据模型的模式。

使用物化视图进行数据建模可以有效解决这些问题。StarRocks 的异步物化视图可以：

- **简化数据仓库架构**：由于 StarRocks 可以提供一站式的数据治理体验，您无需维护其他数据处理系统，节省了人力和系统资源。
- **简化数据建模体验**：只需具备基本的 SQL 知识，任何数据分析师都可以使用 StarRocks 进行数据建模。数据建模不再是经验丰富的数据工程师的专属领域。
- **降低维护复杂性**：StarRocks 的异步物化视图可以自动管理数据层之间的血缘关系和依赖关系，无需整个数据平台来处理此任务。

![Modeling-1](../assets/Modeling-1.png)

在实际情况下，您可以通过结合使用 StarRocks 的视图（逻辑视图）和异步物化视图来进行数据建模，如下所示：

1. 使用视图将实时数据与维度数据关联，使用物化视图将数据湖中的历史数据与维度数据关联。执行必要的数据清洗和语义映射，获取中间层的详细数据，反映您业务场景中所需的语义。
2. 在应用层中，根据不同的业务场景执行数据连接、聚合、合并和窗口计算。这将产生用于实时流水线的视图和用于准实时流水线的物化视图。
3. 在应用端，根据您的及时性和性能要求选择适当的分析数据存储（ADS）进行查询分析。这些 ADS 可用于实时仪表盘、准实时 BI、即席查询和定期报告。

在此过程中，您将利用 StarRocks 的几个内置功能，这些功能将在下一节中详细介绍。

## 异步物化视图的能力

StarRocks 的异步物化视图具有以下原子功能，可以帮助进行数据建模：

- **自动刷新**：在数据加载到基表后，物化视图可以自动刷新。您无需外部维护调度任务。
- **分区刷新**：通过基于时间序列的表的分区刷新，可以实现准实时计算。
- **与视图的协同**：通过使用物化视图和逻辑视图，可以实现多层建模，从而实现中间层的重用和数据模型的简化。
- **模式更改**：您可以通过简单的 SQL 语句更改计算结果，而无需修改复杂的数据流程。

有了这些功能，您可以设计全面且适应性强的数据模型，以满足各种业务需求和场景。

### 自动刷新

创建异步物化视图时，可以使用 REFRESH 子句指定刷新策略。目前，StarRocks 支持以下异步物化视图的刷新策略：

- **自动刷新**（`REFRESH ASYNC`）：每当基表中的数据发生变化时，将触发刷新任务。数据依赖关系由物化视图自动管理。
- **定期刷新**（`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`）：以固定的时间间隔触发刷新任务，例如每分钟、每天或每月。如果基表中没有数据变化，则不会触发刷新任务。
- **手动刷新**（`REFRESH MANUAL`）：仅通过执行 REFRESH MATERIALIZED VIEW 手动触发刷新任务。当您维护一个外部调度框架来触发刷新任务时，可以使用此刷新策略。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### 分区刷新

创建异步物化视图时，可以使用 PARTITION BY 子句将基表的分区与物化视图的分区关联起来，从而实现分区级别的刷新。

- `PARTITION BY <column>`：您可以引用基表和物化视图的相同分区列。结果是，基表和物化视图在相同的粒度上进行分区。
- `PARTITION BY date_trunc(<column>)`：您可以使用 date_trunc 函数通过截断时间单位来为物化视图分配不同的分区策略（在粒度级别上）。
- `PARTITION BY { time_slice | date_slice }(<column>)`：与 date_trunc 相比，time_slice 和 date_slice 提供了更灵活的时间粒度调整，可以更精细地控制基于时间的分区。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### 与视图的协同

- 可以基于视图创建物化视图。在这种情况下，当视图引用的基表发生数据变化时，物化视图可以自动刷新。
- 您还可以基于其他物化视图创建物化视图，实现多级级联刷新机制。
- 可以基于物化视图创建视图，这相当于常规表。

### 模式更改

- 您可以使用 ALTER MATERIALIZED VIEW SWAP 语句在两个异步物化视图之间执行原子交换。这样，您可以创建一个具有添加列或更改列类型的新物化视图，然后用它替换旧物化视图。
- 可以使用 ALTER VIEW 语句直接修改视图的定义。
- StarRocks 中的常规表可以使用 SWAP 或 ALTER 操作进行修改。
- 此外，当基表发生更改时（可以是物化视图、视图或常规表），会触发相应物化视图的级联更改。

## 分层建模

在许多实际业务场景中，存在各种形式的数据源，包括实时详细数据、维度数据和来自数据湖的历史数据。另一方面，业务需求需要各种分析方法，例如实时仪表盘、准实时 BI 查询、即席查询和定期报告。不同的场景有不同的需求 - 有些需要灵活性，有些优先考虑性能，而其他一些则强调成本效益。

显然，单一解决方案无法充分满足如此多样化的需求。StarRocks 可以通过结合使用视图和物化视图来有效解决这些需求。因为视图不维护物理数据，每次查询视图时，都会根据视图的定义进行解析和执行。相比之下，物化视图保存了预计算结果，可以避免重复执行的开销。视图适用于表达业务语义和简化 SQL 复杂性，但无法降低查询执行的成本。物化视图则通过预计算优化查询性能，适用于简化 ETL 流程。

下面是视图和物化视图之间的差异总结：

|**视图**|**物化视图**|
|---|---|---|
|**用途**|业务建模、数据治理|数据建模、透明加速、数据湖集成|
|**存储成本**|无存储成本|存储预计算结果产生的存储成本|
|**更新成本**|无更新成本|基表数据更新时产生的刷新成本|
|**性能优势**|无性能优势|重用预计算结果带来的查询加速|
|**数据实时属性**|由于对视图的查询是实时计算的，因此返回的是最新数据。|数据可能不是最新的，因为结果是预先计算的。|
|**依赖关系**|如果基表名称发生更改，视图将变为无效，因为它们通过名称引用基表。|基表名称的更改不会影响物化视图的可用性，物化视图通过 ID 引用基表。|
|**创建语法**|CREATE VIEW|CREATE MATERIALIZED VIEW|
|**修改语法**|ALTER VIEW|ALTER MATERIALIZED VIEW|

您可以使用以下语句修改视图、物化视图和基表：

```SQL
-- 修改表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 交换两个表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图的定义。
ALTER VIEW <view_name> AS <query>;

-- 交换两个物化视图
--（通过交换两个物化视图的名称而不影响其中的数据）。
ALTER MATERIALIZED VIWE <mv1> SWAP WITH <mv2>;

-- 重新激活物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

模式更改遵循以下原则：

- 对表进行重命名和交换操作将使依赖的物化视图变为非活动状态。对于模式更改操作，只有在执行模式更改操作时，基表列被物化视图引用时，依赖的物化视图才会被设置为非活动状态。
- 如果更改视图的定义，依赖的物化视图将被设置为非活动状态。
- 如果交换了物化视图，任何嵌套在其上的物化视图都将被设置为非活动状态。
- 非活动状态向上级联，直到没有物化视图依赖为止。
- 非活动状态的物化视图无法刷新或用于自动查询重写。
- 非活动状态的物化视图仍然可以直接查询，但在重新激活之前，数据一致性不能得到保证。

虽然无法保证非活动物化视图的数据一致性，但您可以使用以下方法恢复它们的功能：

- **手动修复**：您可以通过执行 ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE 来手动修复非活动物化视图。此语句将根据其原始 SQL 定义重新创建物化视图。请注意，在底层模式更改后，SQL 定义仍然必须有效，否则操作将失败。
- **自动修复**：StarRocks 将尝试自动激活非活动物化视图。但无法保证此过程的及时性。

## 分区建模

除了分层建模，分区建模也是数据建模的重要方面。数据建模通常涉及基于业务语义关联数据和根据及时性要求设置数据的生存时间（TTL）。分区建模在此过程中起着重要作用。

分区建模是数据建模的重要方面，是分层建模的补充。它涉及基于业务语义关联数据和根据及时性要求设置数据的生存时间（TTL）。数据分区在此过程中起着重要作用。

不同的数据关联方式导致了各种建模方法，例如星型模式和雪花模式。这些模型有一个共同点 - 它们都使用事实表和维度表。一些业务场景需要多个大型事实表，而其他业务场景涉及复杂的维度表及其之间的关系。StarRocks 的物化视图支持对事实表进行分区关联，即事实表进行分区，物化视图的连接结果也进行相同的分区。

![Modeling-2](../assets/Modeling-2.png)

如上图所示，一个物化视图将事实表与多个维度表关联起来：

- 您需要将特定基表（通常是事实表）的分区键引用为物化视图的分区键（`PARTITION BY fact_tbl.col`），以关联它们的分区策略。每个物化视图只能与一个基表关联。
- 当引用表的分区中的数据发生变化时，物化视图中对应的分区将被刷新，而不影响其他分区。
- 当非引用表中的数据发生变化时，默认情况下将刷新整个物化视图。但是，您可以选择忽略某些非引用基表中的数据变化，以避免在这些表中的数据变化时刷新整个物化视图。

这种分区关联支持各种业务场景：

- **事实表更新**：您可以以精细的粒度（例如每天或每小时）对事实表进行分区。事实表更新后，物化视图中相应的分区将自动刷新。
- **维度表更新**：通常，维度表中的数据更新将导致刷新所有关联的结果，这可能很昂贵。您可以选择忽略某些维度表中的数据更新，以避免刷新整个物化视图，或者可以指定一个时间范围，以便仅刷新时间范围内的分区。
- **外部表自动刷新**：在 Apache Hive 或 Apache Iceberg 等外部数据源中，数据变化是在分区级别上进行的。StarRocks 的物化视图可以订阅外部目录的分区级别的更改，并仅刷新物化视图的相应分区。
- **TTL**：在为物化视图设置分区策略时，您可以设置要保留的最近分区的数量，从而仅保留最新的数据。这在业务场景中非常有用，分析师只需要从某个时间窗口中查询最新的数据，而不需要保留所有历史数据。

可以使用几个参数来控制刷新行为：

- `partition_refresh_number`：每次刷新操作中要刷新的分区数。
- `partition_ttl_number`：要保留的最近分区的数量。
- `excluded_trigger_tables`：可以忽略的数据更改的表，以避免触发自动刷新。
- `auto_refresh_partitions_limit`：每次自动刷新操作中要刷新的分区数。

有关更多信息，请参见 [CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

目前，分区物化视图具有以下限制：

- 只能基于分区表构建分区物化视图。
- 只能使用 DATE 或 DATETIME 类型的列作为分区键，不支持 STRING 数据类型。
- 只能使用 date_trunc、time_slice 和 date_slice 函数执行分区卷积。
- 只能指定单个列作为分区键，不支持多个分区列。

## 总结

利用 StarRocks 的异步物化视图进行数据建模，可以通过声明性建模语言简化管道管理，并通过预计算优化查询性能，提高数据建模的效率和灵活性。

除了数据建模之外，StarRocks 的异步物化视图还可以应用于涉及透明加速和数据湖集成的各种场景。这有利于进一步挖掘数据价值，提高数据效率。