---
displayed_sidebar: "中文"
---

# 使用物化视图进行数据建模

本文描述了如何通过 StarRocks 的异步物化视图来进行数据建模，从而极大地简化数据仓库的 ETL Pipeline，并显著提高数据质量和查询性能。

## 概述

数据建模是通过合理的方法进行数据清洗、分层、聚合和关联的过程。当原始数据质量过低，指标过多过于复杂，或未经聚合导致查询成本过高时，您可以通过对原始数据进行建模得到易于理解的、可供使用的数据结果。

然而，在现实数据建模中常见的矛盾在于建模过程难以跟上业务发展的步伐，并且很难衡量数据建模工作的投资回报。建模手段虽然简单，但需要业务专家在数据组织和治理方面有扎实的背景，对数据整理加工，这是个复杂的过程。在业务的早期阶段，决策者通常不会在数据建模方面投入足够资源，并且很难看到数据建模能够带来的价值。此外，由于业务模式可能会迅速变化，而建模方法本身也需要不断迭代和演化。因此，许多数据分析师倾向于不使用数据建模，直接使用原始数据，从而不可避免地导致数据质量和查询性能的问题。当建模的需求出现时，又遇到数据使用方式已经成型，难以重构的问题。

使用 StarRocks 物化视图进行数据建模可以有效解决以上问题。StarRocks 异步物化视图具备以下能力：

- **简化数仓架构**：由于 StarRocks 可以提供一站式数据治理体验，您无需维护其他数据处理系统或组件，节省了用于维护这些系统的人力和物理资源。
- **简化建模体验**：任何只具备基本 SQL 知识的数据分析师都可以使用 StarRocks 进行数据建模，无需专业数据工程师。
- **简化系统维护**：StarRocks 的异步物化视图可以自动管理数据之间的层级和依赖关系，无需整个数据平台来处理此任务。

![Modeling-1](../assets/Modeling-1.png)

在实际情况中，您可以通过结合使用 StarRocks 的视图（逻辑视图）和异步物化视图来进行数据建模，如下所示：

1. 使用视图将实时数据与维度数据关联，并使用物化视图将数据湖中的历史数据与维度数据关联。同时进行必要的数据清洗和业务语义映射，以得到反映业务语义明细数据的中间层（Intermediate Layer）。
2. 在应用层（Application Layer）中，面向不同的业务场景，进行数据的 Join、Agg、Union、Window 计算，生成用于实时链路的视图和用于近实时链路的物化视图。
3. 在应用侧（Application），根据您的时效性和性能要求选择适当的分析数据存储（ADS）进行查询分析，服务于实时大屏、近实时 BI、Ad hoc 查询和定时报告等需求。

在此过程中，您将利用 StarRocks 的几种内置能力，这些能力将在下一节中详细阐述。

## 异步物化视图的能力

StarRocks 的异步物化视图具备以下原子能力，可助力数据建模：

- **自动刷新**：在数据导入至基表后，物化视图可以自动刷新。您无需在外部维护调度任务。
- **分区刷新**：通过有时序属性的报表，可以通过分区刷新实现近实时计算。
- **与视图协同使用**：通过协同使用物化视图和逻辑视图，您可以实现多层建模，从而实现中间层的重复使用和数据模型的简化。
- **Schema Change**：您可以通过简单的 SQL 语句更改计算结果，无需修改复杂的数据流水线。

借助以上功能，您可以设计全面且灵活的数据模型，以满足各种业务需求和场景。

### 自动刷新

创建异步物化视图时，您可以使用 REFRESH 子句指定刷新策略。目前，StarRocks 异步物化视图支持以下刷新策略：

- 自动刷新（`REFRESH ASYNC`）：每当基表中的数据发生变化时，都会触发刷新任务。数据依赖关系由物化视图自动管理。
- 定时刷新（`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`）：定期触发刷新任务，例如，每分钟、每天或每月。如果基表中没有数据更改，将不会触发刷新任务。
- 手动刷新（`REFRESH MANUAL`）：您只能通过手动执行 `REFRESH MATERIALIZED VIEW` 触发刷新任务。如果您通过外部调度框架触发刷新任务，可以使用此刷新策略。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### 分区刷新

创建异步物化视图时，您可以使用 PARTITION BY 子句将基表的分区与物化视图的分区关联起来，从而实现分区粒度的刷新。

- `PARTITION BY <column>`：您可以为物化视图引用与基表相同的分区列，从而使基表和物化视图采用相同的分区粒度。
- `PARTITION BY date_trunc(<column>)`：您可以使用 date_trunc 函数在基表分区列的基础上上卷，从而为物化视图制定不同粒度的分区策略。
- `PARTITION BY { time_slice | date_slice }(<column>)`：与 date_trunc 相比，time_slice 和 date_slice 提供更灵活的时间粒度调整，允许更精细地控制时间分区粒度。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### 与视图的协同使用

- 可以基于视图创建物化视图。此时，当视图引用的基表发生数据更改时，物化视图可以自动刷新。
- 可以基于其他物化视图创建物化视图，实现多层级联式刷新。
- 可以基于物化视图创建视图，等同于基于常规表创建。

### Schema Change

- 异步物化视图可以通过 ALTER MATERIALIZED VIEW SWAP 语句进行原子替换。您可以创建一个新物化视图，并增加新列或更改列类型，然后用新物化视图替换旧物化视图。
- 视图可以通过 ALTER VIEW 语句直接修改定义。
- StarRocks 中的常规表可以使用 SWAP 或 ALTER 操作进行修改。
- 此外，当基表（可以是物化视图、视图或普通表）发生变化时，会触发相关物化视图中的级联变更。

## 分层建模

在许多实际业务场景中，存在着各种形式的数据源，包括实时的详细数据、维度数据以及数据湖中的归档数据。另一方面，业务需求对于分析方法的多样性要求也很高，比如实时的大屏显示、准实时的BI查询、分析师的临时查询以及定时的报告等。不同的场景有着不同的需求 —— 有些需要灵活性，有些则更重视性能，而其他一些则注重成本效益。

显而易见，单一解决方案无法有效满足这些多样化的需求。StarRocks 能够通过结合视图和物化视图的使用，有效满足这些需求。由于视图不维护物理数据，每次查询视图时都要根据视图定义解析并执行查询。与此相反，物化视图保存了预计算的结果，能够避免重复执行造成的开销。视图适合表达业务语义并简化SQL复杂度，但无法减少查询执行的开销。另一方面，物化视图通过预先计算，优化了查询性能，适用于简化ETL管道。

以下是视图和物化视图的区别：

|                | **视图**                                   | **物化视图**                                       |
| -------------- | ------------------------------------------ | -------------------------------------------------- |
| **使用场景**   | 业务建模、数据治理                         | 数据建模、透明加速、一体化湖仓                     |
| **存储开销**   | 不存储数据，无存储开销                     | 存储预计算结果，有额外存储成本                     |
| **更新开销**   | 无更新开销                                 | 基表数据更新时，有更新开销                         |
| **性能收益**   | 不做预计算，无性能收益                     | 预计算结果，加快查询                               |
| **数据实时性** | 查询视图时返回最新数据                     | 预计算结果，可能存在数据延迟                       |
| **依赖关系**   | 基于表名引用基表，基表名变更会导致视图无效 | 基于ID引用基表，基表名变更不影响物化视图          |
| **创建语法**   | CREATE VIEW                                | CREATE MATERIALIZED VIEW                           |
| **修改语法**   | ALTER VIEW                                 | ALTER MATERIALIZED VIEW                            |

您可以使用以下语句来修改您的视图、物化视图和基表：

```SQL
-- 修改基表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 原子替换基表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图定义。
ALTER VIEW <view_name> AS <query>;

-- 原子替换物化视图（替换两个物化视图的名称，不修改数据）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- 重新激活物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

Schema变更遵循以下原则：

- 表的重命名和原子替换操作会导致依赖它的物化视图变为Inactive状态。只有当物化视图所依赖的基表列进行了Schema变更时，物化视图才会变为Inactive状态。
- 视图的定义变更会导致依赖它的物化视图变为Inactive状态。
- 物化视图的原子替换操作会导致依赖它的嵌套物化视图变为Inactive状态。
- Inactive状态会向上传播，直到没有物化视图依赖为止。
- Inactive状态的物化视图不能用于刷新或自动查询重写。
- Inactive状态的物化视图仍可以直接查询，但在激活之前，数据一致性不能保证。

由于Inactive状态的物化视图数据一致性无法保证，您可以使用以下方法修复：

- **手动修复**：您可以通过执行ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE来手动修复Inactive状态的物化视图。这个语句会尝试根据物化视图最初的SQL定义来重建。需要注意的是，重建时必须保证底层的Schema变更后，SQL定义仍旧有效，否则操作会失败。
- **自动修复**：StarRocks会尝试自动激活Inactive状态的物化视图，但无法保证及时性。

## 分区建模

除了分层建模，分区建模也是数据建模的一个重要方面。数据建模通常涉及到根据业务逻辑关联数据，并根据时效性要求设定数据的存活时间（TTL）。在此过程中，分区建模起到了重要作用。不同的数据关联方式会产生不同的建模方法，如星型和雪花模式。这些模型有一个共同之处——它们都利用事实表和维度表。一些业务场景需要多个大型事实表，而其他场景则涉及到复杂的维度表和它们之间的关联关系。StarRocks的物化视图支持对事实表的分区联接，即事实表进行分区，物化视图的Join结果按相同方式进行分区。

![Modeling-2](../assets/Modeling-2.png)

以上图为例，通过物化视图关联事实表和多个维度表：

- 您需要在物化视图的分区键中指定某个基表（通常是事实表）的分区键，以实现物化视图的分区联接（`PARTITION BY fact_tbl.col`）。一个物化视图只能和一个基表进行分区联接。
- 当被联接的基表的某个分区数据发生变化时，物化视图中相应的分区会被刷新，但不会影响其他分区。
- 当其他未被联接的基表发生变化时，默认情况下会刷新整个物化视图。不过，您可以选择忽视一些未联接表中的数据变更，这样当这些表中的数据发生变化时不会刷新物化视图。

这种分区联接可以支持多种业务场景：

- **事实表更新**：您可以将事实表划分为更细的粒度，比如按天或按小时。当事实表更新后，物化视图中相应的分区会自动刷新。
- **维度表更新**：通常维度表中的数据更新会导致所有关联结果的刷新，这样的刷新成本较大。您可以选择忽视某些维度表中的更新以避免刷新整个物化视图，或者指定一个时间范围，只有在这个时间范围内的分区会被刷新。
- **外部表的自动刷新**：在类似于Apache Hive或Apache Iceberg的外部数据源中，数据通常会按分区粒度发生变化。StarRocks的物化视图可以订阅外部表分区级别的更新，只刷新物化视图的相关分区。
- **TTL**：在为物化视图设置分区策略时，您可以设置要保留的最新分区的数量，从而只保留最新的数据。这适应了对数据时效性有较高要求的业务场景，例如分析师只需要查询某个时间窗口内的最新数据，而无需保存所有历史数据。

您可以使用多个参数来控制刷新行为：

- `partition_refresh_number`：每次刷新操作时需要刷新的分区数量。
- `partition_ttl_number`：需要保留的最新分区的数量。
- `excluded_trigger_tables`：为避免触发自动刷新而需要排除的表。
- `auto_refresh_partitions_limit`：每次自动刷新操作时需要刷新的分区数量。

详细说明，请参见 [CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

在当前的版本中，分区物化视图有如下限制：

- 只支持基于分区表创建分区物化视图。
- 只支持 DATE 和 DATETIME 类型的分区列，不支持 STRING 类型。
- 只支持使用 date_trunc、time_slice 和 date_slice 进行分区上卷。
- 只支持单一列作为分区列，不支持多个分区列。

## 总结

通过 StarRocks 的异步物化视图进行数据建模，可以通过声明式的建模语言简化数据处理流程的管理，提高数据建模的效率和灵活性。

除了用于数据建模的场景之外，异步物化视图还能应用于其他透明加速场景、湖仓一体场景，从而进一步挖掘数据价值，提高数据的使用效率。