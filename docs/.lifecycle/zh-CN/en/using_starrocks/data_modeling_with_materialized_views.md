---
displayed_sidebar: "Chinese"
---

# 使用物化视图进行数据建模

本主题介绍了如何通过StarRocks的异步物化视图来进行数据建模。通过这种方式，您可以大大简化数据仓库的ETL流程，并显著提高数据质量和查询性能。

## 概述

数据建模是对数据进行清理、分层、聚合和关联的过程，采用合理的方法论。它可以创建原始数据的可理解表示，而原始数据可能太粗糙、过于复杂或成本太高，无法直接进行分析，并为数据提供可操作的见解。

然而，现实世界中数据建模所面临的普遍挑战在于，建模过程难以跟上业务发展的步伐，难以衡量数据建模工作的投资回报。虽然建模方法论很简单，但业务专家需要在数据组织和治理方面具备扎实的背景，这是一个复杂的过程。在企业的初期阶段，决策者很少会为数据建模投入足够的资源，并且很难看到数据建模所能带来的价值。此外，商业模型可以迅速变化，建模方法本身也需要迭代和演进。因此，许多数据分析师倾向于避免建模，直接使用原始数据，这不可避免地导致数据质量和查询性能的问题。当需要建模时，重新结构已经建立的数据分析模式以匹配数据模型的模式变得困难。

使用物化视图进行数据建模可以有效解决这些问题。StarRocks的异步物化视图可以：

- **简化数据仓库架构**：由于StarRocks可以提供一站式数据治理体验，您无需维护其他数据处理系统，节约了在这些系统上花费的人力资源和系统资源。
- **简化数据建模体验**：只需具备基本SQL知识的任何数据分析师都能够使用StarRocks进行数据建模。数据建模不再是有经验的数据工程师的专属领域。
- **降低维护复杂度**：StarRocks的异步物化视图可以自动管理跨数据层的血统关系和依赖关系，消除了需要整个数据平台来处理此任务的需求。

在真实世界的情景中，可以通过结合StarRocks的视图（逻辑视图）和异步物化视图的使用来执行数据建模：

1. 使用视图将实时数据与维度数据关联，使用物化视图将数据湖中的历史数据与维度数据关联。进行必要的数据清洗和语义映射，以获取中间层的详细数据，这反映了业务场景中所需的语义。

2. 在应用层中，执行适用于不同业务场景的数据连接、聚合、联合和窗口计算。这将产生适用于实时流程的视图和适用于准实时流程的物化视图。
3. 在应用侧，根据时效性和性能要求为查询分析选择适当的分析数据存储（ADS）。这些ADS可用于实时仪表板、准实时BI、自助查询和定期报告。


在此过程中，您将利用StarRocks的几个内置功能，这些功能将在下一部分详细阐述。

## 异步物化视图的功能

StarRocks的异步物化视图具有以下原子功能，可辅助数据建模：

- **自动刷新**：在将数据加载到基表后，物化视图可以自动刷新。您无需外部维护调度任务。
- **分区刷新**：通过基于时间序列的表的分区刷新，可以实现准实时的计算。
- **与视图的协同作用**：通过使用物化视图和逻辑视图可以实现多层建模，从而实现中间层的重用和数据模型的简化。
- **模式更改**：您可以通过简单的SQL语句更改计算结果，无需修改复杂的数据管道。

有了这些功能，您可以设计全面且灵活的数据模型，以满足各种业务需求和场景。

### 自动刷新

创建异步物化视图时，可以使用REFRESH子句指定刷新策略。目前，StarRocks支持以下异步物化视图的刷新策略：

- **自动刷新** (`REFRESH ASYNC`)：每当基表中的数据发生更改时，都会触发刷新任务。物化视图会自动管理数据依赖关系。
- **定时刷新** (`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`)：定期触发刷新任务，例如每隔一分钟、一天或一个月。如果基表中没有数据更改，则不会触发刷新任务。
- **手动刷新** (`REFRESH MANUAL`)：只能通过手动执行`REFRESH MATERIALIZED VIEW`来触发刷新任务。当您维护外部调度框架以触发刷新任务时，可以使用此刷新策略。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### 分区刷新

创建异步物化视图时，可以使用PARTITION BY子句将基表的分区与物化视图的分区关联起来，从而实现分区级别的刷新。

- `PARTITION BY <column>`：您可以将基表和物化视图引用相同的分区列。因此，基表和物化视图将在相同的粒度上分区。
- `PARTITION BY date_trunc(<column>)`：您可以使用date_trunc函数通过截断时间单位来为物化视图分配不同的分区策略（在粒度级别上）。
- `PARTITION BY { time_slice | date_slice }(<column>)`：与date_trunc相比，time_slice和date_slice可以更灵活地调整时间粒度，从而更好地控制基于时间的分区。

语法：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### 与视图的协同作用

- 可以基于视图创建物化视图。在这种情况下，当视图引用的基表发生数据更改时，物化视图可以自动刷新。
- 还可以基于其他物化视图创建物化视图，从而实现多级级联刷新机制。
- 可以基于物化视图创建视图，这相当于常规表。

### 模式更改

- 您可以使用ALTER MATERIALIZED VIEW SWAP语句在两个异步物化视图之间执行原子交换。这使您可以创建一个具有增加列或更改列类型的新物化视图，然后用其替换旧的物化视图。
- 可以直接使用ALTER VIEW语句修改视图的定义。
- StarRocks中的常规表可以使用SWAP或ALTER操作来进行修改。
- 此外，当基表（可以是物化视图、视图或常规表）发生变化时，会触发相应物化视图的级联更改。

## 分层建模

在许多现实世界的业务场景中，存在各种形式的数据源，包括实时详细数据、维度数据和数据湖中的历史数据。另一方面，业务需求要求采用多种分析方法，例如实时仪表板、准实时BI查询、自助查询和定期报告。不同的场景有不同的需求 - 有些需要灵活性，有些优先考虑性能，而其他则强调成本效益。

显然，单一解决方案无法满足如此多样化的需求。StarRocks可以通过结合视图和物化视图的使用来高效满足这些需求。因为视图不维护任何物理数据，每次查询视图时，将根据视图的定义解析和执行查询。相比之下，物化视图保留了预先计算的结果，可以避免重复执行的开销。视图适用于表达业务语义并简化SQL复杂性，但无法降低查询执行的成本。另一方面，物化视图通过预计算优化了查询性能，并适用于简化ETL流程。

下表总结了视图和物化视图之间的区别：

|                                      | **视图**                                                     | **物化视图**                                        |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **用例**                        | 业务建模，数据治理                           | 数据建模，透明加速，数据湖集成 |
| **存储成本**                     | 无存储成本                                              | 通过存储预先计算的结果而产生的存储成本        |
| **更新成本**                      | 无更新成本                                               | 基表数据更新时产生的刷新成本           |
| **性能优势**             | 无性能优势                                       | 通过重复使用预先计算的结果引入的查询加速 |
| **实时数据属性** | 返回最新数据，因为对视图的查询是实时计算的。 | 数据可能不是最新的，因为结果是预先计算的。 |
| **依赖关系**                       | 如果基表名称发生更改，视图会失效，因为它们按名称引用基表。 | 基表名称的更改不会影响物化视图的可用性，因为物化视图是按ID引用基表的。 |
| **创建语法**              | CREATE VIEW                                                  | CREATE MATERIALIZED VIEW                                     |
| **修改语法**           | ALTER VIEW                          | ALTER MATERIALIZED VIEW              |

您可以使用以下语句来修改您的视图、物化视图和基础表：

```SQL
-- 修改表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 交换两个表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图的定义。
ALTER VIEW <view_name> AS <query>;

-- 交换两个物化视图
-- （通过交换两个物化视图的名称而不影响其中的数据，来交换这两个物化视图）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- 重新激活一个物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

架构更改遵循以下原则：

- 对表进行重命名和交换操作会使依赖的物化视图变为非活动状态。对于架构更改操作，只有在对物化视图引用的基础表列执行架构更改操作时，才会使依赖的物化视图变为非活动状态。
- 如果更改视图的定义，则会使依赖的物化视图变为非活动状态。
- 如果一个物化视图被交换，那么任何构建在它上面的嵌套物化视图都会被设为非活动状态。
- 非活动状态向上级级联，直到没有物化视图依赖为止。
- 非活动状态的物化视图无法刷新或用于自动查询重写。
- 非活动状态的物化视图仍然可以直接查询，但在其再次激活之前无法保证数据一致性。

对于非活动状态的物化视图，无法保证其数据一致性，您可以使用以下方法恢复其功能：

- **手动修复**：您可以通过执行 ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE 来手动修复一个非活动状态的物化视图。该语句将根据其原始 SQL 定义重新创建物化视图。请注意，在基础架构更改后，SQL 定义仍然必须有效，否则该操作将失败。
- **自动修复**：StarRocks 将尝试自动激活非活动状态的物化视图。但是，无法保证此过程的及时性。

## 分区建模

除了分层建模，分区建模也是数据建模的一个重要方面。数据建模通常涉及根据业务语义关联数据，并根据时效性要求设置数据的存活时间（TTL）。分区建模在这一过程中扮演着重要的角色。

分区建模是数据建模的一个重要方面，补充了分层建模。它涉及根据业务语义关联数据，并根据时效性要求设置数据的存活时间（TTL）。数据分区在这一过程中起着重要的作用。

不同的关联数据方式导致了各种建模方法的产生，例如星型模式和雪花模式。这些模型有一个共同点 - 它们都使用事实表和维度表。一些业务场景需要多个大型事实表，而另一些则涉及复杂的维度表及其之间的关系。StarRocks 的物化视图支持对事实表进行分区关联，这意味着事实表被分区，并且物化视图的连接结果也以相同的方式被分区。

![建模-2](../assets/Modeling-2.png)

如上图所示，物化视图将一个事实表与多个维度表关联起来：

- 您需要将指定基本表（通常为事实表）的分区键（`PARTITION BY fact_tbl.col`）作为物化视图的分区键，以关联它们的分区策略。每个物化视图只能与一个基本表关联。
- 当所引用表的分区中的数据发生更改时，默认情况下，物化视图中对应的分区将刷新，而不影响其他分区。
- 当非引用表中的数据发生更改时，通常情况下整个物化视图将被刷新。但是，您可以选择忽略某些非引用基表的数据更改，以避免整个物化视图的刷新，或者您可以指定一个时间范围，以便仅刷新时间范围内的分区。

这种分区关联支持各种业务场景：

- **事实表更新**：您可以将事实表细分为每日或每小时等粒度。在事实表更新后，物化视图中对应的分区将自动刷新。
- **维度表更新**：通常情况下，维度表中的数据更新会导致刷新所有相关结果，这可能代价高昂。您可以选择忽略一些维度表的数据更新，以避免刷新整个物化视图，或者您可以指定一个时间范围，以便仅刷新时间范围内的分区。
- **外部表自动刷新**：在像 Apache Hive 或 Apache Iceberg 这样的外部数据源中，数据在分区级别发生更改。StarRocks 的物化视图可以订阅外部目录的分区级别变化，并且仅刷新物化视图的相应分区。
- **TTL**：在为物化视图设置分区策略时，您可以设置要保留的最近分区的数量，从而仅保留最近的数据。这在业务场景中非常有用，分析人员仅需要从某个时间窗口查询最新数据，并且无需保留所有历史数据。

有几个参数可用于控制刷新行为：

- `partition_refresh_number`：每个刷新操作中要刷新的分区数。
- `partition_ttl_number`：要保留的最近分区的数量。
- `excluded_trigger_tables`：其数据更改可被忽略以避免触发自动刷新。
- `auto_refresh_partitions_limit`：每个自动刷新操作中要刷新的分区数。

有关更多信息，请参见[CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

目前，分区物化视图有以下限制：

- 您只能基于分区表构建分区物化视图。
- 您只能使用 DATE 或 DATETIME 类型的列作为分区键。STRING 数据类型不受支持。
- 您只能使用 date_trunc、time_slice 和 date_slice 等函数执行分区滚动。
- 您只能指定单个列作为分区键，不支持多列分区。

## 总结

利用 StarRocks 的异步物化视图进行数据建模具有简化管道管理、通过声明式建模语言提高数据建模的效率和灵活性的优势。

除了数据建模，StarRocks 的异步物化视图还在涉及透明加速和数据湖集成的各种场景中发挥作用。这有助于进一步探索数据价值并提高数据效率。