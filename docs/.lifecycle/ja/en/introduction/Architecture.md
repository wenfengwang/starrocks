---
displayed_sidebar: English
---

# アーキテクチャ

StarRocksはシンプルなアーキテクチャを持っています。システム全体はフロントエンド(FE)とバックエンド(BE)、またはコンピュートノード(CN)の2種類のコンポーネントのみで構成されています。StarRocksは外部コンポーネントに依存せず、デプロイメントとメンテナンスが簡素化されます。ノードはサービスダウンタイムなしで水平スケーリングが可能です。さらに、StarRocksにはメタデータとサービスデータのレプリカメカニズムがあり、データの信頼性を高め、シングルポイントオブフェイラー(SPOF)を効率的に防ぐことができます。

StarRocksはMySQLプロトコルと互換性があり、標準SQLをサポートしています。ユーザーはMySQLクライアントからStarRocksに簡単に接続し、即時かつ価値ある洞察を得ることができます。

## アーキテクチャの進化

StarRocksが進化するにつれて、システムアーキテクチャは元のストレージ-コンピュート結合アーキテクチャ（シェアード・ナッシング）からストレージ-コンピュート分離アーキテクチャ（シェアード・データ）へと移行しました。

- バージョン3.0以前のStarRocksはストレージ-コンピュート結合アーキテクチャを使用しています。BEはデータストレージと計算の両方を担当します。データアクセスと計算はローカルノードで実行され、データ移動を最小限に抑え、クエリレイテンシを短縮し、超高速なクエリと分析体験を提供します。

- バージョン3.0から、StarRocksはストレージ-コンピュート分離アーキテクチャを導入しました。データストレージはBEから分離され、BEはステートレスなCNノードにアップグレードされます。データはリモートオブジェクトストレージやHDFSに永続的に保存され、CNのローカルディスクはホットデータのキャッシングに使用され、クエリを加速します。ストレージ-コンピュート分離アーキテクチャは、コンピュートノードの動的な追加と削除をサポートし、オンデマンドでのスケーリングを可能にします。

以下の図は、アーキテクチャの進化を示しています。

![アーキテクチャの進化](../assets/architecture_evolution.png)

## ストレージ-コンピュート結合

StarRocksは、典型的なマッシブ並列処理(MPP)データベースとして、バージョン3.0以前ではストレージ-コンピュート結合アーキテクチャを使用しています。このアーキテクチャでは、BEはデータストレージと計算の両方を担当します。BEモードでのローカルデータへの直接アクセスにより、データ転送やコピーを避けながらローカルで計算を行うことができ、超高速なクエリと分析パフォーマンスを提供します。このアーキテクチャはマルチレプリカデータストレージをサポートし、クラスタの高並行性クエリ処理能力を強化し、データの信頼性を保証します。これは最適なクエリパフォーマンスを追求するシナリオに適しています。

### ノード

ストレージ-コンピュート結合アーキテクチャでは、StarRocksはFEとBEの2種類のノードで構成されます。

- FEはメタデータの管理と実行プランの構築を担当します。
- BEはクエリプランを実行し、データを格納します。BEはローカルストレージを使用してクエリを加速し、マルチレプリカメカニズムを使用して高いデータ可用性を確保します。

### FE

FEはメタデータ管理、クライアント接続管理、クエリプランニング、クエリスケジューリングを担当します。各FEはメモリ内にメタデータの完全なコピーを保持し、FE間でサービスが一貫して提供されることを保証します。FEはリーダー、フォロワー、オブザーバーとして機能することができます。フォロワーはPaxosに類似したBDB JEプロトコルに基づいてリーダーを選出することができます。BDB JEはBerkeley DB Java Editionの略です。

| **FEの役割** | **メタデータ管理**                                               | **リーダー選出**                                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| リーダーFE      | リーダーFEはメタデータの読み書きを行います。フォロワーFEとオブザーバーFEはメタデータの読み取りのみが可能です。彼らはメタデータの書き込みリクエストをリーダーFEにルーティングします。リーダーFEはメタデータを更新し、BDB JEを使用してメタデータの変更をフォロワーFEとオブザーバーFEに同期します。データの書き込みは、メタデータの変更がフォロワーFEの半数以上に同期された後に成功と見なされます。 | リーダーFEはフォロワーFEから選出されます。リーダー選出を行うには、クラスタ内のフォロワーFEの半数以上がアクティブである必要があります。リーダーFEが失敗した場合、フォロワーFEはリーダー選出の新たなラウンドを開始します。 |
| フォロワーFE    | フォロワーはメタデータの読み取りのみが可能です。彼らはリーダーFEからのログを同期し、再生してメタデータを更新します。 | フォロワーはリーダー選出に参加しますが、リーダー選出にはクラスタ内のフォロワーの半数以上がアクティブである必要があります。 |
| オブザーバーFE   | オブザーバーはリーダーFEからのログを同期し、再生してメタデータを更新します。     | オブザーバーは主にクラスタのクエリ並行性を高めるために使用されます。オブザーバーはリーダー選出に参加せず、クラスタにリーダー選出の圧力を加えません。|

### BE

BEはデータストレージとSQL実行を担当します。

- データストレージ: BEは等価なデータストレージ能力を持ちます。FEは事前定義されたルールに基づいてデータをBEに分配します。BEは取り込まれたデータを変換し、必要なフォーマットでデータを書き込み、データにインデックスを生成します。

- SQL実行: SQLクエリが到着すると、FEはクエリのセマンティクスに従って論理実行プランに解析し、その論理プランをBEで実行可能な物理実行プランに変換します。データを保持するBEがクエリを実行します。これによりデータ転送とコピーが不要になり、高いクエリパフォーマンスを実現します。

### データ管理

StarRocksはカラム指向のデータベースシステムです。パーティショニングとバケッティングのメカニズムを使用してデータを管理します。テーブル内のデータは、最初に複数のパーティションに分割され、その後複数のタブレットに分割されます。タブレットはStarRocksにおけるデータ管理の基本的な論理単位です。各タブレットは、異なるBEにまたがって保存される複数のレプリカを持つことができます。タブレットの数を指定し、StarRocksにタブレットの管理を任せることができます。

パーティションとタブレットはテーブルスキャンを減少させ、クエリの同時実行性を向上させます。レプリカはデータのバックアップと復元を容易にし、データ損失を防ぎます。

以下の図では、テーブルは時間に基づいて4つのパーティションに分割されています。最初のパーティションのデータはさらに4つのタブレットに分割されます。各タブレットには3つのレプリカがあり、3つの異なるBEに保存されています。

![Data management](../assets/data_manage.png)

1つのテーブルが複数のタブレットに分割されているため、StarRocksは1つのSQLステートメントをすべてのタブレットに対して並列処理するようスケジュールでき、複数の物理マシンとコアの計算能力を最大限に活用します。これにより、クエリの負荷が複数のノードに分散され、サービスの可用性が向上します。物理マシンをオンデマンドで追加し、高い同時実行性を達成することができます。

タブレットの分布は物理ノードによって影響を受けたり制限されたりしません。BEの数が変更された場合（例えば、BEを追加または削除した場合）、進行中のサービスは中断されることなく続行できます。ノードの変更はタブレットの自動移行をトリガーします。BEが追加されると、一部のタブレットは新しいBEへ自動的に移行され、データ分布がより均等になります。BEが削除されると、これらのBE上のタブレットは他のBEへ自動的に移行され、レプリカの数は変わりません。自動タブレット移行はStarRocksクラスタの自動スケーリングを容易にし、手動でのデータ再分配の必要性を排除します。

StarRocksはタブレットに対してマルチレプリカメカニズム（デフォルトでは3）を使用します。レプリカは高いデータ信頼性とサービス可用性を保証します。1つのノードが故障しても、全体のサービスの可用性には影響しません。また、クエリの同時実行性を高めるためにレプリカの数を増やすこともできます。

### 制約

このアーキテクチャにはそれ自体の制約があります：

- コスト増加：ユーザーは計算能力と共にストレージをスケールアップする必要があり、望ましくないストレージコストが増加します。データ量が増加するにつれて、ストレージと計算リソースの需要が不均衡に増加し、リソース効率が低下します。
- 複雑なアーキテクチャ：複数のレプリカ間でデータの一貫性を維持することはシステムを複雑にし、障害のリスクを高めます。
- 弾力性の限界：スケーリング操作はデータの再バランスを引き起こし、ユーザー体験を損なう可能性があります。

## ストレージとコンピュートの分離

新しいストレージとコンピュートの分離アーキテクチャでは、データストレージ機能はBEから切り離されます。BEは、現在「コンピュートノード（CN）」と呼ばれ、データの計算とホットデータのキャッシュのみを担当します。データはAmazon S3、GCP、Azure Blob Storageなどの低コストで信頼性の高いリモートストレージシステムや、MinIOなどのS3互換ストレージに保存されます。キャッシュがヒットすると、クエリパフォーマンスはストレージとコンピュートの結合アーキテクチャと同等です。CNノードは数秒以内にオンデマンドで追加または削除することができます。このアーキテクチャはストレージコストを削減し、リソースの分離を向上させ、高い弾力性とスケーラビリティを実現します。

ストレージとコンピュートの分離アーキテクチャは、ストレージとコンピュートの結合アーキテクチャと同様にシンプルなアーキテクチャを維持します。これはFEとCNの2種類のノードのみで構成されています。唯一の違いは、ユーザーがバックエンドオブジェクトストレージをプロビジョニングする必要があることです。

![shared-data-arch](../assets/architecture_shared_data.png)

### ノード

ストレージとコンピュートの分離アーキテクチャのFEは、ストレージとコンピュートの結合アーキテクチャと同じ機能を提供します。

BEのストレージ機能は分離されています。ローカルストレージは共有ストレージに移行されます。BEノードはステートレスなCNノードにアップグレードされ、データのロード、クエリ計算、キャッシュ管理などのタスクを担当します。

### ストレージ

現在、StarRocks共有データクラスタは、オブジェクトストレージ（例：AWS S3、Google GCS、Azure Blob Storage、MinIO）と、従来のデータセンターにデプロイされたHDFSの2つのストレージソリューションをサポートしています。このテクノロジーは、指定されたバケットまたはHDFSディレクトリ内のデータストレージを統一します。

共有データクラスタでは、データファイル形式はシェアードナッシングクラスタ（ストレージとコンピュートが結合されている特徴を持つ）の形式と一致しています。データはセグメントファイルに整理され、さまざまなインデックス技術がクラウドネイティブテーブル（共有データクラスタ専用のテーブル）で再利用されます。

### キャッシュ

StarRocksの共有データクラスタは、データストレージとコンピューティングを分離し、それぞれが独立してスケールできるようにすることで、コストを削減し、弾力性を強化します。しかし、このアーキテクチャはクエリパフォーマンスに影響を与える可能性があります。

この影響を軽減するため、StarRocksはメモリ、ローカルディスク、リモートストレージを含む多層データアクセスシステムを確立し、さまざまなビジネスニーズに適応するようにしています。

ホットデータに対するクエリは、まずキャッシュを直接スキャンし、次にローカルディスクをスキャンします。一方、コールドデータは、後続のクエリを加速するためにオブジェクトストレージからローカルキャッシュにロードされる必要があります。StarRocksは、ホットデータを計算ユニットの近くに保持することで、高性能な計算とコスト効率の良いストレージを実現しています。さらに、データプリフェッチ戦略を用いてコールドデータへのアクセスを最適化し、クエリのパフォーマンス制限を効果的に解消しています。

ユーザーはテーブルを作成する際に、キャッシュを有効にするかどうかを選択できます。キャッシュを有効にした場合、データはローカルディスクとバックエンドのオブジェクトストレージの両方に書き込まれます。クエリ時には、CNノードが最初にローカルディスクからデータを読み込みます。データが見つからない場合、バックエンドのオブジェクトストレージから取得し、同時にローカルディスクにキャッシュされます。
