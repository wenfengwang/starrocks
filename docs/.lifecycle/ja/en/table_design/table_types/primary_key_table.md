---
displayed_sidebar: English
---

# プライマリキー テーブル

テーブルを作成する際には、プライマリキーとソートキーを別々に定義することができます。データがプライマリキー テーブルにロードされると、StarRocksはデータを格納する前にソートキーに従ってデータをソートします。クエリは、同じプライマリキーを持つレコード群の中で最新のレコードを返します。ユニークキー テーブルと異なり、プライマリキー テーブルはクエリ時の集約操作を必要とせず、述語とインデックスのプッシュダウンをサポートします。そのため、リアルタイムで頻繁にデータが更新される状況でも、高いクエリパフォーマンスを提供することができます。

> **注記**
>
> - v3.0より前のバージョンでは、プライマリキー テーブルはプライマリキーとソートキーの分離をサポートしていませんでした。
> - バージョン3.1以降、StarRocksの共有データモードはプライマリキー テーブルをサポートしています。バージョン3.1.4以降、StarRocks共有データクラスタで作成されたプライマリキー テーブルは、ローカルディスクへのインデックスの永続化をさらにサポートしています。

## シナリオ

- プライマリキー テーブルは、データをリアルタイムで頻繁に更新する必要がある以下のようなシナリオに適しています：
  - **トランザクション処理システムからStarRocksへリアルタイムでストリームデータを送信します。** 通常、トランザクション処理システムでは、挿入操作に加えて多くの更新と削除操作が行われます。トランザクション処理システムからStarRocksへデータを同期する必要がある場合、プライマリキー テーブルを使用するテーブルの作成を推奨します。その後、Apache Flink®用CDCコネクタなどのツールを使用して、トランザクション処理システムのバイナリログをStarRocksに同期できます。StarRocksはバイナリログを使用してテーブル内のデータをリアルタイムで追加、削除、更新します。これによりデータ同期が簡素化され、ユニークキー テーブルのMoRテーブルを使用する場合に比べて3倍から10倍高いクエリパフォーマンスが実現します。例えば、flink-connector-starrocksを使用してデータをロードすることができます。詳細は[flink-connector-starrocksを使用したデータのロード](../../loading/Flink-connector-starrocks.md)をご覧ください。

  - **個々の列に対する更新操作を実行し、複数のストリームを結合します。** ユーザープロファイリングなどのビジネスシナリオでは、多次元分析のパフォーマンスを向上させ、データアナリストが使用する分析モデルを簡素化するためにフラットテーブルが好まれます。これらのシナリオでは、アップストリームデータはショッピングアプリ、配送アプリ、銀行アプリなどの様々なアプリや、ユーザーの個別のタグやプロパティを計算する機械学習システムなどのシステムから来ることがあります。プライマリキー テーブルは個々の列の更新をサポートしているため、これらのシナリオに適しています。各アプリやシステムは自身のサービス範囲内のデータを保持する列のみを更新し、リアルタイムでデータの追加、削除、更新を高いクエリパフォーマンスで利用できます。

- プライマリキーが占有するメモリが制御可能なシナリオにプライマリキー テーブルは適しています。

  StarRocksのストレージエンジンは、プライマリキー テーブルを使用する各テーブルのプライマリキーに対してインデックスを作成します。さらに、データをテーブルにロードする際に、StarRocksはプライマリキーインデックスをメモリにロードします。したがって、プライマリキー テーブルは他の3つのテーブルタイプよりも大きなメモリ容量を必要とします。**StarRocksは、エンコード後のプライマリキーを構成するフィールドの合計長を127バイトに制限しています。**

  テーブルが以下の特徴を持つ場合、プライマリキー テーブルの使用を検討してください：

  - テーブルには、変化が速いデータと変化が遅いデータの両方が含まれています。変化が速いデータは最近の日に頻繁に更新されますが、変化が遅いデータはほとんど更新されません。例えば、MySQLの注文テーブルをリアルタイムでStarRocksに同期して分析とクエリを行う必要があるとします。この場合、テーブルのデータは日ごとにパーティションされ、最新の日に作成された注文に対する更新がほとんどです。履歴上の注文は完了後には更新されなくなります。データロードジョブを実行すると、プライマリキーインデックスはメモリにロードされず、最近更新された注文のインデックスエントリのみがメモリにロードされます。

    下の図に示すように、テーブルのデータは日ごとにパーティションされ、最新の2つのパーティションのデータは頻繁に更新されます。

    ![プライマリ インデックス -1](../../assets/3.2-1.png)

  - テーブルは、数百または数千の列で構成されるフラットテーブルです。プライマリキーはテーブルデータのごく一部を構成し、少量のメモリしか消費しません。例えば、ユーザーステータステーブルやプロファイルテーブルは多くの列を持っていますが、ユーザー数は数千万から数億に過ぎません。この場合、プライマリキーによって消費されるメモリ量は制御可能です。

    下の図に示すように、テーブルにはわずかな行しか含まれておらず、テーブルのプライマリキーはテーブルデータのごく一部を構成しています。

    ![プライマリ インデックス -2](../../assets/3.2.4-2.png)

### 原理

プライマリキー テーブルは、StarRocksが提供する新しいストレージエンジンに基づいて設計されています。プライマリキー テーブルのメタデータ構造と読み書きメカニズムは、デュプリケートキー テーブルとは異なります。そのため、プライマリキー テーブルは集約操作を必要とせず、述語とインデックスのプッシュダウンをサポートします。これによりクエリパフォーマンスが大幅に向上します。

デュプリケートキー テーブルはMoRポリシーを採用しています。MoRはデータ書き込みを合理化しますが、複数のデータバージョンのオンライン集約が必要です。また、マージオペレータは述語とインデックスのプッシュダウンをサポートしていません。結果としてクエリパフォーマンスが低下します。

プライマリキー テーブルは削除+挿入ポリシーを採用し、各レコードが一意のプライマリキーを持つことを保証します。これにより、プライマリキー テーブルはマージ操作を必要としません。詳細は以下の通りです：

- StarRocksがレコードの更新操作のリクエストを受け取ると、プライマリキーインデックスを検索してレコードを特定し、そのレコードを削除済みとマークし、新しいレコードを挿入します。つまり、StarRocksは更新操作を削除操作と挿入操作に変換します。

- StarRocksがレコードの削除操作を受け取ると、プライマリキーインデックスを検索してレコードを特定し、そのレコードを削除済みとマークします。

## テーブルの作成

例 1: 毎日の注文を分析する必要があるとします。この例では、`orders`という名前のテーブルを作成し、`dt`と`order_id`をプライマリキーとして定義し、他のカラムをメトリックカラムとして定義します。

```SQL
create table orders (
    dt date NOT NULL,
    order_id bigint NOT NULL,
    user_id int NOT NULL,
    merchant_id int NOT NULL,
    good_id int NOT NULL,
    good_name string NOT NULL,
    price int NOT NULL,
    cnt int NOT NULL,
    revenue int NOT NULL,
    state tinyint NOT NULL
) PRIMARY KEY (dt, order_id)
PARTITION BY RANGE(`dt`) (
    PARTITION p20210820 VALUES [('2021-08-20'), ('2021-08-21')),
    PARTITION p20210821 VALUES [('2021-08-21'), ('2021-08-22')),
    ...
    PARTITION p20210929 VALUES [('2021-09-29'), ('2021-09-30')),
    PARTITION p20210930 VALUES [('2021-09-30'), ('2021-10-01'))
) DISTRIBUTED BY HASH(order_id)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

> **注意**
>
> - テーブルを作成する際には、`DISTRIBUTED BY HASH`句を使用してバケット列を指定する必要があります。詳細は[bucketing](../Data_distribution.md#design-partitioning-and-bucketing-rules)を参照してください。
> - v2.5.7以降、StarRocksはテーブル作成時やパーティション追加時にバケット数(BUCKETS)を自動的に設定することができます。もはやバケット数を手動で設定する必要はありません。詳細は[バケット数の決定](../Data_distribution.md#determine-the-number-of-buckets)を参照してください。

例 2: ユーザーの住所や最終アクティブ時間などの次元からリアルタイムでユーザー行動を分析する必要があるとします。テーブルを作成する際には、`user_id`カラムをプライマリキーとして定義し、`address`と`last_active`カラムの組み合わせをソートキーとして定義できます。

```SQL
create table users (
    user_id bigint NOT NULL,
    name string NOT NULL,
    email string NULL,
    address string NULL,
    age tinyint NULL,
    sex tinyint NULL,
    last_active datetime,
    property0 tinyint NOT NULL,
    property1 tinyint NOT NULL,
    property2 tinyint NOT NULL,
    property3 tinyint NOT NULL,
    ....
) PRIMARY KEY (user_id)
DISTRIBUTED BY HASH(user_id)
ORDER BY(`address`,`last_active`)
PROPERTIES("replication_num" = "3",
"enable_persistent_index" = "true");
```

## 使用上の注意点

- テーブルのプライマリキーに関して以下の点に注意してください：
  - プライマリキーは`PRIMARY KEY`キーワードを使用して定義されます。

  - プライマリキーは一意性制約が適用されるカラムに作成する必要があり、プライマリキーのカラム名は変更できません。

  - プライマリキーのカラムはBOOLEAN、TINYINT、SMALLINT、INT、BIGINT、LARGEINT、STRING、VARCHAR、DATE、DATETIMEのデータ型が使用できます。ただし、プライマリキーのカラムを`NULL`として定義することはできません。

  - パーティションカラムとバケットカラムはプライマリキーに含まれている必要があります。

  - プライマリキーのカラム数と全体の長さはメモリ節約のために適切に設計する必要があります。メモリ使用量が少ないデータ型のカラムを特定し、それらをプライマリキーとして定義することを推奨します。例えばINTやBIGINTなどです。VARCHARデータ型のカラムをプライマリキーに含めることは推奨されません。

  - テーブルを作成する前に、プライマリキーのカラムのデータ型とテーブル内の行数に基づいて、プライマリキーインデックスが占めるメモリを見積もることを推奨します。これにより、テーブルのメモリ不足を防ぐことができます。以下の例は、プライマリキーインデックスが占めるメモリを計算する方法を説明しています：
    - DATEデータ型で4バイトを占める`dt`カラムと、BIGINTデータ型で8バイトを占める`id`カラムがプライマリキーとして定義されているとします。この場合、プライマリキーは12バイトの長さです。

    - テーブルに1,000万行のホットデータが含まれており、3つのレプリカに格納されているとします。

    - 上記の情報に基づいて、プライマリキーインデックスによって占められるメモリは、次の式に基づいて945MBです：

      (12 + 9) x 10,000,000 x 3 x 1.5 = 945 (MB)

      上記の式で、`9`は行ごとの固定オーバーヘッド、`1.5`はハッシュテーブルごとの平均的な追加オーバーヘッドです。

- `enable_persistent_index`：プライマリキーインデックスをディスクに永続化し、メモリに格納することで、メモリの使用量を過度に増やさないようにすることができます。通常、プライマリキーインデックスは以前のメモリの1/10しか占有しません。このプロパティは、テーブルを作成する際に`PROPERTIES`で設定できます。有効な値はtrueまたはfalseです。デフォルト値はfalseです。

  > - テーブルを作成した後にこのパラメータを変更したい場合は、[ALTER TABLE](../../sql-reference/sql-statements/data-definition/ALTER_TABLE.md)でテーブルのプロパティを変更する部分を参照してください。
  > - ディスクがSSDの場合は、このプロパティをtrueに設定することを推奨します。
  > - バージョン2.3.0以降、StarRocksはこのプロパティの設定をサポートしています。
  > - バージョン3.1以降、StarRocksの共有データモードはプライマリキーテーブルをサポートしています。バージョン3.1.4以降、StarRocks共有データクラスタで作成されたプライマリキーテーブルは、ローカルディスク上のインデックスの永続化をさらにサポートしています。

- `ORDER BY`キーワードを使用して、任意のカラムの順列および組み合わせとしてソートキーを指定できます。

  > **注意**
  >
  > ソートキーが指定されている場合、プレフィックスインデックスはソートキーに基づいて構築されます。ソートキーが指定されていない場合、プレフィックスインデックスはプライマリキーに基づいて構築されます。

- ALTER TABLEを使用してテーブルスキーマを変更することができますが、以下の制限があります：
  - プライマリキーの変更はサポートされていません。
  - ALTER TABLE ... ORDER BY ...を使用してソートキーを再割り当てすることはサポートされています。ソートキーの削除はサポートされていません。ソートキーのカラムのデータ型を変更することはサポートされていません。
  - カラムの順序を調整することはサポートされていません。

- バージョン2.3.0以降、プライマリキー以外のカラムはBITMAPおよびHLLデータ型をサポートしています。

- テーブルを作成する際には、プライマリキーカラム以外のカラムにBITMAPインデックスまたはブルームフィルターインデックスを作成することができます。

- バージョン2.4.0以降、プライマリキーテーブルに基づいて非同期のマテリアライズドビューを作成することができます。

## 次に行うこと

テーブルを作成した後、ロードジョブを実行してプライマリキーテーブルにデータをロードすることができます。サポートされているロード方法の詳細については、[データロードの概要](../../loading/Loading_intro.md)を参照してください。

主キー表のデータを更新する必要がある場合、[ロードジョブを実行](../../loading/Load_to_Primary_Key_tables.md)するか、DMLステートメント（[UPDATE](../../sql-reference/sql-statements/data-manipulation/UPDATE.md)または[DELETE](../../sql-reference/sql-statements/data-manipulation/DELETE.md)）を実行できます。これらの更新操作は原子性を保証します。
