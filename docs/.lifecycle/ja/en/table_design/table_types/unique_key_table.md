---
displayed_sidebar: English
---

# ユニークキーテーブル

テーブルを作成する際には、プライマリキー列とメトリック列を定義することができます。この方法により、クエリは同一プライマリキーを持つレコード群の中で最新のレコードを返します。デュプリケートキーテーブルと比較して、ユニークキーテーブルはデータロードプロセスを簡素化し、リアルタイムで頻繁なデータ更新をより効果的にサポートします。

## シナリオ

ユニークキーテーブルは、データがリアルタイムで頻繁に更新される必要があるビジネスシナリオに適しています。例えば、eコマースのシナリオでは、1日に数億の注文が発生し、注文のステータスが頻繁に変更されます。

## 原理

ユニークキーテーブルは、同一プライマリキーを持つレコード群の中で最新のレコードを返すために、メトリック列に`REPLACE`集計関数が指定された特別なアグリゲートキーテーブルと考えることができます。

ユニークキーテーブルを使用するテーブルにデータをロードする際、データは複数のバッチに分割されます。各バッチにはバージョン番号が割り当てられます。したがって、同一プライマリキーを持つレコードは複数のバージョンを持ち、その中で最新のバージョン（つまり、最大のバージョン番号を持つレコード）がクエリに対して取得されます。

以下の表に示すように、`ID`はプライマリキー列、`value`はメトリック列であり、`_version`はStarRocks内で生成されるデータバージョン番号を保持します。この例では、`ID`が`1`のレコードはバージョン番号が`1`と`2`の2つのバッチによってロードされ、`ID`が`2`のレコードはバージョン番号が`3`、`4`、`5`の3つのバッチによってロードされます。

| ID   | value | _version |
| ---- | ----- | -------- |
| 1    | 100   | 1        |
| 1    | 101   | 2        |
| 2    | 100   | 3        |
| 2    | 101   | 4        |
| 2    | 102   | 5        |

`ID`が`1`のレコードをクエリすると、最大のバージョン番号を持つ最新のレコード、この場合は`2`が返されます。`ID`が`2`のレコードをクエリすると、最大のバージョン番号を持つ最新のレコード、この場合は`5`が返されます。以下の表は、2つのクエリによって返されるレコードを示しています。

| ID   | value |
| ---- | ----- |
| 1    | 101   |
| 2    | 102   |

## テーブルの作成

eコマースのシナリオでは、注文のステータスを日付ごとに収集し分析することがよくあります。この例では、`orders`という名前のテーブルを作成して注文を保持し、フィルタ条件として頻繁に使用される`create_time`と`order_id`をプライマリキー列として定義し、他の2つの列`order_state`と`total_price`をメトリック列として定義します。これにより、注文のステータスが変更されたときにリアルタイムで更新が可能となり、クエリの高速化につながるフィルタリングが迅速に行えます。

テーブルを作成するためのステートメントは以下の通りです。

```SQL
CREATE TABLE IF NOT EXISTS orders (
    create_time DATE NOT NULL COMMENT "注文の作成時間",
    order_id BIGINT NOT NULL COMMENT "注文ID",
    order_state INT COMMENT "注文の状態",
    total_price BIGINT COMMENT "注文の合計金額"
)
UNIQUE KEY(create_time, order_id)
DISTRIBUTED BY HASH(order_id);
```

> **注意**
>
> - テーブルを作成する際には、`DISTRIBUTED BY HASH`句を使用してバケット列を指定する必要があります。詳細は[バケット化](../Data_distribution.md#design-partitioning-and-bucketing-rules)を参照してください。
> - v2.5.7以降、StarRocksはテーブルを作成する際やパーティションを追加する際にバケット数（BUCKETS）を自動的に設定することができます。バケット数を手動で設定する必要はもうありません。詳細は[バケット数の決定](../Data_distribution.md#determine-the-number-of-buckets)を参照してください。

## 使用上の注意点

- テーブルのプライマリキーに関して以下の点に注意してください：

  - プライマリキーは`UNIQUE KEY`キーワードを使用して定義されます。
  - プライマリキーは、一意性制約が強制され、名前が変更できない列に対して作成する必要があります。
  - プライマリキーは適切に設計されるべきです：
    - クエリ実行時、プライマリキー列は複数のデータバージョンの集約前にフィルタリングされますが、メトリック列は集約後にフィルタリングされます。したがって、フィルタ条件として頻繁に使用される列を特定し、これらの列をプライマリキー列として定義することを推奨します。これにより、複数のデータバージョンの集約前にデータフィルタリングを開始し、クエリ性能を向上させることができます。
    - 集約プロセス中、StarRocksはすべてのプライマリキー列を比較します。これは時間がかかり、クエリ性能を低下させる可能性があります。したがって、多くのプライマリキー列を定義しないでください。クエリのフィルタ条件としてほとんど使用されない列については、プライマリキー列として定義しないことを推奨します。

- テーブルを作成する際には、メトリック列にBITMAPインデックスやブルームフィルターインデックスを作成することはできません。

- ユニークキーテーブルはマテリアライズドビューをサポートしていません。

## 次のステップ

テーブルが作成された後、さまざまなデータ取り込み方法を使用してStarRocksにデータをロードできます。StarRocksでサポートされているデータ取り込み方法については、[データインポート](../../loading/Loading_intro.md)を参照してください。

> - ユニークキーテーブルを使用するテーブルにデータをロードする際には、テーブルの全ての列を更新することしかできません。例えば、`orders`テーブルを更新する場合、`create_time`、`order_id`、`order_state`、`total_price`の全ての列を更新する必要があります。
> - ユニークキーテーブルを使用するテーブルからデータをクエリする際には、StarRocksは複数のデータバージョンのレコードを集約する必要があります。この状況では、データバージョンが多いとクエリ性能が低下します。そのため、リアルタイムデータ分析の要件を満たしつつ、多数のデータバージョンが発生しないように、データをロードする適切な頻度を設定することを推奨します。分単位のデータが必要な場合は、ロード頻度を1秒ではなく1分に設定することができます。
