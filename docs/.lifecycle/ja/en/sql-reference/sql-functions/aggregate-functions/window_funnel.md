---
displayed_sidebar: English
---

# window_funnel

## 説明

スライディングウィンドウ内でイベントチェーンを検索し、イベントチェーン内の連続するイベントの最大数を計算します。この関数は、コンバージョン率の分析によく使用されます。v2.3からサポートされています。

この関数は、以下のルールに従って動作します：

- イベントチェーンの最初のイベントからカウントを開始します。最初のイベントが見つかった場合、イベントカウンターは1に設定され、スライディングウィンドウが開始されます。最初のイベントが見つからない場合は、0が返されます。

- スライディングウィンドウ内で、イベントチェーン内のイベントが順序通りに発生すると、カウンターがインクリメントされます。スライディングウィンドウを超えると、イベントカウンターはインクリメントされなくなります。

- 複数のイベントチェーンが指定された条件に一致する場合、最も長いイベントチェーンが返されます。

## 構文

```Plain
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメータ

- `window`: スライディングウィンドウの長さ。サポートされるデータ型はBIGINTです。単位は`time`パラメータのデータ型に依存します。`time`がDATE型の場合、単位は日です。`time`がDATETIME型の場合、単位は秒です。

- `time`: タイムスタンプが含まれる列。DATE型とDATETIME型がサポートされています。

- `mode`: イベントチェーンのフィルタリングモード。サポートされるデータ型はINTです。値の範囲は0、1、2です。
  - `0`はデフォルト値で、通常のファネル計算を指します。
  - `1`は`DEDUPLICATION`モードを指し、フィルタリングされたイベントチェーンには繰り返しイベントが含まれないようにします。例えば、`array`パラメータが`[event_type = 'A', event_type = 'B', event_type = 'C', event_type = 'D']`で、元のイベントチェーンが"A-B-C-B-D"の場合、イベントBが繰り返され、フィルタリングされたイベントチェーンは"A-B-C"になります。
  - `2`は`FIXED`モードを指し、フィルタリングされたイベントチェーンには指定された順序を乱すイベントが含まれないようにします。例えば、前述の`array`パラメータを使用し、元のイベントチェーンが"A-B-D-C"の場合、イベントDが順序を乱すため、フィルタリングされたイベントチェーンは"A-B"になります。
  - `4`は`INCREASE`モードを指し、フィルタリングされたイベントは厳密にタイムスタンプが増加する必要があります。タイムスタンプが重複するとイベントチェーンが中断されます。このモードはバージョン2.5以降でサポートされています。

- `array`: 定義されたイベントチェーン。配列である必要があります。

## 戻り値

BIGINT型の値を返します。

## 例

**例1**: `uid`に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルタリングモードは`0`です。

この例では、`uid`でソートされたデータを含む`action`テーブルを使用します。

```Plaintext
mysql> select * from action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:20:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Order      | 2020-01-02 11:00:00 |
| 2    | Pay        | 2020-01-02 11:10:00 |
| 3    | Browse     | 2020-01-02 11:20:00 |
| 3    | Click      | 2020-01-02 12:00:00 |
| 4    | Browse     | 2020-01-02 11:50:00 |
| 4    | Click      | 2020-01-02 12:00:00 |
| 5    | Browse     | 2020-01-02 11:50:00 |
| 5    | Click      | 2020-01-02 12:00:00 |
| 5    | Order      | 2020-01-02 11:10:00 |
| 6    | Browse     | 2020-01-02 11:50:00 |
| 6    | Click      | 2020-01-02 12:00:00 |
| 6    | Order      | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

以下のステートメントを実行します：

```Plaintext
select uid,
       window_funnel(1800, time, 0, [event_type='Browse', event_type='Click', 
        event_type='Order', event_type='Pay']) AS level
from action
group by uid
order by uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

結果の説明：

- `uid = 1`の一致するイベントチェーンは"Browse-Click-Order-Pay"で、`4`が返されます。最後の"Browse"イベントの時刻（2020-01-02 11:00:00）は条件を満たしていないため、カウントされません。

- `uid = 2`のイベントチェーンは最初のイベント"Browse"から始まっていないため、`0`が返されます。

- `uid = 3`の一致するイベントチェーンは"Browse"で、`1`が返されます。"Click"イベントは1800秒のタイムウィンドウを超えているため、カウントされません。

- `uid = 4` の一致するイベントチェーンは "Browse-Click" で、`2` が返されます。

- `uid = 5` の一致するイベントチェーンは "Browse-Click" で、`2` が返されます。"Order" イベント（2020-01-02 11:10:00）はイベントチェーンに含まれていないため、カウントされません。

- `uid = 6` の一致するイベントチェーンは "Browse-Click-Order" で、`3` が返されます。

**例 2**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1800秒で、フィルターモード `0` と `1` が使用されます。

この例では、`time` によってデータがソートされている `action1` テーブルを使用します。

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Order      | 2020-01-02 11:29:00 |
| 1    | Click      | 2020-01-02 11:29:50 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Click      | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

以下のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1800,time,0,['Browse', 
        'Click', 'Order', 'Pay']) AS level
from action1
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` の場合、「Click」イベント（2020-01-02 11:29:50）は繰り返しイベントですが、モード `0` が使用されているため、カウントされます。その結果、`4` が返されます。

モードを `1` に変更し、ステートメントを再度実行します。

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

重複排除後にフィルタリングされた最長のイベントチェーンは "Browse-Click-Order" で、`3` が返されます。

**例 3**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルターモード `0` と `2` が使用されます。

この例では、`time` によってデータがソートされている `action2` テーブルを使用します。

```Plaintext
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 2    | Browse     | 2020-01-02 11:00:01 |
| 1    | Click      | 2020-01-02 11:10:00 |
| 1    | Pay        | 2020-01-02 11:30:00 |
| 1    | Order      | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

以下のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,0,['Browse', 'Click', 
        'Order', 'Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` に対しては、モード `0` が使用され、「Pay」イベント（2020-01-02 11:30:00）がイベントチェーンを中断しないため、`3` が返されます。

モードを `2` に変更し、ステートメントを再度実行します。

```Plaintext
select uid,
       window_funnel(1900,time,2,['Browse', 'Click', 
        'Order', 'Pay']) AS level
from action2
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

「Pay」イベントによってイベントチェーンが中断され、イベントカウンターが停止するため、`2` が返されます。フィルタリングされたイベントチェーンは "Browse-Click" です。

**例 4**: `uid` に基づいて連続するイベントの最大数を計算します。スライディングウィンドウは1900秒で、フィルターモード `0` と `4` が使用されます。

この例では、`time` によってデータがソートされている `action3` テーブルを使用します。

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | Browse     | 2020-01-02 11:00:00 |
| 1    | Click      | 2020-01-02 11:00:01 |
| 2    | Browse     | 2020-01-02 11:00:03 |
| 1    | Order      | 2020-01-02 11:00:31 |
| 2    | Click      | 2020-01-02 11:00:03 |
| 2    | Order      | 2020-01-02 11:01:03 |
+------+------------+---------------------+
6 rows in set (0.02 sec)
```

以下のステートメントを実行します。

```Plaintext
select uid,
       window_funnel(1900,time,0,['Browse', 'Click',
        'Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
2 rows in set (0.02 sec)
```

`uid = 1` と `uid = 2` に対して `3` が返されます。

モードを `4` に変更し、ステートメントを再度実行します。

```Plaintext
select uid,
       window_funnel(1900,time,4,['Browse', 'Click',
        'Order']) AS level
from action3
group by uid
order by uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
2 rows in set (0.02 sec)
```
`1` は、`uid = 2` の場合、モード `4`（厳密に増加）が使用されるため返されます。「クリック」は「BROWSE」と同じ秒に起こります。したがって、「クリック」と「オーダー」はカウントされません。

## キーワード

window_funnel、ファネル、window_funnel
