---
displayed_sidebar: English
---

# JSON 演算子

StarRocks は、`<`、`<=`、`>`、`>=`、`=`、`!=` という JSON 比較演算子をサポートしています。これらの演算子を使用して JSON データをクエリできます。ただし、StarRocks では `IN` を使用して JSON データをクエリすることはできません。

- > 演算子のオペランドは両方とも JSON 値でなければなりません。

- > 演算子の一方のオペランドが JSON 値で、もう一方が JSON 値でない場合、JSON 値でないオペランドは算術演算中に JSON 値に変換されます。変換ルールの詳細については、[CAST](./json-query-and-processing-functions/cast.md)を参照してください。

## 算術ルール

JSON 演算子は以下の算術ルールに従います：

- 演算子のオペランドが同じデータ型の JSON 値である場合：
  - 両オペランドが NUMBER、STRING、BOOLEAN などの基本データ型の JSON 値である場合、演算子は基本データ型の算術ルールに従って演算を行います。

> 注：両オペランドが数値で、一方が DOUBLE 値で他方が INT 値の場合、演算子は INT 値を DOUBLE 値に変換します。

- 両オペランドが OBJECT や ARRAY などの複合データ型の JSON 値である場合、演算子は第一オペランドのキーの順序に基づいてキーを辞書順にソートし、その後オペランド間のキーの値を比較します。

例 1:

第一オペランドは `{"a": 1, "c": 2}` で、第二オペランドは `{"b": 1, "a": 2}` です。この例では、演算子はオペランド間のキー `a` の値を比較します。第一オペランドのキー `a` の値は `1` で、第二オペランドのキー `a` の値は `2` です。値 `1` は値 `2` より小さいです。したがって、演算子は第一オペランド `{"a": 1, "c": 2}` が第二オペランド `{"b": 1, "a": 2}` より小さいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 2}');

       -> 1
```

例 2:

第一オペランドは `{"a": 1, "c": 2}` で、第二オペランドは `{"b": 1, "a": 1}` です。この例では、演算子は最初にオペランド間のキー `a` の値を比較します。両オペランドのキー `a` の値は共に `1` です。次に、演算子はオペランド間のキー `c` の値を比較します。第二オペランドにはキー `c` が含まれていません。したがって、演算子は第一オペランド `{"a": 1, "c": 2}` が第二オペランド `{"b": 1, "a": 1}` より大きいと結論付けます。

```plaintext
mysql> SELECT PARSE_JSON('{"a": 1, "c": 2}') < PARSE_JSON('{"b": 1, "a": 1}');

       -> 0
```

- 演算子のオペランドが異なるデータ型の JSON 値である場合、演算子は NULL < BOOLEAN < ARRAY < OBJECT < DOUBLE < INT < STRING の順に従ってオペランドを比較します。

```plaintext
mysql> SELECT PARSE_JSON('"a"') < PARSE_JSON('{"a": 1, "c": 2}');

       -> 0
```
