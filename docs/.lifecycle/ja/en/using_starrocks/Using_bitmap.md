---
displayed_sidebar: English
---

# ビットマップを使用した正確なカウントディスティンクト

このトピックでは、StarRocksでビットマップを使用して異なる値の数を計算する方法について説明します。

ビットマップは、配列内の異なる値の数を計算するための便利なツールです。この方法は、従来のカウントディスティンクトと比較して、ストレージスペースを少なくし、計算を高速化することができます。例えば、[0, n) の範囲の値を持つAという配列があるとします。ビットマップを(n+7)/8バイトで使用することで、配列内の異なる要素の数を計算できます。これを行うには、すべてのビットを0に初期化し、要素の値をビットの添え字として設定し、その後すべてのビットを1に設定します。ビットマップ内の1の数が配列内の異なる要素の数です。

## 従来のカウントディスティンクト

StarRocksはMPPアーキテクチャを使用しており、カウントディスティンクトを使用する際に詳細データを保持することができます。しかし、カウントディスティンクト機能はクエリ処理中に複数のデータシャッフルを必要とするため、リソースの消費が増え、データ量が増加するにつれてパフォーマンスが線形に低下します。

以下のシナリオでは、テーブル(dt、page、user_id)の詳細データに基づいてUVを計算します。

|  dt   |   page  | user_id |
| :---: | :---: | :---:|
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 102 |
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 101 |
|   20191206  |   game  | 101 |
|   20191206  |   shopping  | 101 |

StarRocksは以下の図に従ってデータを計算します。まず`page`と`user_id`列でデータをグループ化し、その後処理結果をカウントします。

![alter](../assets/6.1.2-2.png)

* 注: 図は2つのBEノードで計算された6行のデータの概念図を示しています。

大量のデータを処理し、複数のシャッフル操作が必要な場合、計算リソースの必要量が大幅に増加する可能性があります。これによりクエリが遅くなります。しかし、ビットマップ技術を使用することで、この問題に対処し、そのようなシナリオでのクエリパフォーマンスを向上させることができます。

`page`でグループ化してUVをカウントします：

```sql
select page, count(distinct user_id) as uv from table group by page;

|  page   |   uv  |
| :---: | :---: |
|   game  |  1   |
|   shopping  |   2  |
```

## ビットマップを使用したカウントディスティンクトの利点

ビットマップは、COUNT(DISTINCT expr)と比較して以下の点で利点があります：

* ストレージスペースの削減：INT32データの異なる値の数をビットマップで計算する場合、必要なストレージスペースはCOUNT(DISTINCT expr)の1/32だけです。StarRocksは圧縮されたローリングビットマップを使用して計算を実行し、従来のビットマップと比較してさらにストレージスペースを節約します。
* 計算の高速化：ビットマップはビット単位の操作を使用するため、COUNT(DISTINCT expr)と比較して計算が速くなります。StarRocksでは、異なる値の数の計算が並列で処理され、クエリパフォーマンスがさらに向上します。

Roaring Bitmapの実装については、[特定の論文と実装](https://github.com/RoaringBitmap/RoaringBitmap)を参照してください。

## 使用上の注意点

* ビットマップインデックスとビットマップカウントディスティンクトは、どちらもビットマップ技術を使用します。しかし、導入された目的と解決される問題は完全に異なります。前者はカーディナリティが低い列挙型列をフィルタリングするために使用され、後者はデータ行の値列内の異なる要素の数を計算するために使用されます。
* StarRocks 2.3以降のバージョンでは、テーブルタイプ（集約テーブル、重複キーテーブル、プライマリキーテーブル、ユニークキーテーブル）に関係なく、値列をBITMAPとして定義することができます。ただし、テーブルの[ソートキー](../table_design/Sort_key.md)はBITMAPタイプにはできません。
* テーブルを作成する際には、値列をBITMAPとして定義し、集約関数を[BITMAP_UNION](../sql-reference/sql-functions/bitmap-functions/bitmap_union.md)として定義することができます。
* Roaring Bitmapは、TINYINT、SMALLINT、INT、BIGINTのデータタイプの異なる値の数を計算するためにのみ使用できます。他のデータタイプの場合は、[グローバル辞書を構築する](#global-dictionary)必要があります。

## ビットマップを使用したカウントディスティンクト

ページUVの計算を例にとりましょう。

1. 集約関数`BITMAP_UNION`を使用するBITMAP列`visit_users`を持つ集約テーブルを作成します。

    ```sql
    CREATE TABLE `page_uv` (
      `page_id` INT NOT NULL COMMENT 'ページID',
      `visit_date` datetime NOT NULL COMMENT 'アクセス時間',
      `visit_users` BITMAP BITMAP_UNION NOT NULL COMMENT 'ユーザーID'
    ) ENGINE=OLAP
    AGGREGATE KEY(`page_id`, `visit_date`)
    DISTRIBUTED BY HASH(`page_id`)
    PROPERTIES (
      "replication_num" = "3",
      "storage_format" = "DEFAULT"
    );
    ```

2. このテーブルにデータをロードします。

    INSERT INTOを使用してデータをロードします。

    ```sql
    INSERT INTO page_uv VALUES
    (1, '2020-06-23 01:30:30', to_bitmap(13)),
    (1, '2020-06-23 01:30:30', to_bitmap(23)),
    (1, '2020-06-23 01:30:30', to_bitmap(33)),
    (1, '2020-06-23 02:30:30', to_bitmap(13)),
    (2, '2020-06-23 01:30:30', to_bitmap(23));
    ```

    データがロードされた後:

    * `page_id = 1, visit_date = '2020-06-23 01:30:30'`の行では、`visit_users`フィールドに3つのビットマップ要素(13、23、33)が含まれています。
    * `page_id = 1, visit_date = '2020-06-23 02:30:30'`の行では、`visit_users`フィールドに1つのビットマップ要素(13)が含まれています。
    * `page_id = 2, visit_date = '2020-06-23 01:30:30'`の行では、`visit_users`フィールドに1つのビットマップ要素(23)が含まれています。

   ローカルファイルからデータをロードします。

    ```shell
    echo -e '1,2020-06-23 01:30:30,130\n1,2020-06-23 01:30:30,230\n1,2020-06-23 01:30:30,120\n1,2020-06-23 02:30:30,133\n2,2020-06-23 01:30:30,234' > tmp.csv | 
    curl --location-trusted -u <username>:<password> -H "label:label_1600960288798" \
        -H "column_separator:," \
        -H "columns:page_id,visit_date,visit_users, visit_users=to_bitmap(visit_users)" -T tmp.csv \
        http://StarRocks_be0:8040/api/db0/page_uv/_stream_load
    ```

3. ページUVを計算します。

    ```sql
    SELECT page_id, count(distinct visit_users) FROM page_uv GROUP BY page_id;
    +-----------+------------------------------+
    |  page_id  | count(DISTINCT `visit_users`)|
    +-----------+------------------------------+
    |         1 |                            3 |
    |         2 |                            1 |
    +-----------+------------------------------+
    2 rows in set (0.00 sec)
    ```

## グローバル辞書

現在、ビットマップベースのCount Distinctメカニズムでは、入力が整数である必要があります。ユーザーがビットマップへの入力として他のデータ型を使用する必要がある場合、独自のグローバル辞書を構築して、他のデータ型（例えば文字列型）を整数型にマッピングする必要があります。グローバル辞書を構築するためのいくつかのアイデアがあります。

### Hiveテーブルベースのグローバル辞書

この方式のグローバル辞書自体はHiveテーブルで、生の値用の列とエンコードされたInt値用の列の2つの列があります。グローバル辞書を生成する手順は以下の通りです。

1. ファクトテーブルの辞書列を重複排除して一時テーブルを生成します。
2. 一時テーブルとグローバル辞書を左結合し、`new value`を一時テーブルに追加します。
3. `new value`をエンコードし、グローバル辞書に挿入します。
4. ファクトテーブルと更新されたグローバル辞書を左結合し、辞書項目をIDに置き換えます。

この方法では、グローバル辞書を更新し、ファクトテーブルの値列をSparkまたはMRを使用して置き換えることができます。トライツリーベースのグローバル辞書と比較して、このアプローチは分散可能であり、グローバル辞書を再利用できます。

ただし、元のファクトテーブルが複数回読み取られること、およびグローバル辞書の計算中に多くの余分なリソースを消費する2つの結合があることに注意が必要です。

### トライツリーに基づくグローバル辞書の構築

ユーザーはトライツリー（別名プレフィックスツリーや辞書ツリー）を使用して独自のグローバル辞書を構築することもできます。トライツリーは、ノードの子孫に共通のプレフィックスがあり、クエリ時間を短縮し、文字列比較を最小限に抑えるために使用できるため、辞書エンコーディングの実装に適しています。しかし、トライツリーの実装は分散が難しく、データ量が比較的大きい場合にパフォーマンスのボトルネックを生じる可能性があります。

グローバル辞書を構築し、他のタイプのデータを整数データに変換することで、Bitmapを使用して整数でないデータ列に対する正確なCount Distinct分析を行うことができます。
