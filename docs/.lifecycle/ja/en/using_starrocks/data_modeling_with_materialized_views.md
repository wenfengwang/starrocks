---
displayed_sidebar: English
---

# マテリアライズド・ビューを使用したデータモデリング

このトピックでは、StarRocksの非同期マテリアライズド・ビューを利用したデータモデリングの実行方法について説明します。これにより、データウェアハウスのETLパイプラインを大幅に簡素化し、データ品質とクエリ性能を大きく向上させることができます。

## 概要

データモデリングは、合理的な方法論を用いてデータのクリーニング、階層化、集約、関連付けを行うプロセスです。これにより、分析が困難な粗く、複雑、またはコストがかかりすぎる生データを理解しやすい形で表現し、データに関する実用的な洞察を提供することができます。

しかし、実際のデータモデリングにおける一般的な課題は、モデリングプロセスがビジネスの発展の速度に追いつくのが難しく、データモデリングの努力に対する投資収益率を測定することが困難であることです。モデリング手法は単純であるにもかかわらず、ビジネスの専門家はデータの整理とガバナンスに関する堅固なバックグラウンドを必要としますが、これは複雑なプロセスです。ビジネスの初期段階では、意思決定者はデータモデリングに十分なリソースを割り当てることは稀であり、データモデリングがもたらす価値を認識することは難しいです。さらに、ビジネスモデルは急速に変化する可能性があり、モデリング手法自体も反復と進化を必要とします。そのため、多くのデータアナリストはモデリングを避け、生データを直接使用することを選びますが、これは避けられないデータ品質とクエリ性能の問題につながります。モデリングの必要性が生じた場合、既に確立されたデータ分析パターンをデータモデルに合わせて再構築することは困難です。

マテリアライズド・ビューをデータモデリングに使用することで、これらの問題を効果的に解決できます。StarRocksの非同期マテリアライズド・ビューは次のような利点を提供します。

- **データウェアハウスアーキテクチャの簡素化**: StarRocksはワンストップのデータガバナンス体験を提供するため、他のデータ処理システムの維持が不要になり、それに伴う人的およびシステムリソースの節約が可能です。
- **データモデリング体験の向上**: 基本的なSQL知識を持つデータアナリストでも、StarRocksを使用してデータモデリングを行うことができます。データモデリングはもはや経験豊かなデータエンジニアの専門領域ではありません。
- **メンテナンスの複雑さの低減**: StarRocksの非同期マテリアライズド・ビューは、データレイヤー間の系譜関係と依存関係を自動的に管理するため、これらのタスクを処理するためのデータプラットフォーム全体が不要になります。

![Modeling-1](../assets/Modeling-1.png)

実際のシナリオでは、StarRocksのビュー（論理ビュー）と非同期マテリアライズド・ビューを組み合わせて使用し、以下のようにデータモデリングを実行できます。

1. ビューを使用してリアルタイムデータをディメンションデータと関連付け、マテリアライズド・ビューを使用してデータレイクの履歴データをディメンションデータと関連付けます。必要なデータクリーニングとセマンティックマッピングを行い、ビジネスシナリオに必要なセマンティクスを反映した中間層の詳細データを取得します。
2. アプリケーション層では、さまざまなビジネスシナリオに合わせたデータの結合、集約、結合、ウィンドウ計算を実行します。これにより、リアルタイムパイプライン用のビューと、ほぼリアルタイムパイプライン用のマテリアライズド・ビューが生成されます。
3. アプリケーション側では、タイムリネスとパフォーマンスの要件に基づいて適切なAnalytical Data Store（ADS）をクエリ分析用に選択します。これらのADSはリアルタイムダッシュボード、ほぼリアルタイムBI、アドホッククエリ、スケジュールされたレポートに対応できます。

このプロセスを通じて、次のセクションで詳しく説明するStarRocksのいくつかの組み込み機能を活用します。

## 非同期マテリアライズド・ビューの機能

StarRocksの非同期マテリアライズド・ビューには、データモデリングを支援する以下のアトミック機能があります。

- **自動更新**: データがベーステーブルにロードされた後、マテリアライズド・ビューは自動的に更新されます。スケジューリングタスクを外部で維持する必要はありません。
- **パーティション化された更新**: 時系列データを特徴とするテーブルに構築されたマテリアライズド・ビューのパーティション化された更新を通じて、ほぼリアルタイムの計算を実現できます。
- **ビューとのシナジー**: マテリアライズド・ビューと論理ビューを使用してマルチレイヤーモデリングを実現し、中間層の再利用を可能にし、データモデルを簡素化できます。
- **スキーマ変更**: 複雑なデータパイプラインを変更することなく、シンプルなSQLステートメントを使用して計算結果を変更できます。

これらの特徴を活用することで、様々なビジネスニーズとシナリオに対応する包括的で適応性の高いデータモデルを設計することができます。

### 自動更新

非同期マテリアライズド・ビューを作成する際には、REFRESH句を使用して更新戦略を指定することができます。現在、StarRocksは非同期マテリアライズド・ビューの以下の更新戦略をサポートしています。

- **自動更新** (`REFRESH ASYNC`): ベーステーブルのデータが変更されるたびに更新タスクがトリガされます。データ依存関係はマテリアライズド・ビューによって自動的に管理されます。
- **スケジュールされた更新** (`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`): 例えば分単位、日単位、月単位など、定期的な間隔で更新タスクがトリガされます。ベーステーブルにデータ変更がなければ、更新タスクはトリガされません。
- **手動更新** (`REFRESH MANUAL`): 更新タスクは、`REFRESH MATERIALIZED VIEW`を手動で実行したときにのみトリガされます。この更新戦略は、更新タスクをトリガする外部のスケジューリングフレームワークを維持している場合に使用できます。

構文：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### パーティション化された更新

非同期マテリアライズドビューを作成する場合、PARTITION BY 句を指定してベーステーブルのパーティションをマテリアライズドビューのパーティションに関連付け、パーティションレベルでのリフレッシュを実現できます。

- `PARTITION BY <column>`: ベーステーブルとマテリアライズドビューで同じパーティション列を参照できます。結果として、ベーステーブルとマテリアライズドビューは同じ粒度でパーティションされます。
- `PARTITION BY date_trunc(<column>)`: date_trunc 関数を使用して、時間単位を切り捨てることにより、マテリアライズドビューに異なるパーティション戦略（粒度のレベルで）を割り当てることができます。
- `PARTITION BY { time_slice | date_slice }(<column>)`: date_trunc と比較して、time_slice と date_slice はより柔軟な時間粒度の調整を提供し、時間に基づくパーティションをより細かく制御できます。

構文：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### ビューとのシナジー

- マテリアライズドビューはビューに基づいて作成できます。この場合、ビューが参照するベーステーブルのデータが変更されたとき、マテリアライズドビューは自動的にリフレッシュされます。
- 他のマテリアライズドビューに基づいてマテリアライズドビューを作成することもでき、これにより多層のカスケードリフレッシュメカニズムが可能になります。
- マテリアライズドビューに基づいてビューを作成することができ、これは通常のテーブルと同等です。

### スキーマ変更

- 2つの非同期マテリアライズドビュー間でアトミックな交換を行うには、ALTER MATERIALIZED VIEW SWAP ステートメントを使用します。これにより、列を追加したり、列の型を変更したりした新しいマテリアライズドビューを作成し、古いものと交換することができます。
- ビューの定義は、ALTER VIEW ステートメントを使用して直接変更することができます。
- StarRocksの通常テーブルは、SWAPまたはALTER操作を使用して変更できます。
- さらに、ベーステーブル（マテリアライズドビュー、ビュー、または通常テーブルである可能性があります）に変更がある場合、それに応じてマテリアライズドビューにカスケード変更がトリガーされます。

## レイヤードモデリング

多くの実世界のビジネスシナリオでは、リアルタイムの詳細データ、ディメンションデータ、データレイクからの履歴データなど、さまざまな形態のデータソースが存在します。一方で、ビジネス要件はリアルタイムダッシュボード、ほぼリアルタイムのBIクエリ、アドホッククエリ、スケジュールされたレポートなど、多様な分析手法を求めています。異なるシナリオには異なる要求があり、柔軟性、パフォーマンス、コスト効率のいずれかを優先するものがあります。

明らかに、単一のソリューションではこれらの多様な要求に十分に対応することはできません。StarRocksはビューとマテリアライズドビューの使用を組み合わせることで、これらのニーズに効率的に対応できます。ビューは物理データを保持しないため、ビューに対するクエリは毎回、ビューの定義に従って解析され実行されます。一方、事前計算された結果を保持するマテリアライズドビューは、繰り返しの実行オーバーヘッドを防ぐことができます。ビューはビジネスセマンティクスを表現し、SQLの複雑さを簡素化するのに適していますが、クエリ実行のコストを削減することはできません。一方、マテリアライズドビューは事前計算を通じてクエリパフォーマンスを最適化し、ETLパイプラインを合理化するのに適しています。

以下はビューとマテリアライズドビューの違いをまとめた表です：

|                                      | **ビュー**                                                     | **マテリアライズドビュー**                                        |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **ユースケース**                        | ビジネスモデリング、データガバナンス                           | データモデリング、透過的な加速、データレイク統合 |
| **ストレージコスト**                     | ストレージコストなし                                              | 事前計算された結果を保存することで発生するストレージコスト        |
| **更新コスト**                      | 更新コストなし                                               | ベーステーブルデータ更新時に発生するリフレッシュコスト           |
| **パフォーマンス上の利点**             | パフォーマンス上の利点なし                                       | 事前計算された結果の再利用によるクエリ加速 |
| **データのリアルタイム性** | ビューに対するクエリはリアルタイムで計算されるため、最新のデータが返されます。 | 結果が事前計算されているため、データが最新でない可能性があります。 |
| **依存性**                       | ビューはベーステーブルを名前で参照するため、ベーステーブル名が変更されると無効になります。 | ベーステーブル名の変更がマテリアライズドビューの可用性に影響を与えない、IDでベーステーブルを参照します。 |
| **作成構文**              | CREATE VIEW                                                  | CREATE MATERIALIZED VIEW                                     |
| **変更構文**          | ALTER VIEW                                                   | ALTER MATERIALIZED VIEW                                      |

ビュー、マテリアライズドビュー、ベーステーブルを変更するには、次のステートメントを使用できます：

```SQL
-- テーブルを変更する。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 2つのテーブルを交換する。
ALTER TABLE <table1> SWAP WITH <table2>;

-- ビューの定義を変更する。
ALTER VIEW <view_name> AS <query>;

-- 2つのマテリアライズドビューを交換する
-- （2つのマテリアライズドビューの名前を交換することで、内部のデータに影響を与えずに）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- マテリアライズドビューを再アクティブ化する。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

スキーマ変更は以下の原則に従います：

- テーブルの名前変更やスワップ操作は、依存するマテリアライズドビューを非アクティブにします。スキーマ変更操作の場合、依存するマテリアライズドビューは、マテリアライズドビューが参照するベーステーブルの列にスキーマ変更操作が実行された場合にのみ非アクティブに設定されます。
- ビューの定義を変更すると、依存するマテリアライズドビューは非アクティブに設定されます。
- マテリアライズドビューが交換されると、それに基づいて構築されたネストされたマテリアライズドビューも非アクティブに設定されます。

- 非アクティブステータスは、マテリアライズドビューの依存関係がなくなるまで上向きにカスケードします。
- 非アクティブなマテリアライズドビューは、リフレッシュしたり、自動クエリ書き換えに使用したりすることはできません。
- 非アクティブなマテリアライズドビューは直接クエリ可能ですが、再びアクティブになるまでデータの整合性は保証されません。

非アクティブなマテリアライズドビューのデータ整合性は保証されませんが、以下の方法で機能を復元できます：

- **手動修復**: `ALTER MATERIALIZED VIEW <mv_name> ACTIVE` を実行することで、非アクティブなマテリアライズドビューを手動で修復できます。このステートメントは、元のSQL定義に基づいてマテリアライズドビューを再作成します。基盤となるスキーマが変更された後もSQL定義が有効である必要があります。そうでなければ、操作は失敗します。
- **自動修復**: StarRocksは非アクティブなマテリアライズドビューを自動的にアクティブ化しようとしますが、このプロセスのタイムリネスは保証されません。

## パーティションモデリング

階層モデリングに加えて、パーティションモデリングもデータモデリングの重要な側面です。データモデリングには、ビジネスセマンティクスに基づいてデータを関連付け、タイムリネスの要件に応じてデータのTime-To-Live（TTL）を設定することが含まれます。パーティションモデリングはこのプロセスにおいて重要な役割を果たします。

パーティションモデリングはデータモデリングの重要な側面であり、階層モデリングを補完します。これには、ビジネスセマンティクスに基づいてデータを関連付け、タイムリネスの要件に応じてデータのTTLを設定することが含まれます。データパーティショニングはこのプロセスにおいて重要な役割を果たします。

データを関連付けるさまざまな方法により、スタースキーマやスノーフレークスキーマなど、さまざまなモデリングアプローチが生まれます。これらのモデルには共通点があり、すべてファクトテーブルとディメンションテーブルを使用します。ビジネスシナリオには、複数の大規模なファクトテーブルが必要なものもあれば、複雑なディメンションテーブルとそれらの間の関係を扱うものもあります。StarRocksのマテリアライズドビューはファクトテーブルのパーティション関連付けをサポートし、ファクトテーブルがパーティション化され、マテリアライズドビューの結合結果も同様にパーティション化されます。

![Modeling-2](../assets/Modeling-2.png)

上の図が示すように、マテリアライズドビューはファクトテーブルを複数のディメンションテーブルに関連付けます：

- 特定のベーステーブル（通常はファクトテーブル）のパーティションキーをマテリアライズドビューのパーティションキーとして参照する必要があります（`PARTITION BY fact_tbl.col`）、それによってそれらのパーティション戦略を関連付けます。各マテリアライズドビューは一つのベーステーブルにのみ関連付けられます。
- 参照されたテーブルのパーティション内のデータが変更された場合、マテリアライズドビュー内の対応するパーティションが他のパーティションに影響を与えることなく更新されます。
- 参照されていないテーブルのデータが変更された場合、デフォルトではマテリアライズドビュー全体が更新されます。ただし、参照されていない特定のベーステーブルのデータ変更を無視し、これらのテーブルのデータが変更されたときにマテリアライズドビューが更新されないように選択することもできます。

このようなパーティションの関連付けは、さまざまなビジネスシナリオをサポートします：

- **ファクトテーブルの更新**: ファクトテーブルを日単位や時間単位などの細かいレベルでパーティション化できます。ファクトテーブルが更新された後、マテリアライズドビューの対応するパーティションは自動的に更新されます。
- **ディメンションテーブルの更新**: 通常、ディメンションテーブルのデータ更新は、関連するすべての結果の更新を引き起こし、コストがかかる可能性があります。一部のディメンションテーブルのデータ更新を無視して、マテリアライズドビュー全体の更新を回避するか、時間範囲を指定して時間範囲内のパーティションのみを更新するように選択できます。
- **外部テーブルの自動更新**: Apache HiveやApache Icebergなどの外部データソースでは、パーティションレベルでデータが変更されます。StarRocksのマテリアライズドビューは、パーティションレベルで外部カタログの変更をサブスクライブし、マテリアライズドビューの対応するパーティションのみを更新します。
- **TTL**: マテリアライズドビューのパーティション戦略を設定する際に、保持する最新のパーティションの数を設定することで、最新のデータのみを保持することができます。これは、アナリストが特定の期間の最新データのみをクエリするビジネスシナリオで役立ちます。過去のデータを全て保持する必要はありません。

更新動作を制御するために使用できるいくつかのパラメーターがあります：

- `partition_refresh_number`: 各更新操作で更新するパーティションの数。
- `partition_ttl_number`: 保持する最新のパーティションの数。
- `excluded_trigger_tables`: 自動更新をトリガーしないようにデータ変更を無視できるテーブル。
- `auto_refresh_partitions_limit`: 各自動更新操作で更新するパーティションの数。

詳細については、[CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)を参照してください。

現在、パーティション化されたマテリアライズドビューには以下の制限があります：

- パーティション化されたマテリアライズドビューは、パーティション化されたテーブルに基づいてのみ構築できます。
- パーティションキーとしては、DATE型またはDATETIME型の列のみを使用できます。STRINGデータ型はサポートされていません。
- パーティションのロールアップは、date_trunc、time_slice、date_slice関数を使用してのみ実行できます。
- パーティションキーとして指定できるのは1つの列のみです。複数のパーティションキーはサポートされていません。

## 概要

StarRocksの非同期マテリアライズドビューをデータモデリングに活用することは、パイプライン管理を単純化し、宣言型モデリング言語を用いてデータモデリングの効率性と柔軟性を向上させる利点を提供します。

データモデリングに加えて、StarRocksの非同期マテリアライズドビューは、透過的な加速とデータレイク統合を含む様々なシナリオでの応用が見られます。これにより、データの価値をさらに探求しやすくなり、データ効率が改善されます。
