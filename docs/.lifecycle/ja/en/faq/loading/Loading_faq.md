---
displayed_sidebar: English
---

# データの読み込み

## 1. 「close_index_channel_failed」または「too_many_tablet_versions」エラーが発生した場合はどうすればよいですか?

ロードジョブを頻繁に実行しすぎると、データがタイムリーにコンパクションされないことがあります。その結果、ロード中に生成されるデータバージョンの数が、許可されているデータバージョンの最大数（デフォルトは1000）を超えることがあります。この問題を解決するには、以下の方法のいずれかを使用します:

- 各個別のジョブでロードするデータ量を増やし、ロードの頻度を減らします。

- 各BEのBE設定ファイル**be.conf**の設定項目を以下のように変更し、データコンパクションを加速します:

    ```Plain
    cumulative_compaction_num_threads_per_disk = 4
    base_compaction_num_threads_per_disk = 2
    cumulative_compaction_check_interval_seconds = 2
    ```

  上記の設定項目を変更した後は、メモリとI/Oが正常であることを確認するために監視する必要があります。

## 2. 「Label_Already_Exists」エラーが発生した場合はどうすればよいですか?

このエラーは、ロードジョブが同じStarRocksデータベース内で成功した別のロードジョブ、または実行中のロードジョブと同じラベルを持っているために発生します。

Stream LoadジョブはHTTPによって送信されます。一般的に、HTTPクライアントの全てのプログラミング言語にはリクエスト再試行ロジックが組み込まれています。StarRocksクラスタがHTTPクライアントからロードジョブリクエストを受け取ると、すぐにリクエストの処理を開始しますが、HTTPクライアントにジョブ結果をタイムリーに返しません。その結果、HTTPクライアントは同じロードジョブリクエストを再送します。しかし、StarRocksクラスタは既に最初のリクエストを処理しているため、2番目のリクエストに対して「Label_Already_Exists」エラーを返します。

異なるロード方法を使用して送信されたロードジョブが同じラベルを持たず、繰り返し送信されないようにするには、以下の手順に従ってください:

- FEログを確認し、失敗したロードジョブのラベルが2回記録されているかどうかをチェックします。ラベルが2回記録されている場合、クライアントがロードジョブリクエストを2回送信しています。

  > **注記**
  >
  > StarRocksクラスタは、ロード方法に基づいてロードジョブのラベルを区別しません。したがって、異なるロード方法を使用して送信されたロードジョブが同じラベルを持つ可能性があります。

- `SHOW LOAD WHERE LABEL = "xxx"` を実行して、同じラベルを持ち**FINISHED**状態にあるロードジョブを確認します。

  > **注記**
  >
  > `xxx`は、確認したいラベルです。

ロードジョブを送信する前に、データをロードするのに必要なおおよその時間を計算し、それに応じてクライアント側のリクエストタイムアウト期間を調整することを推奨します。これにより、クライアントがロードジョブリクエストを複数回送信することを防ぐことができます。

## 3. 「ETL_QUALITY_UNSATISFIED; msg:quality not good enough to cancel」エラーが発生した場合はどうすればよいですか?

[SHOW LOAD](../../sql-reference/sql-statements/data-manipulation/SHOW_LOAD.md)を実行し、返された実行結果のエラーURLを使用してエラーの詳細を確認します。

一般的なデータ品質エラーは以下の通りです:

- 「CSV文字列をINTに変換できませんでした。」
  
  ソース列の文字列を目的の列のデータ型に変換できませんでした。例えば、`abc`を数値に変換できませんでした。

- 「入力の長さがスキーマの長さを超えています。」
  
  ソース列の値の長さが目的の列でサポートされている長さを超えています。例えば、CHARデータ型のソース列の値がテーブル作成時に指定された目的の列の最大長を超えている場合や、INTデータ型のソース列の値が4バイトを超えている場合です。

- 「実際の列数がスキーマの列数より少ないです。」
  
  指定された列区切り文字に基づいてソース行が解析された後、得られた列の数が目的のテーブルの列数より少なくなっています。考えられる理由は、ロードコマンドまたはステートメントで指定された列区切り文字が、その行で実際に使用されている列区切り文字と異なる場合です。

- 「実際の列数がスキーマの列数を超えています。」
  
  指定された列区切り文字に基づいてソース行が解析された後、得られた列の数が目的のテーブルの列数を超えています。考えられる理由は、ロードコマンドまたはステートメントで指定された列区切り文字が、その行で実際に使用されている列区切り文字と異なる場合です。

- 「小数部の長さがスキーマのスケールより長いです。」
  
  DECIMAL型のソース列の値の小数部が指定された長さを超えています。

- 「整数部の長さがスキーマの精度より長いです。」
  
  DECIMAL型のソース列の値の整数部が指定された長さを超えています。

- 「このキーに対応するパーティションがありません。」
  
  ソース行のパーティション列の値がパーティション範囲内にありません。

## 4. RPCがタイムアウトする場合はどうすればよいですか?

各BEのBE設定ファイル**be.conf**で`write_buffer_size`設定項目の設定を確認します。この設定項目は、BE上のメモリブロックごとの最大サイズを制御するために使用されます。デフォルトの最大サイズは100MBです。最大サイズが非常に大きい場合、リモートプロシージャコール（RPC）がタイムアウトする可能性があります。この問題を解決するには、BE設定ファイルの`write_buffer_size`と`tablet_writer_rpc_timeout_sec`の設定を調整します。詳細は[BE設定](../../loading/Loading_intro.md#be-configurations)を参照してください。

## 5. 「Value count does not match column count」というエラーが発生した場合はどうすればよいですか?

ロードジョブが失敗した後、ジョブ結果で返されたエラーURLを使用してエラーの詳細を取得し、「Value count does not match column count」というエラーが見つかりました。これは、ソースデータファイルの列数と宛先StarRocksテーブルの列数が一致しないことを示しています。

```Java
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:00Z,cpu0,80.99
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:10Z,cpu1,75.23
Error: Value count does not match column count. Expect 3, but got 1. Row: 2023-01-01T18:29:20Z,cpu2,59.44
```

この問題の原因は以下の通りです:

ロードコマンドまたはステートメントで指定された列区切り文字が、ソースデータファイルで実際に使用されている列区切り文字と異なります。上記の例では、CSV形式のデータファイルはコンマ(`,`)で区切られた3つの列で構成されていますが、ロードコマンドまたはステートメントではタブ(`\t`)が列区切り文字として指定されています。その結果、ソースデータファイルの3つの列が誤って1つの列として解析されます。

ロードコマンドまたはステートメントでコンマ(`,`)を列区切り文字として指定し、ロードジョブを再送信してください。
