---
displayed_sidebar: Chinese
---

# プライマリキーモデル

プライマリキーモデルは、プライマリキーとソートキーを別々に定義することをサポートします。データはプライマリキーモデルのテーブルにインポートされる際、まずソートキーに従ってソートされた後に保存されます。クエリ時には、同じプライマリキーを持つデータグループの中で最新のデータが返されます。アップデートモデルと比較して、プライマリキーモデルはクエリ時に集約操作を行う必要がなく、**リアルタイムおよび頻繁な更新**をサポートするシナリオで高効率なクエリを提供しつつ、述語とインデックスのプッシュダウンをサポートします。
> **説明**
>
> - バージョン3.0以前では、プライマリキーモデルはプライマリキーとソートキーを別々に定義することをサポートしていませんでした。
> - バージョン3.1以降、計算ストレージ分離モードではプライマリキーモデルテーブルの作成をサポートし、バージョン3.1.4からはローカルディスク上の永続化インデックスに基づくサポートが追加されました。

## 適用シナリオ

プライマリキーモデルは、リアルタイムおよび頻繁な更新が必要なシナリオに適しています。例えば：

- **StarRocksへのリアルタイムなトランザクションデータの統合**。トランザクションデータベースでは、データの挿入に加えて、多くの更新や削除操作が行われることが一般的です。そのため、トランザクションデータベースからStarRocksへのデータ同期には、プライマリキーモデルの使用が推奨されます。[Flink-CDCなどのツールを使用してTPのBinlogに直接接続する](../../loading/Flink_cdc_load.md)ことで、リアルタイムにデータの追加、削除、変更をプライマリキーモデルに同期し、データ同期プロセスを簡素化することができます。また、Merge-On-Read戦略のアップデートモデルと比較して、クエリパフォーマンスが3〜10倍向上します。
- **部分的な列の更新を利用して簡単にマルチストリームJOINを実現**します。ユーザープロファイルなどの分析シナリオでは、多次元分析のパフォーマンスを向上させるために、通常はワイドテーブルを使用し、データ分析のモデルを簡素化します。このようなシナリオでは、上流データは多くの場合、異なるビジネス（例えば、ショッピング、配送、銀行業務など）やシステム（例えば、ユーザーの異なるタグ属性を計算する機械学習システムなど）から来る可能性があります。プライマリキーモデルの部分的な列の更新機能は、このような要件をうまく満たし、異なるビジネスはそれぞれのビジネスに関連する列を必要に応じて更新するだけでよく、プライマリキーモデルのリアルタイムなデータの同期と高効率なクエリパフォーマンスを継続して享受できます。

## 注意事項

- 永続化インデックスを有効にすると、プライマリキーモデルはプライマリキーインデックスのメモリ使用量を大幅に削減します。インポート時には、一部のプライマリキーインデックスがメモリに存在し、大部分がディスクに存在します。**単一のプライマリキーがエンコードされた後の最大長さは128バイトです**。
- 永続化インデックスを有効にしない場合、プライマリキーモデルはプライマリキーが占めるスペースが比較的に制御可能なシナリオに適しています。インポート時にプライマリキーインデックスがメモリにロードされるためです。**単一のプライマリキーがエンコードされた後の最大長さおよびメモリ使用量の上限は128バイトです**。
  以下の二つのシナリオでは、プライマリキーが占めるスペースが比較的に制御可能です：
  - **データには冷温特性があります**。つまり、最近数日間のホットデータのみが頻繁に変更され、古いコールドデータはほとんど変更されません。例えば、MySQLの注文テーブルがリアルタイムにStarRocksに同期され、分析クエリを提供します。データは日ごとにパーティションされ、注文の変更は新しく作成された最近数日間の注文に集中しています。古い注文が完了すると、それ以上更新されないため、インポート時にそのプライマリキーインデックスはロードされず、メモリを占有しません。メモリには最近数日間のインデックスのみがロードされます。<br />
  ![プライマリキー1](../../assets/3.2-1.png)
  > 図のように、データは日ごとにパーティションされ、最新の2つのパーティションのデータ更新が頻繁です。
  - **ワイドテーブル**(数百から数千の列)。プライマリキーは全体のデータのごく一部を占めるだけで、そのメモリコストは比較的に低いです。例えば、ユーザーステータスとプロファイルテーブルでは、列は非常に多いですが、全体のユーザー数はそれほど多くない（千万から億単位）ため、プライマリキーインデックスのメモリ使用量は比較的に制御可能です。
  ![プライマリキー2](../../assets/3.2-2.png)
  > 図のように、ワイドテーブルではプライマリキーはごく一部を占め、データ行数は多くありません。

## 原理

プライマリキーモデルは、StarRocksが新たに設計開発したストレージエンジンによってサポートされています。アップデートモデルと比較して、プライマリキーモデルのメタデータの組織、読み取り、書き込みの方法は全く異なり、集約操作を実行する必要がなく、述語とインデックスのプッシュダウンをサポートし、クエリパフォーマンスを大幅に向上させます。

アップデートモデルは、全体的にMerge-On-Read戦略を採用しています。書き込み時は処理がシンプルで効率的ですが、クエリ時にはオンラインで複数のバージョンを集約する必要があります。また、Mergeオペレーターが存在するため、述語とインデックスはプッシュダウンできず、クエリパフォーマンスに大きな影響を与えます。

一方、プライマリキーモデルはDelete+Insert戦略を採用しており、同じプライマリキーの下には1つのレコードのみが存在することを保証し、Merge操作を完全に回避します。具体的な実装方法は以下の通りです：

- StarRocksがあるレコードの更新操作を受け取ると、プライマリキーインデックスを通じてそのレコードの位置を見つけ、削除マークを付けた後、新しいレコードを挿入します。UpdateをDelete+Insertに書き換えることに相当します。

- StarRocksがあるレコードの削除操作を受け取ると、プライマリキーインデックスを通じてそのレコードの位置を見つけ、削除マークを付けます。

このように、クエリ時に集約操作を実行する必要がなく、述語とインデックスのプッシュダウンに影響を与えず、クエリの効率的な実行を保証します。

## テーブル作成

- 例えば、日ごとにリアルタイムで注文を分析する必要がある場合、日付 `dt` と注文番号 `order_id` をプライマリキーとし、その他の列を指標列とします。テーブル作成のSQL文は以下の通りです:

```SQL
create table orders (
    dt date NOT NULL,
    order_id bigint NOT NULL,
    user_id int NOT NULL,
    merchant_id int NOT NULL,
    good_id int NOT NULL,
    good_name string NOT NULL,
    price int NOT NULL,
    cnt int NOT NULL,
    revenue int NOT NULL,
    state tinyint NOT NULL
) PRIMARY KEY (dt, order_id)
PARTITION BY RANGE(`dt`) (

    PARTITION p20210820 VALUES [('2021-08-20'), ('2021-08-21')),
    PARTITION p20210821 VALUES [('2021-08-21'), ('2021-08-22')),
    PARTITION p20210929 VALUES [('2021-09-29'), ('2021-09-30')),
    PARTITION p20210930 VALUES [('2021-09-30'), ('2021-10-01'))
) DISTRIBUTED BY HASH(order_id)
PROPERTIES (
    "replication_num" = "3",
    "enable_persistent_index" = "true"
);
```

> **注意**
>
> - テーブル作成時には、`DISTRIBUTED BY HASH` 句を使用してバケットキーを指定する必要があります。指定しない場合、テーブル作成に失敗します。バケットキーの詳細については、[バケット](../Data_distribution.md#分桶)を参照してください。
> - 2.5.7 バージョン以降、StarRocks はテーブル作成およびパーティション追加時にバケット数 (BUCKETS) を自動的に設定する機能をサポートしています。手動でバケット数を設定する必要はありません。詳細は [バケット数の決定](../Data_distribution.md#确定分桶数量) を参照してください。

- 例えば、地域や最近のアクティブ時間に基づいてユーザー状況をリアルタイムで分析する必要がある場合は、ユーザーIDを表す `user_id` 列をプライマリキーとし、地域を表す `address` 列と最近のアクティブ時間を表す `last_active` 列をソートキーとして設定できます。テーブル作成のSQLは以下の通りです：

```SQL
create table users (
    user_id bigint NOT NULL,
    name string NOT NULL,
    email string NULL,
    address string NULL,
    age tinyint NULL,
    sex tinyint NULL,
    last_active datetime,
    property0 tinyint NOT NULL,
    property1 tinyint NOT NULL,
    property2 tinyint NOT NULL,
    property3 tinyint NOT NULL
) PRIMARY KEY (user_id)
DISTRIBUTED BY HASH(user_id)
ORDER BY(`address`,`last_active`)
PROPERTIES (
    "replication_num" = "3",
    "enable_persistent_index" = "true"
);
```

## 使用説明

- プライマリキーに関する説明：
  - テーブル作成時には、プライマリキーを他の列より前に定義する必要があります。
  - プライマリキーは `PRIMARY KEY` で定義されます。
  - プライマリキーは一意性制約を満たし、列の値は変更されません。この例では、プライマリキーは `dt`、`order_id` です。
  - プライマリキーは以下のデータ型をサポートしています：BOOLEAN、TINYINT、SMALLINT、INT、BIGINT、LARGEINT、DATE、DATETIME、VARCHAR/STRING。NULLは許可されていません。
  - パーティション列とバケット列はプライマリキーに含まれている必要があります。

- `enable_persistent_index`：プライマリキーインデックスを永続化するかどうか。ディスクとメモリの両方を使用してプライマリキーインデックスを保存し、プライマリキーインデックスが大量のメモリを消費するのを防ぎます。通常、プライマリキーインデックスを永続化すると、インデックスが消費するメモリは以前の1/10になります。テーブル作成時に `PROPERTIES` でこのパラメータを設定できます。値の範囲は `true` または `false`（デフォルト値）です。

   > - 2.3.0 バージョン以降、StarRocks はこのパラメータの設定をサポートしています。
   > - ディスクがSSDの場合は `true` を設定することをお勧めします。HDDで、インポート頻度が低い場合も `true` を設定できます。
   > - テーブル作成後、このパラメータを変更する必要がある場合は、ALTER TABLE [テーブルの属性を変更する](../../sql-reference/sql-statements/data-definition/ALTER_TABLE.md#修改表的属性) を参照してください。
   > - 3.1 バージョン以降、計算とストレージの分離モードはプライマリキーモデルのテーブル作成をサポートし、3.1.4 バージョン以降はローカルディスク上の永続化インデックスに基づいてサポートしています。

- 永続化インデックスが有効になっていない場合、インポート時にプライマリキーインデックスがメモリ内に存在し、多くのメモリを消費する可能性があります。そのため、以下の提案に従うことをお勧めします：
  - プライマリキーの列数と長さを適切に設定します。メモリ消費が少ないデータ型、例えば INT、BIGINT などをプライマリキーとして使用することをお勧めします。VARCHARは現時点では推奨されていません。
  - テーブル作成前に、プライマリキーのデータ型とテーブルの行数に基づいて、プライマリキーインデックスが消費するメモリを予測し、メモリオーバーフローを避けるために計算します。以下の例は、プライマリキーインデックスが消費するメモリの計算方法を示しています：
    - プライマリキーモデルが存在し、プライマリキーが `dt`、`id` で、データ型が DATE（4バイト）、BIGINT（8バイト）であると仮定します。したがって、プライマリキーは12バイトを占めます。
    - そのテーブルのアクティブデータが1000万行で、3つのレプリカで保存されていると仮定します。
    - メモリ消費の計算方法は：`(12 + 9(固定オーバーヘッド) ) * 1000万 * 3 * 1.5（ハッシュテーブルの平均追加オーバーヘッド) = 945MB`

- `ORDER BY` キーワードを使用してソートキーを指定し、任意の列の組み合わせを指定できます。

  > 注意：
  >
  > ソートキーを指定した場合は、ソートキーに基づいてプレフィックスインデックスが構築されます。ソートキーを指定しない場合は、プライマリキーに基づいてプレフィックスインデックスが構築されます。

- ALTER TABLE を使用してテーブル構造を変更することができますが、以下の注意点があります：

  - プライマリキーの変更はサポートされていません。
  - ソートキーについては、ALTER TABLE ... ORDER BY ... を使用してソートキーを再指定することがサポートされています。ソートキーの削除や、ソートキーの列のデータ型の変更はサポートされていません。
  - 列の順序を変更することはサポートされていません。

- 2.3 バージョン以降、プライマリキー以外の列に BITMAP、HLL データ型を追加することがサポートされています。

- テーブル作成時に、プライマリキー以外の列に BITMAP、Bloom Filter などのインデックスを作成することがサポートされています。

- 2.4 バージョン以降、プライマリキーモデルのテーブルに対して[非同期マテリアライズドビュー](../../using_starrocks/Materialized_view.md)を作成することがサポートされています。

## 次のステップ

テーブル作成が完了したら、インポートジョブを作成してデータをテーブルにインポートできます。具体的なインポート方法については、[インポート概要](../../loading/Loading_intro.md)を参照してください。
主キーモデルのテーブルデータを更新する必要がある場合、[インポート](../../loading/Load_to_Primary_Key_tables.md)機能を使用するか、DMLステートメント（[UPDATE](../../sql-reference/sql-statements/data-manipulation/UPDATE.md)または[DELETE](../../sql-reference/sql-statements/data-manipulation/DELETE.md)）を実行して行うことができ、更新操作はアトミックです。
