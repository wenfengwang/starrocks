---
displayed_sidebar: Chinese
---

# StarRocks のテーブル設計を理解する

## 列指向ストレージ

![列指向ストレージ](../assets/3.1-1.png)

StarRocks のテーブルは行と列で構成されています。各行のデータはユーザーのレコードに対応し、各列のデータは同じデータ型を持っています。すべてのデータ行は同じ数の列を持ち、列の動的な追加や削除が可能です。StarRocks では、テーブルの列は次元列（Key 列とも呼ばれる）と指標列（Value 列とも呼ばれる）に分けられます。次元列はグループ化とソートに使用され、指標列の値は集約関数 [sum](../sql-reference/sql-functions/aggregate-functions/sum.md)、[count](../sql-reference/sql-functions/aggregate-functions/count.md)、[min](../sql-reference/sql-functions/aggregate-functions/min.md)、[max](../sql-reference/sql-functions/aggregate-functions/max.md)、[hll_union_agg](../sql-reference/sql-functions/aggregate-functions/hll_union_agg.md) および [bitmap_union](../sql-reference/sql-functions/bitmap-functions/bitmap_union.md) などで集計されます。

StarRocks では、テーブルデータは列単位で格納されます。物理的には、列データはブロックエンコーディング、圧縮などの処理を経て、非揮発性デバイスに永続的に保存されます。しかし、論理的には、列データは同じ型の要素から構成される配列と見なすことができます。一行のデータのすべての列値は、それぞれの配列内で列の順序に従って配置され、同じ配列インデックスを持っています。配列インデックスは暗黙的であり、保存する必要はありません。テーブル内のすべての行は次元列によって複数回ソートされ、ソートされた位置がその行の行番号となります。

クエリ時に、次元列に等価条件または範囲条件が指定され、これらの条件に含まれる次元列がテーブルの次元列プレフィックスを構成できる場合、データの順序性を利用して二分探索を使用して目的の行を迅速に特定できます。例えば、テーブル `table1` には `event_day`、`siteid`、`citycode`、`username` の4つの列が含まれており、`event_day` と `siteid` は次元列です。クエリ条件が `event_day = 2020-09-18` と `siteid = 2` の場合、`event_day` と `siteid` は次元列プレフィックスを構成できるため、二分探索を使用して、指定された範囲内のデータのみを処理することができます。しかし、クエリ条件が `citycode = 4` と `username = Andy` の場合、`citycode` と `username` は次元列プレフィックスを構成できないため、二分探索を使用することはできず、テーブル全体のデータを処理する必要があります。

## インデックス

StarRocks はプレフィックスインデックス（Prefix Index）と列レベルインデックスを使用して、目的の行が存在するデータブロックの開始行番号を迅速に見つけることができます。

StarRocks のテーブル設計の原理は以下の図に示されています。

![スパースインデックス](../assets/3.1-2.png)

テーブル内のデータは主に以下の3つの部分で構成されています：

- プレフィックスインデックス

  テーブル内の1024行ごとにデータブロック（Data Block）が形成されます。各データブロックはプレフィックスインデックステーブルにインデックス項目を1つ持ち、その内容はデータブロックの最初の行の次元列によって構成されるプレフィックスで、長さは36バイトを超えません。プレフィックスインデックスはスパースインデックスの一種です。テーブル内のある行のデータの次元列によって構成されるプレフィックスを使用してプレフィックスインデックステーブルを検索すると、その行のデータが存在するデータブロックの開始行番号を特定できます。

- 列レベルデータブロック

  テーブル内の各列データは64KBごとにブロックに分割されて格納されます。データブロックは単位として個別にエンコード、圧縮され、I/O 単位としても機能し、デバイスに一括して書き込まれたり読み出されたりします。

- 列レベルインデックス

  テーブル内の各列データには独立した行番号インデックスがあります。行番号インデックステーブルでは、その列のデータブロックと行番号が一対一で対応しています。各行番号インデックス項目は、対応するデータブロックの開始行番号、位置、長さの情報で構成されています。ある行のデータの行番号を使用して行番号インデックステーブルを検索すると、その行番号に対応するデータブロックの位置を取得でき、目的のデータブロックを読み出した後、さらにデータを検索することができます。

したがって、ある行のデータの次元列によって構成されるプレフィックスを使用してその行のデータを検索するプロセスには、以下の5つのステップが含まれます：

1. まずプレフィックスインデックステーブルを検索して、データブロックの開始行番号を取得します。
2. 次元列の行番号インデックスを検索して、次元列のデータブロックを特定します。
3. データブロックを読み出します。
4. データブロックを解凍・デコードします。
5. データブロックから次元列プレフィックスに対応するデータ項目を見つけます。

## 処理の高速化

StarRocks は以下のメカニズムを通じてデータ処理の高速化を実現します：

### 事前集約

StarRocks は集約モデルをサポートしており、次元列の値が同じデータ行は1行にマージすることができます。マージ後、データ行の次元列の値は変わらず、指標列の値はこれらのデータ行の集約結果となります。指標列に集約関数を指定する必要があります。事前集約により、集約操作を高速化できます。

### パーティショニングとバケッティング

StarRocks では、テーブルは複数のタブレットに分割され、各タブレットはBE上で複数のレプリカとして冗長に保存されます。BEとタブレットの数は、計算リソースとデータ規模の変化に応じて弾力的にスケールすることができます。クエリ時には、複数のBEが並行してタブレットを検索し、迅速にデータを取得することができます。さらに、タブレットのレプリカは複製や移動が可能で、データの信頼性を高め、データの偏りを防ぐことができます。要するに、パーティショニングとバケッティングはデータアクセスの効率性と安定性を効果的に保証します。

### マテリアライズドビュー

プレフィックスインデックスはデータ検索を高速化できますが、プレフィックスインデックスは次元列の順序に依存しています。プレフィックスでない次元列を使用して検索述語を構築する場合、プレフィックスインデックスを使用することはできません。データテーブルにマテリアライズドビューを作成することができます。マテリアライズドビューのデータ構造と保存はデータテーブルと同じですが、マテリアライズドビューは独自のプレフィックスインデックスを持っています。マテリアライズドビューのインデックスを作成する際には、集約の粒度、列の数、次元列の順序を指定することができ、頻繁に使用されるクエリ条件が対応するマテリアライズドビューインデックスにヒットするようにすることができます。

### 列レベルインデックス

StarRocks はブルームフィルター（Bloom Filter）、ZoneMap インデックス、ビットマップ（Bitmap）インデックスなどの列レベルのインデックス技術をサポートしています：

- ブルームフィルターはデータブロックに検索値が含まれていないことを迅速に判断するのに役立ちます。

- ZoneMap インデックスはデータの範囲を使用して検索値を迅速にフィルタリングするのに役立ちます。

- ビットマップインデックスは、特定の条件を満たす列挙型の列の行を迅速に計算するのに役立ちます。
