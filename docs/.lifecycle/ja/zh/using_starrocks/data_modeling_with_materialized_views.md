---
displayed_sidebar: Chinese
---

# データモデリングにおけるマテリアライズドビューの使用

この記事では、StarRocks の非同期マテリアライズドビューを使用してデータモデリングを行う方法について説明し、データウェアハウスの ETL パイプラインを大幅に簡素化し、データ品質とクエリ性能を大幅に向上させる方法を紹介します。

## 概要

データモデリングは、合理的な方法でデータのクレンジング、階層化、集約、および関連付けを行うプロセスです。原始データの品質が低い、指標が多すぎて複雑すぎる、または集約されていないためにクエリコストが高くなる場合、原始データをモデリングして、理解しやすく、使用可能なデータ結果を得ることができます。

しかし、現実のデータモデリングでは、モデリングプロセスがビジネスの発展に追いつくのが難しく、データモデリングの投資収益率を測定することが難しいという矛盾がよく見られます。モデリング手法は単純ですが、ビジネスの専門家がデータの組織化とガバナンスに関して確かなバックグラウンドを持ち、データの整理と加工を行う必要があります。これは複雑なプロセスです。ビジネスの初期段階では、意思決定者は通常、データモデリングに十分なリソースを投入せず、データモデリングがもたらす価値を見るのが難しいです。さらに、ビジネスモデルが急速に変化する可能性があり、モデリング手法自体も継続的に反復され進化する必要があります。そのため、多くのデータアナリストはデータモデリングを使用せずに、直接原始データを使用することを好み、これによりデータ品質とクエリ性能の問題が避けられなくなります。モデリングのニーズが生じたとき、データの使用方法がすでに確立されており、再構築が困難になる問題に直面します。

StarRocks のマテリアライズドビューを使用したデータモデリングは、上記の問題を効果的に解決することができます。StarRocks の非同期マテリアライズドビューは以下の能力を持っています：

- **データウェアハウスアーキテクチャの簡素化**：StarRocks はワンストップデータガバナンス体験を提供するため、他のデータ処理システムやコンポーネントを維持する必要がなく、これらのシステムを維持するための人的および物理的リソースを節約できます。
- **モデリング体験の簡素化**：基本的な SQL 知識を持つデータアナリストは誰でも StarRocks を使用してデータモデリングを行うことができ、専門のデータエンジニアは必要ありません。
- **システムメンテナンスの簡素化**：StarRocks の非同期マテリアライズドビューは、データ間の階層と依存関係を自動的に管理できるため、データプラットフォーム全体でこのタスクを処理する必要はありません。

![Modeling-1](../assets/Modeling-1.png)

実際の状況では、以下に示すように StarRocks のビュー（論理ビュー）と非同期マテリアライズドビューを組み合わせてデータモデリングを行うことができます：

1. ビューを使用してリアルタイムデータとディメンションデータを関連付け、マテリアライズドビューを使用してデータレイクの履歴データとディメンションデータを関連付けます。同時に必要なデータクレンジングとビジネスセマンティックマッピングを行い、ビジネスセマンティックの詳細データを反映する中間層（Intermediate Layer）を得ます。
2. アプリケーション層（Application Layer）では、異なるビジネスシナリオに向けて、データの Join、Agg、Union、Window 計算を行い、リアルタイムリンク用のビューとニアリアルタイムリンク用のマテリアライズドビューを生成します。
3. アプリケーション側（Application）では、タイムリネスとパフォーマンスの要件に基づいて適切な分析データストレージ（ADS）を選択してクエリ分析を行い、リアルタイムの大画面、ニアリアルタイム BI、アドホッククエリ、定時レポートなどのニーズに対応します。

このプロセスでは、次のセクションで詳細に説明される StarRocks のいくつかの組み込み機能を利用します。

## 非同期マテリアライズドビューの機能

StarRocks の非同期マテリアライズドビューは、以下の原子機能を備えており、データモデリングを支援します：

- **自動リフレッシュ**：データがベーステーブルにインポートされた後、マテリアライズドビューは自動的にリフレッシュされます。外部でスケジュールタスクを維持する必要はありません。
- **パーティションリフレッシュ**：時系列属性を持つレポートを通じて、パーティションリフレッシュによりニアリアルタイム計算を実現できます。
- **ビューとの協調使用**：マテリアライズドビューと論理ビューを協調して使用することで、複数層のモデリングを実現し、中間層の再利用とデータモデルの簡素化が可能になります。
- **スキーマ変更**：複雑なデータパイプラインを変更することなく、単純な SQL ステートメントで計算結果を変更できます。

これらの機能を活用することで、さまざまなビジネスニーズとシナリオに対応する包括的で柔軟なデータモデルを設計できます。

### 自動リフレッシュ

非同期マテリアライズドビューを作成する際、REFRESH 句を使用してリフレッシュ戦略を指定できます。現在、StarRocks の非同期マテリアライズドビューは以下のリフレッシュ戦略をサポートしています：

- 自動リフレッシュ（`REFRESH ASYNC`）：ベーステーブルのデータが変更されるたびに、リフレッシュタスクがトリガーされます。データの依存関係はマテリアライズドビューによって自動的に管理されます。
- 定期リフレッシュ（`REFRESH ASYNC EVERY (INTERVAL <refresh_interval>)`）：定期的にリフレッシュタスクをトリガーします。たとえば、毎分、毎日、または毎月です。ベーステーブルにデータ変更がない場合、リフレッシュタスクはトリガーされません。
- 手動リフレッシュ（`REFRESH MANUAL`）：`REFRESH MATERIALIZED VIEW` を手動で実行することによってのみリフレッシュタスクをトリガーできます。外部のスケジュールフレームワークを通じてリフレッシュタスクをトリガーする場合、このリフレッシュ戦略を使用できます。

構文：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH 
    [ ASYNC | 
      ASYNC [START <time>] EVERY(<interval>) | 
      MANUAL
    ]
AS <query>
```

### パーティションリフレッシュ

非同期マテリアライズドビューを作成する際、PARTITION BY 句を使用してベーステーブルのパーティションとマテリアライズドビューのパーティションを関連付けることで、パーティション粒度のリフレッシュを実現できます。

- `PARTITION BY <column>`：ベーステーブルと同じパーティション列をマテリアライズドビューに参照させることで、ベーステーブルとマテリアライズドビューが同じパーティション粒度を使用できます。
- `PARTITION BY date_trunc(<column>)`：date_trunc 関数を使用してベーステーブルのパーティション列を上にロールアップし、マテリアライズドビューに異なる粒度のパーティション戦略を指定できます。
- `PARTITION BY { time_slice | date_slice }(<column>)`：date_trunc と比較して、time_slice と date_slice はより柔軟な時間粒度の調整を提供し、時間パーティションの粒度をより細かく制御できます。

構文：

```SQL
CREATE MATERIALIZED VIEW <name>
REFRESH ASYNC
PARTITION BY 
    [
        <base_table_column> | 
        date_trunc(<granularity>, <base_table_column>) |
        time_slice(<base_table_column>, <granularity>) | 
        date_slice(<base_table_column>, <granularity>)
    ]
AS <query>
```

### ビューとの協調使用

- ビューを基にマテリアライズドビューを作成できます。この場合、ビューが参照するベーステーブルにデータ変更があると、マテリアライズドビューは自動的にリフレッシュされます。
- 他のマテリアライズドビューを基にマテリアライズドビューを作成し、複数レベルのカスケードリフレッシュを実現できます。
- マテリアライズドビューを基にビューを作成できます。これは通常のテーブルを基に作成するのと同じです。

### スキーマ変更

- 非同期マテリアライズドビューは、ALTER MATERIALIZED VIEW SWAP ステートメントを使用して原子的に置き換えることができます。新しいマテリアライズドビューを作成し、新しい列を追加したり、列のタイプを変更したりしてから、古いマテリアライズドビューと置き換えることができます。
- ビューは ALTER VIEW ステートメントを使用して直接定義を変更できます。
- StarRocks の通常のテーブルは、SWAP または ALTER 操作を使用して変更できます。
- さらに、ベーステーブル（マテリアライズドビュー、ビュー、または通常のテーブルである可能性があります）に変更があると、関連するマテリアライズドビューでカスケード変更がトリガーされます。

## 階層モデリング

多くの実際のビジネスシナリオでは、リアルタイムの詳細データ、ディメンションデータ、およびデータレイクのアーカイブデータを含むさまざまな形式のデータソースが存在します。一方で、ビジネスニーズはリアルタイムの大画面、ニアリアルタイムの BI クエリ、アナリストのアドホッククエリ、定時レポートなど、多様な分析方法を必要としています。異なるシナリオには異なる要件があります - 一部は柔軟性を、他の一部はパフォーマンスを優先し、また他の一部はコスト効率を強調します。

显然，单一解决方案无法充分满足如此多样化的需求。StarRocks 可以通过结合使用视图和物化视图高效地满足这些需求。因为视图不维护物理数据，每次查询视图时，查询会根据视图的定义进行解析和执行。相比之下，物化视图保存了预计算的结果，可以避免重复执行的开销。视图适合表达业务语义并简化 SQL 复杂性，但无法降低查询执行的开销。另一方面，物化视图通过预先计算优化查询性能，适用于简化 ETL パイプライン。

以下为视图与物化视图的差异：

|                | **视图**                                   | **物化视图**                                       |
| -------------- | ------------------------------------------ | -------------------------------------------------- |
| **使用场景**   | 业务建模、数据治理                         | 数据建模、透明加速、湖仓一体                       |
| **存储开销**   | 不存储数据，无存储开销                     | 存储预计算结果，有额外存储成本                     |
| **更新开销**   | 无更新开销                                 | 基表数据更新时，有更新开销                         |
| **性能收益**   | 不做预计算，无性能收益                     | 预计算结果，加速查询                               |
| **数据实时性** | 查询视图时返回最新数据                     | 结果为预计算，可能存在数据延迟                     |
| **依赖关系**   | 基于表名引用基表，基表名变更将导致视图失效 | 基于 ID 引用基表，基表名变更不影响物化视图可用性。 |
| **创建语法**   | CREATE VIEW                                | CREATE MATERIALIZED VIEW                           |
| **修改语法**   | ALTER VIEW                                 | ALTER MATERIALIZED VIEW                            |

您可以使用以下语句来修改您的视图、物化视图和基表：

```SQL
-- 修改基表。
ALTER TABLE <table_name> ADD COLUMN <column_desc>;

-- 原子替换基表。
ALTER TABLE <table1> SWAP WITH <table2>;

-- 修改视图定义。
ALTER VIEW <view_name> AS <query>;

-- 原子替换物化视图（替换两个物化视图的名字，并不修改其中数据）。
ALTER MATERIALIZED VIEW <mv1> SWAP WITH <mv2>;

-- 重新启用物化视图。
ALTER MATERIALIZED VIEW <mv_name> ACTIVE;
```

Schema Change 遵循以下原则：

- 表的重命名以及原子替换操作将导致依赖其的物化视图变为 Inactive 状态。对于 Schema Change 操作，仅当物化视图依赖的基表列发生 Schema Change 时，才会导致物化视图变为 Inactive 状态。
- 视图的定义变更将导致依赖其的物化视图变为 Inactive 状态。
- 物化视图的原子替换操作将导致依赖其的嵌套物化视图变为 Inactive 状态。
- Inactive 状态会级联向上传播，直到没有物化视图依赖关系为止。
- Inactive 状态的物化视图无法刷新或用于自动查询改写。
- Inactive 状态的物化视图仍然可以直接查询，但在它们被变为 Active 之前，数据一致性不能得到保证。

由于 Inactive 状态的物化视图其数据一致性无法保证，您可以使用以下方法修复：

- **手动修复**：您可以通过执行 ALTER MATERIALIZED VIEW `<mv_name>` ACTIVE 手动修复 Inactive 状态的物化视图。此语句将根据物化视图原始 SQL 定义尝试重建。需要注意的是，重建时需保证在底层 Schema Change 之后，SQL 定义仍然有效，否则操作将失败。
- **自动修复**：StarRocks 将尝试自动激活 Inactive 状态的物化视图，但时效性无法保证。

## 分区建模

除分层建模外，分区建模也是数据建模的一个重要方面。数据建模往往涉及根据业务语义关联数据，并根据时效性要求设置数据的生存时间（TTL）。分区建模在此过程中起着重要作用。不同的数据关联方式会产生不同的建模方法，如星型模式和雪花模式。这些模型有一个共同点 - 它们都使用事实表和维度表。一些业务场景需要多个大型事实表，而其他场景涉及复杂的维度表及其之间的复杂的关联关系。StarRocks 的物化视图支持事实表的分区关联，即事实表进行分区，而物化视图的 Join 结果按照同样的方式进行分区。

![Modeling-2](../assets/Modeling-2.png)

以上图为例，通过物化视图将事实表和多个维度表进行关联：

- 您需要在物化视图的分区键中指定特定基表（通常是事实表）的分区键来实现物化视图的分区关联（`PARTITION BY fact_tbl.col`）。一个物化视图仅能与一个基表做分区关联。
- 当被关联基表的某个分区中的数据发生变化时，物化视图中相应的分区将被刷新，但不影响其他分区。
- 当其他未被关联的基表发生变化时，默认情况下会刷新整个物化视图。然而，您可以选择忽略某些未关联表中的数据变化，以便在这些表中的数据发生变化时不刷新物化视图。

这种分区关联可以支持多种业务场景：

- **事实表更新**：您可以将事实表分区到细粒度级别，例如按日或按小时。在事实表更新后，物化视图中相应的分区将自动刷新。
- **维度表更新**：通常，维度表中的数据更新将导致所有关联结果的刷新，刷新代价较大。您可以选择忽略某些维度表中的数据更新，以避免刷新整个物化视图，或者您可以指定一个时间范围，从而只有在该时间范围内的分区才能被刷新。
- **外部表的自动刷新**：在类似于 Apache Hive 或 Apache Iceberg 这样的外部数据源中，数据往往以分区的粒度进行变更。StarRocks 的物化视图可以订阅外表分区级别的数据更新，只刷新物化视图的相应分区。
- **TTL**：在为物化视图设置分区策略时，您可以设置要保留的最近分区的数量，从而仅保留最新的数据。其对应的业务场景对数据时效性有较高要求，例如，分析师仅需要查询某个时间窗口内的最新数据，而无需保留所有历史数据。

您可以使用多个参数来控制刷新行为：

- `partition_refresh_number`：每次刷新操作中要刷新的分区数。
- `partition_ttl_number`：要保留的最近分区的数量。
- `excluded_trigger_tables`：为避免触发自动刷新而需要忽略的表。
- `auto_refresh_partitions_limit`：每次自动刷新操作中要刷新的分区数。

详细说明，请参见 [CREATE MATERIALIZED VIEW](../sql-reference/sql-statements/data-definition/CREATE_MATERIALIZED_VIEW.md)。

当前版本中，分区物化视图存在如下限制：

- 仅支持基于分区表创建分区物化视图。
- 仅支持 DATE 和 DATETIME 类型的分区列，不支持 STRING 类型。
- 仅支持使用 date_trunc、time_slice 和 date_slice 做分区上卷。
- 仅支持单个列作为分区列，不支持多分区列。

## 总结


StarRocks の非同期マテリアライズド・ビューを使用したデータモデリングでは、宣言型のモデリング言語を通じて、パイプラインの管理を簡素化し、データモデリングの効率と柔軟性を向上させることができます。

データモデリングのシナリオ以外にも、非同期マテリアライズド・ビューは、他のトランスペアレントなアクセラレーションシナリオや、湖仓一体シナリオにも適用可能で、データの価値をさらに引き出し、データ効率をさらに高めることができます。
