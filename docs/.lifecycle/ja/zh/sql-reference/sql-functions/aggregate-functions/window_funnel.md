---
displayed_sidebar: Chinese
---

# window_funnel

## 機能

スライディングタイムウィンドウ内のイベントリストを検索し、条件に一致するイベントチェーンの最大連続イベント数を計算します。この関数はファネル関数の一種で、一般的なコンバージョン分析手法として使用され、ユーザーの各ステージでの行動のコンバージョン率を分析するために使用されます。

この関数は以下のルールに従います：

- イベントチェーンの最初の条件から判断を開始します。データに条件に一致するイベントが含まれている場合、カウンターに1を加算し、そのイベントに対応する時間をスライディングウィンドウの開始時間とします。最初の条件に一致するデータが見つからない場合は、0を返します。

- スライディングウィンドウ内で、イベントチェーンのイベントが順番に発生する場合、カウンターは増加します。時間窓を超えると、カウンターは増加しません。

- 条件に一致するイベントチェーンが複数ある場合、最長のイベントチェーンを出力します。

この関数はバージョン2.3からサポートされています。

## 文法

```Haskell
BIGINT window_funnel(BIGINT window, DATE|DATETIME time, INT mode, array[cond1, cond2, ..., condN])
```

## パラメータ説明

- `window`：スライディングウィンドウのサイズで、BIGINT型です。単位は`time`パラメータの型に依存します。`time`がDATE型の場合は日単位、DATETIME型の場合は秒単位です。

- `time`：タイムスタンプを含む列。現在、DATEおよびDATETIME型をサポートしています。

- `mode`：イベントチェーンの選択モードで、INT型です。取りうる値は0、1、2、4です。
  - デフォルト値は`0`で、最も一般的なファネル計算を実行します。
  - モードが`1`の場合（ビットで第1位を設定）、`DEDUPLICATION`モードを意味し、選択されたイベントチェーンに重複するイベントは含まれません。例えば`array`パラメータが`[event_type='A', event_type='B', event_type='C', event_type='D']`で、元のイベントチェーンが"A-B-C-B-D"の場合、イベントBが重複しているため、選択されるイベントチェーンは"A-B-C"のみです。
  - モードが`2`の場合（ビットで第2位を設定）、`FIXED`モードを意味し、選択されたイベントチェーンに飛び越えるイベントは含まれません。`array`パラメータが上記と同じで、元のイベントチェーンが"A-B-D-C"の場合、イベントDが飛び越えているため、選択されるイベントチェーンは"A-B"のみです。
  - モードが`4`の場合（ビットで第3位を設定）、`INCREASE`モードを意味し、選択されたイベントチェーンでは、連続するイベントのタイムスタンプが厳密に増加している必要があります。**このモードはバージョン2.5からサポートされています。**

- `array`：定義されたイベントチェーンで、ARRAY型です。

## 戻り値の説明

BIGINT型の値を返し、スライディングウィンドウ内で条件に一致する最大連続イベント数です。

## 例

例1：異なる`uid`に対応する最大連続イベント数を選択し、ウィンドウは1800秒、選択モードは`0`です。

`action`というテーブルがあり、データは`uid`でソートされているとします：

```Plaintext
SELECT * FROM action;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | ブラウズ   | 2020-01-02 11:00:00 |
| 1    | クリック   | 2020-01-02 11:10:00 |
| 1    | 注文       | 2020-01-02 11:20:00 |
| 1    | 支払い     | 2020-01-02 11:30:00 |
| 1    | ブラウズ   | 2020-01-02 11:00:00 |
| 2    | 注文       | 2020-01-02 11:00:00 |
| 2    | 支払い     | 2020-01-02 11:10:00 |
| 3    | ブラウズ   | 2020-01-02 11:20:00 |
| 3    | クリック   | 2020-01-02 12:00:00 |
| 4    | ブラウズ   | 2020-01-02 11:50:00 |
| 4    | クリック   | 2020-01-02 12:00:00 |
| 5    | ブラウズ   | 2020-01-02 11:50:00 |
| 5    | クリック   | 2020-01-02 12:00:00 |
| 5    | 注文       | 2020-01-02 11:10:00 |
| 6    | ブラウズ   | 2020-01-02 11:50:00 |
| 6    | クリック   | 2020-01-02 12:00:00 |
| 6    | 注文       | 2020-01-02 12:10:00 |
+------+------------+---------------------+
17 rows in set (0.01 sec)
```

以下のSQLステートメントを実行して最大連続イベント数を計算します：

```Plaintext
SELECT uid,
       window_funnel(1800,time,0,[event_type='ブラウズ', event_type='クリック', 
        event_type='注文', event_type='支払い'])
        AS level
FROM action
GROUP BY uid
ORDER BY uid; 
+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     0 |
| 3    |     1 |
| 4    |     2 |
| 5    |     2 |
| 6    |     3 |
+------+-------+
```

以下のようになります：

- uid=1に一致するイベントチェーンは「ブラウズ-クリック-注文-支払い」で、結果は4です。最後のブラウズイベントの時間が条件に合わないため、カウントされませんでした。

- uid=2に対応するイベントチェーンは最初のイベント「ブラウズ」から始まっていないため、結果は0です。

- uid=3に対応するイベントチェーンは「ブラウズ」で、結果は1です。1800秒のウィンドウを超えた「クリック」イベントはカウントされませんでした。

- uid=4に対応するイベントチェーンは「ブラウズ-クリック」で、結果は2です。

- uid=5のイベントチェーンは「ブラウズ-クリック」で、結果は2です。注文時間がイベントチェーンに含まれていないため、カウントされませんでした。

- uid=6のイベントチェーンは「ブラウズ-クリック-注文」で、結果は3です。

例2：異なる`uid`に対応する最大連続イベント数を選択し、ウィンドウは1800秒、選択モードは`0`と`1`でそれぞれ計算します。


`action1` テーブルがあり、データは `time` でソートされているとします:

```Plaintext
mysql> select * from action1 order by time;
+------+------------+---------------------+ 
| uid  | event_type | time                |     
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 2    | 浏览       | 2020-01-02 11:00:01 |
| 1    | 点击       | 2020-01-02 11:10:00 |
| 1    | 下单       | 2020-01-02 11:29:00 |
| 1    | 点击       | 2020-01-02 11:29:50 |
| 1    | 支付       | 2020-01-02 11:30:00 |
| 1    | 点击       | 2020-01-02 11:40:00 |
+------+------------+---------------------+
7 rows in set (0.03 sec)
```

以下の SQL ステートメントを実行して、最大連続イベント数を計算します:

```Plaintext
SELECT uid,
       window_funnel(1800,time,0,[event_type='浏览', 
        event_type='点击', event_type='下单', event_type='支付'])
        AS level
FROM action1
GROUP BY uid
ORDER BY uid;

+------+-------+
| uid  | level |
+------+-------+
| 1    |     4 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

uid=1 の場合、"点击事件 (2020-01-02 11:29:50)" が重複しているにも関わらず、最終的に `4` が出力されます。これは `mode` が `0` であるためです。

`mode` を `1` に変更して重複を排除し、SQL を再実行します:

```Plaintext
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.05 sec)
```

出力は `3` で、重複を除外した最長のイベントチェーンは "浏览-点击-下单" です。

例3: `uid` に対応する最大連続イベント数を選択し、ウィンドウは1900秒で、選択モード `0` と `2` の結果をそれぞれ計算します。

`action2` テーブルがあり、データは `time` でソートされているとします:

```Plaintext
mysql> select * from action2 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 2    | 浏览       | 2020-01-02 11:00:01 |
| 1    | 点击       | 2020-01-02 11:10:00 |
| 1    | 支付       | 2020-01-02 11:30:00 |
| 1    | 下单       | 2020-01-02 11:31:00 |
+------+------------+---------------------+
5 rows in set (0.01 sec)
```

以下の SQL ステートメントを実行します:

```Plaintext
SELECT uid,
       window_funnel(1900,time,0,[event_type='浏览', event_type='点击', 
        event_type='下单', event_type='支付'])
        AS level
FROM action2
GROUP BY uid
ORDER BY uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     3 |
| 2    |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

uid=1 の場合、出力は `3` で、`mode` `0` を使用しているため、"支付 (2020-01-02 11:30:00)" という飛び越えたイベントがイベントチェーンの選択を妨げていません。

`mode` を `2` に変更して SQL を再実行します:

```Plaintext
SELECT uid,
       window_funnel(1900,time,2,[event_type='浏览', event_type='点击', 
        event_type='下单', event_type='支付'])
        AS level
FROM action2
GROUP BY uid
ORDER BY uid;
+------+-------+
| uid  | level |
+------+-------+
| 1    |     2 |
| 2    |     1 |
+------+-------+
2 rows in set (0.06 sec)
```

出力は `2` で、"支付" イベントが飛び越えたため、カウントが停止し、選択された最大のイベントチェーンは "浏览-点击" です。

例4: `uid` に対応する最大連続イベント数を選択し、ウィンドウは1900秒で、選択モード `0`（タイムスタンプは厳密に増加する必要はない）と `4`（タイムスタンプは厳密に増加する必要がある）の結果をそれぞれ計算します。

`action3` テーブルがあり、データは `time` でソートされているとします:

```Plaintext
select * from action3 order by time;
+------+------------+---------------------+
| uid  | event_type | time                |
+------+------------+---------------------+
| 1    | 浏览       | 2020-01-02 11:00:00 |
| 1    | 点击       | 2020-01-02 11:00:01 |
| 2    | 浏览       | 2020-01-02 11:00:03 |
| 1    | 下单       | 2020-01-02 11:00:31 |
| 2    | 点击       | 2020-01-02 11:00:03 |
| 2    | 下单       | 2020-01-02 11:01:03 |
+------+------------+---------------------+
6 rows in set (0.02 sec)
```

以下の SQL ステートメントを実行します:

```Plaintext
SELECT uid,
       window_funnel(1900,time,0,[event_type='浏览', event_type='点击',
        event_type='下单'])
        AS level
FROM action3
GROUP BY uid
ORDER BY uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     3 |
+------+-------+
2 rows in set (0.02 sec)
```

uid=1 と 2 の両方で出力は 3 です。

`mode` を `4` に変更して SQL を再実行します:

```Plaintext
SELECT uid, window_funnel(1900,time,4,[event_type='浏览', event_type='点击',
        event_type='下单'])
        AS level
FROM action3
GROUP BY uid
ORDER BY uid;
+------+-------+
| uid  | level |
+------+-------+
|    1 |     3 |
|    2 |     1 |
+------+-------+
2 rows in set (0.02 sec)
```

uid=2の場合、出力は1です。タイムスタンプが厳密に増加することが指定されているため、このユーザーの「クリック」と「閲覧」が同じ秒に発生し、「閲覧」およびその後の行動は無視されます。

## キーワード

ファネル、ファネル関数、コンバージョン率、funnel
